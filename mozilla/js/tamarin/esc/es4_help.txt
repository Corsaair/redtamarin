
GOALS

  The purpose of this prototype is to provide a reusable (as in copiable)
  code base for exploring different aspects of the ES4 runtime compiler.
  The audience for this software consists of language developers. It is 
  not likely to be useful as a language engine but it should be useful as 
  a base for making a useful language engine - at least that's the goal

  Specific goals include:

  1/Implementing a parser for the full ES4 grammar
  2/Using E4X to explore the abstract syntax of ES4 programs
  3/Implementing the "definition" phase of the compiler
  4/Modelling all block structures (e.g. block statements, 
    classes, functions) as prologue-block pairs in the abstract 
    syntax, and emit those pairs uniformly as methods with traits
  5/Implementing packages and namespaces, import and use namespace
  6/Implementing multinames and unqualified name resolution

NON-GOALS

  Specific non-goals:

  1/Efficent intermediate representation of programs. A later
    experiment will attempt a compiler that avoids the use of
    an intermediate a.s.t altogether
  2/Modelling types. There are serious practical issues with
    implementing classes and instances as vanilla activation
    objects, like I have done here. We will want to use the 
    existing AVM support for types in any production version
  3/Implementing a useful subset of the language, including
    control flow statements and operator expressions
  4/Zero bugs

AREAS FOR FURTHER INVESTIGATION

  1/Efficiency - e.g. merging compiler phases to avoid 
    creation of a.s.t.s
  2/Compatibility with ES3/JS1
  3/Prototyping ES4 proposals
    * Static v. standard modes
    * Switch type
    * Enumerability
    * [done] Block scope (let)
    * Local packages
    * Iterators & generators
    * Date literals
    * Destructuring assignment
    * [done] Reserved words
    * Nullability
    * Namespace shadowing
    * Reformed ''with''
    * Type parameters
    * Self hosting object model
    * Structural types
    * is, as, to operators
    * Numbers (see Decmial)
    * Tail calls
    * Type definitions
    * Catchalls
    * Hashcodes
    * Intrinsic namespace
    * Operator overloading
    * Decimal
    * typeof
    * Regexp update
    * Unicode update
    * ES3 bug fixes

ABOUT THE CODE

  * I've used type annotations as sparingly as possible to keep 
    the coding process as fluid as possible. This lack of types 
    sometimes leads to hairy debugging sessions, but on the whole 
    has made the code more malleable than it would be otherwise
  * Variable names are all lower case with words separated by '_'
  * Method names are Java style except in some cases where
    they are part of a major interface and its leading lowercase 
    verb is dropped. For example, in the Emitter class what would
    have been called 'emitGetProperty' is named 'GetProperty'
  * I've used dynamic object features such as E4X and Array and 
    Object extensively and classes sparingly. Again this is to 
    keep design decisions from getting prematurely encrusted in the 
    code
  * I've used namespaces to switch modes at compile time (mostly).
    There are two pairs of opposing namespaces: 'debug' and 'release' 
    are used to control the printing of trace information; 'avm' and
    'ast' are used as alternative interpreters - ast, the tree walking 
    interpreter is currently too incomplete to be interesting - avm 
    is the primary interpreter

