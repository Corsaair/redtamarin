/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* machine generated file -- do not edit */

#ifndef _H_nativegen_header_shell_toplevel
#define _H_nativegen_header_shell_toplevel

namespace avmplus {
    class AccessibilityClass; // flash.accessibility::Accessibility$
    class AccessibilityImplementationClass; // flash.accessibility::AccessibilityImplementation$
    class AccessibilityImplementationObject; // flash.accessibility::AccessibilityImplementation
    class AccessibilityObject; // flash.accessibility::Accessibility
    class AccessibilityPropertiesClass; // flash.accessibility::AccessibilityProperties$
    class AccessibilityPropertiesObject; // flash.accessibility::AccessibilityProperties
    class ActionScriptVersionClass; // flash.display::ActionScriptVersion$
    class ActionScriptVersionObject; // flash.display::ActionScriptVersion
    class ArrayObject; // Array
    class BinaryDataClass; // shell::BinaryData$
    class BinaryDataObject; // shell::BinaryData
    class ByteArrayObject; // flash.utils::ByteArray
    class CErrorClass; // C.errno::CError$
    class CErrorObject; // C.errno::CError
    class CapabilitiesClass; // flash.system::Capabilities$
    class CapabilitiesObject; // flash.system::Capabilities
    class ClassClosure; // Class
    class ClassFactoryClass; // flash.sampler::ClassFactory$
    class ClassFactoryObject; // flash.sampler::ClassFactory
    class CoreEventLoopClass; // shell.async::CoreEventLoop$
    class CoreEventLoopObject; // shell.async::CoreEventLoop
    class DRMManagerErrorClass; // flash.errors::DRMManagerError$
    class DRMManagerErrorObject; // flash.errors::DRMManagerError
    class DeleteObjectSampleClass; // flash.sampler::DeleteObjectSample$
    class DeleteObjectSampleObject; // flash.sampler::DeleteObjectSample
    class DiagnosticsObject; // shell::Diagnostics
    class DomainClass; // shell::Domain$
    class DomainObject; // shell::Domain
    class EncryptedLocalStoreClass; // flash.data::EncryptedLocalStore$
    class EncryptedLocalStoreObject; // flash.data::EncryptedLocalStore
    class EndianClass; // flash.utils::Endian$
    class EndianObject; // flash.utils::Endian
    class EnvironmentClass; // shell::Environment$
    class EnvironmentObject; // shell::Environment
    class ErrorNumberClass; // C.errno::ErrorNumber$
    class ErrorNumberObject; // C.errno::ErrorNumber
    class EventClass; // flash.events::Event$
    class EventDispatcherClass; // flash.events::EventDispatcher$
    class EventDispatcherObject; // flash.events::EventDispatcher
    class EventLoopClass; // shell.async::EventLoop$
    class EventLoopInterface; // shell.async::EventLoop
    class EventObject; // flash.events::Event
    class FileIOObject; // shell::FileIO
    class FunctionObject; // Function
    class HTTPStatusEventClass; // flash.events::HTTPStatusEvent$
    class HTTPStatusEventObject; // flash.events::HTTPStatusEvent
    class HardwareInformationObject; // shell::HardwareInformation
    class IBitmapDrawableClass; // flash.display::IBitmapDrawable$
    class IBitmapDrawableInterface; // flash.display::IBitmapDrawable
    class IDrawCommandClass; // flash.display::IDrawCommand$
    class IDrawCommandInterface; // flash.display::IDrawCommand
    class IEventDispatcherClass; // flash.events::IEventDispatcher$
    class IEventDispatcherInterface; // flash.events::IEventDispatcher
    class IGraphicsDataClass; // flash.display::IGraphicsData$
    class IGraphicsDataInterface; // flash.display::IGraphicsData
    class IGraphicsFillClass; // flash.display::IGraphicsFill$
    class IGraphicsFillInterface; // flash.display::IGraphicsFill
    class IGraphicsPathClass; // flash.display::IGraphicsPath$
    class IGraphicsPathInterface; // flash.display::IGraphicsPath
    class IGraphicsStrokeClass; // flash.display::IGraphicsStroke$
    class IGraphicsStrokeInterface; // flash.display::IGraphicsStroke
    class ISearchableTextClass; // flash.accessibility::ISearchableText$
    class ISearchableTextInterface; // flash.accessibility::ISearchableText
    class ISimpleTextSelectionClass; // flash.accessibility::ISimpleTextSelection$
    class ISimpleTextSelectionInterface; // flash.accessibility::ISimpleTextSelection
    class InvalidSWFErrorClass; // flash.errors::InvalidSWFError$
    class InvalidSWFErrorObject; // flash.errors::InvalidSWFError
    class NewObjectSampleClass; // flash.sampler::NewObjectSample$
    class NewObjectSampleObject; // flash.sampler::NewObjectSample
    class OperatingSystemObject; // shell::OperatingSystem
    class Orientation3DClass; // flash.geom::Orientation3D$
    class Orientation3DObject; // flash.geom::Orientation3D
    class PNGEncoderOptionsClass; // flash.display::PNGEncoderOptions$
    class PNGEncoderOptionsObject; // flash.display::PNGEncoderOptions
    class PixelSnappingClass; // flash.display::PixelSnapping$
    class PixelSnappingObject; // flash.display::PixelSnapping
    class PointClass; // flash.geom::Point$
    class PointObject; // flash.geom::Point
    class ProgramObject; // shell::Program
    class RectangleClass; // flash.geom::Rectangle$
    class RectangleObject; // flash.geom::Rectangle
    class RunModeClass; // shell::RunMode$
    class RunModeObject; // shell::RunMode
    class RuntimeObject; // shell::Runtime
    class SQLCollationTypeClass; // flash.data::SQLCollationType$
    class SQLCollationTypeObject; // flash.data::SQLCollationType
    class SQLColumnNameStyleClass; // flash.data::SQLColumnNameStyle$
    class SQLColumnNameStyleObject; // flash.data::SQLColumnNameStyle
    class SQLColumnSchemaClass; // flash.data::SQLColumnSchema$
    class SQLColumnSchemaObject; // flash.data::SQLColumnSchema
    class SQLConnectionClass; // flash.data::SQLConnection$
    class SQLConnectionObject; // flash.data::SQLConnection
    class SQLErrorClass; // flash.errors::SQLError$
    class SQLErrorObject; // flash.errors::SQLError
    class SQLErrorOperationClass; // flash.errors::SQLErrorOperation$
    class SQLErrorOperationObject; // flash.errors::SQLErrorOperation
    class SQLIndexSchemaClass; // flash.data::SQLIndexSchema$
    class SQLIndexSchemaObject; // flash.data::SQLIndexSchema
    class SQLModeClass; // flash.data::SQLMode$
    class SQLModeObject; // flash.data::SQLMode
    class SQLResultClass; // flash.data::SQLResult$
    class SQLResultObject; // flash.data::SQLResult
    class SQLSchemaClass; // flash.data::SQLSchema$
    class SQLSchemaObject; // flash.data::SQLSchema
    class SQLSchemaResultClass; // flash.data::SQLSchemaResult$
    class SQLSchemaResultObject; // flash.data::SQLSchemaResult
    class SQLStatementClass; // flash.data::SQLStatement$
    class SQLStatementObject; // flash.data::SQLStatement
    class SQLTableSchemaClass; // flash.data::SQLTableSchema$
    class SQLTableSchemaObject; // flash.data::SQLTableSchema
    class SQLTransactionLockTypeClass; // flash.data::SQLTransactionLockType$
    class SQLTransactionLockTypeObject; // flash.data::SQLTransactionLockType
    class SQLTriggerSchemaClass; // flash.data::SQLTriggerSchema$
    class SQLTriggerSchemaObject; // flash.data::SQLTriggerSchema
    class SQLViewSchemaClass; // flash.data::SQLViewSchema$
    class SQLViewSchemaObject; // flash.data::SQLViewSchema
    class SWFVersionClass; // flash.display::SWFVersion$
    class SWFVersionObject; // flash.display::SWFVersion
    class SampleClass; // flash.sampler::Sample$
    class SampleObject; // flash.sampler::Sample
    class SceneClass; // flash.display::Scene$
    class SceneObject; // flash.display::Scene
    class ScriptTimeoutErrorClass; // flash.errors::ScriptTimeoutError$
    class ScriptTimeoutErrorObject; // flash.errors::ScriptTimeoutError
    class StackFrameClass; // flash.sampler::StackFrame$
    class StackFrameObject; // flash.sampler::StackFrame
    class StackOverflowErrorClass; // flash.errors::StackOverflowError$
    class StackOverflowErrorObject; // flash.errors::StackOverflowError
    class StageAlignClass; // flash.display::StageAlign$
    class StageAlignObject; // flash.display::StageAlign
    class StageAspectRatioClass; // flash.display::StageAspectRatio$
    class StageAspectRatioObject; // flash.display::StageAspectRatio
    class StageDisplayStateClass; // flash.display::StageDisplayState$
    class StageDisplayStateObject; // flash.display::StageDisplayState
    class StageOrientationClass; // flash.display::StageOrientation$
    class StageOrientationObject; // flash.display::StageOrientation
    class StageQualityClass; // flash.display::StageQuality$
    class StageQualityObject; // flash.display::StageQuality
    class StageScaleModeClass; // flash.display::StageScaleMode$
    class StageScaleModeObject; // flash.display::StageScaleMode
    class String; // String
    class SystemObject; // flash.system::System
    class TimerClass; // flash.utils::Timer$
    class TimerEventClass; // flash.events::TimerEvent$
    class TimerEventObject; // flash.events::TimerEvent
    class TimerObject; // flash.utils::Timer
    class TraceClass; // flash.trace::Trace$
    class TraceObject; // flash.trace::Trace
    class TriangleCullingClass; // flash.display::TriangleCulling$
    class TriangleCullingObject; // flash.display::TriangleCulling
    class UIntVectorObject; // __AS3__.vec::Vector$uint
    class URLRequestHeaderClass; // flash.net::URLRequestHeader$
    class URLRequestHeaderObject; // flash.net::URLRequestHeader
    class WorkerEventClass; // flash.system::WorkerEvent$
    class WorkerEventObject; // flash.system::WorkerEvent
    class WorkerStateClass; // flash.system::WorkerState$
    class WorkerStateObject; // flash.system::WorkerState
    class __ctypeObject; // C.ctype::__ctype
    class __errnoObject; // C.errno::__errno
    class __fcntlObject; // C.fcntl::__fcntl
    class __limitsObject; // C.limits::__limits
    class __localeObject; // C.locale::__locale
    class __netdbObject; // C.netdb::__netdb
    class __netinetObject; // C.netinet::__netinet
    class __signalObject; // C.signal::__signal
    class __socketObject; // C.sys.socket::__socket
    class __statObject; // C.sys.stat::__stat
    class __stdioObject; // C.stdio::__stdio
    class __stdlibObject; // C.stdlib::__stdlib
    class __timeObject; // C.time::__time
    class __unistdObject; // C.unistd::__unistd
    class __waitObject; // C.sys.wait::__wait
    class addrinfoClass; // C.netdb::addrinfo$
    class addrinfoObject; // C.netdb::addrinfo
    class in6_addrClass; // C.netinet::in6_addr$
    class in6_addrObject; // C.netinet::in6_addr
    class in_addrClass; // C.netinet::in_addr$
    class in_addrObject; // C.netinet::in_addr
    class ipv6_mreqClass; // C.netinet::ipv6_mreq$
    class ipv6_mreqObject; // C.netinet::ipv6_mreq
    class msghdrClass; // C.sys.socket::msghdr$
    class msghdrObject; // C.sys.socket::msghdr
    class netentClass; // C.netdb::netent$
    class netentObject; // C.netdb::netent
    class serventClass; // C.netdb::servent$
    class serventObject; // C.netdb::servent
    class sockaddrClass; // C.sys.socket::sockaddr$
    class sockaddrObject; // C.sys.socket::sockaddr
    class sockaddr_in6Class; // C.netinet::sockaddr_in6$
    class sockaddr_in6Object; // C.netinet::sockaddr_in6
    class sockaddr_inClass; // C.netinet::sockaddr_in$
    class sockaddr_inObject; // C.netinet::sockaddr_in
    class sockaddr_storageClass; // C.sys.socket::sockaddr_storage$
    class sockaddr_storageObject; // C.sys.socket::sockaddr_storage
    class sockdClass; // C.sys.socket::sockd$
    class sockdObject; // C.sys.socket::sockd
}

namespace avmshell {
    class CDIRClass; // C.dirent::DIR$
    class CDIRObject; // C.dirent::DIR
    class CErrnoClass; // C.errno::__errno$
    class CFILEClass; // C.stdio::FILE$
    class CFILEObject; // C.stdio::FILE
    class CFcntlClass; // C.fcntl::__fcntl$
    class CLimitsClass; // C.limits::__limits$
    class CLocaleClass; // C.locale::__locale$
    class CNetdbClass; // C.netdb::__netdb$
    class CNetinetInClass; // C.netinet::__netinet$
    class CSignalClass; // C.signal::__signal$
    class CStatusClass; // C.sys.stat::status$
    class CStatusObject; // C.sys.stat::status
    class CStdioClass; // C.stdio::__stdio$
    class CStdlibClass; // C.stdlib::__stdlib$
    class CSysSocketClass; // C.sys.socket::__socket$
    class CSysStatClass; // C.sys.stat::__stat$
    class CSysWaitClass; // C.sys.wait::__wait$
    class CTimeClass; // C.time::__time$
    class CTypeClass; // C.ctype::__ctype$
    class CUnistdClass; // C.unistd::__unistd$
    class CWaitStatusClass; // C.sys.wait::wait_status$
    class CWaitStatusObject; // C.sys.wait::wait_status
    class CdirentClass; // C.dirent::dirent$
    class CdirentObject; // C.dirent::dirent
    class Cdiv_tClass; // C.stdlib::div_t$
    class Cdiv_tObject; // C.stdlib::div_t
    class Cfpos_tClass; // C.stdio::fpos_t$
    class Cfpos_tObject; // C.stdio::fpos_t
    class ChostentClass; // C.netdb::hostent$
    class ChostentObject; // C.netdb::hostent
    class Cldiv_tClass; // C.stdlib::ldiv_t$
    class Cldiv_tObject; // C.stdlib::ldiv_t
    class Clldiv_tClass; // C.stdlib::lldiv_t$
    class Clldiv_tObject; // C.stdlib::lldiv_t
    class Cpid_tClass; // C.spawn::pid_t$
    class Cpid_tObject; // C.spawn::pid_t
    class CprotoentClass; // C.netdb::protoent$
    class CprotoentObject; // C.netdb::protoent
    class Csiginfo_tClass; // C.signal::siginfo_t$
    class Csiginfo_tObject; // C.signal::siginfo_t
    class CsigvalClass; // C.signal::sigval$
    class CsigvalObject; // C.signal::sigval
    class DiagnosticsClass; // shell::Diagnostics$
    class FileClass; // shell::FileIO$
    class HardwareInformationClass; // shell::HardwareInformation$
    class OperatingSystemClass; // shell::OperatingSystem$
    class ProgramClass; // shell::Program$
    class RuntimeClass; // shell::Runtime$
    class ShellWorkerClass; // flash.system::Worker$
    class ShellWorkerDomainClass; // flash.system::WorkerDomain$
    class ShellWorkerDomainObject; // flash.system::WorkerDomain
    class ShellWorkerObject; // flash.system::Worker
    class SystemClass; // flash.system::System$
}

namespace avmplus { namespace NativeID {

extern const uint32_t shell_toplevel_abc_class_count;
extern const uint32_t shell_toplevel_abc_script_count;
extern const uint32_t shell_toplevel_abc_method_count;
extern const uint32_t shell_toplevel_abc_length;
extern const uint8_t shell_toplevel_abc_data[];
extern const char* const shell_toplevel_versioned_uris[];
AVMTHUNK_DECLARE_NATIVE_INITIALIZER(shell_toplevel)

/* classes */
const uint32_t abcclass_C_ctype___ctype = 0;
const uint32_t abcclass_C_errno___errno = 1;
const uint32_t abcclass_C_errno_ErrorNumber = 2;
const uint32_t abcclass_C_errno_CError = 3;
const uint32_t abcclass_C_limits___limits = 4;
const uint32_t abcclass_C_locale___locale = 5;
const uint32_t abcclass_C_signal___signal = 6;
const uint32_t abcclass_C_signal_sigval = 7;
const uint32_t abcclass_C_signal_siginfo_t = 8;
const uint32_t abcclass_C_stdio___stdio = 9;
const uint32_t abcclass_C_stdio_FILE = 10;
const uint32_t abcclass_C_stdio_fpos_t = 11;
const uint32_t abcclass_C_stdlib___stdlib = 12;
const uint32_t abcclass_C_stdlib_div_t = 13;
const uint32_t abcclass_C_stdlib_ldiv_t = 14;
const uint32_t abcclass_C_stdlib_lldiv_t = 15;
const uint32_t abcclass_C_time___time = 16;
const uint32_t abcclass_C_dirent_DIR = 17;
const uint32_t abcclass_C_dirent_dirent = 18;
const uint32_t abcclass_C_fcntl___fcntl = 19;
const uint32_t abcclass_C_netdb___netdb = 20;
const uint32_t abcclass_C_netdb_hostent = 21;
const uint32_t abcclass_C_netdb_netent = 22;
const uint32_t abcclass_C_netdb_protoent = 23;
const uint32_t abcclass_C_netdb_servent = 24;
const uint32_t abcclass_C_netdb_addrinfo = 25;
const uint32_t abcclass_C_netinet___netinet = 26;
const uint32_t abcclass_C_netinet_in_addr = 27;
const uint32_t abcclass_C_netinet_sockaddr_in = 28;
const uint32_t abcclass_C_netinet_in6_addr = 29;
const uint32_t abcclass_C_netinet_sockaddr_in6 = 30;
const uint32_t abcclass_C_netinet_ipv6_mreq = 31;
const uint32_t abcclass_C_spawn_pid_t = 32;
const uint32_t abcclass_C_sys_socket___socket = 33;
const uint32_t abcclass_C_sys_socket_sockd = 34;
const uint32_t abcclass_C_sys_socket_sockaddr = 35;
const uint32_t abcclass_C_sys_socket_sockaddr_storage = 36;
const uint32_t abcclass_C_sys_socket_msghdr = 37;
const uint32_t abcclass_C_sys_stat___stat = 38;
const uint32_t abcclass_C_sys_stat_status = 39;
const uint32_t abcclass_C_sys_wait___wait = 40;
const uint32_t abcclass_C_sys_wait_wait_status = 41;
const uint32_t abcclass_C_unistd___unistd = 42;
const uint32_t abcclass_shell_Program = 43;
const uint32_t abcclass_shell_Runtime = 44;
const uint32_t abcclass_shell_Diagnostics = 45;
const uint32_t abcclass_shell_HardwareInformation = 46;
const uint32_t abcclass_shell_OperatingSystem = 47;
const uint32_t abcclass_shell_RunMode = 48;
const uint32_t abcclass_shell_Domain = 49;
const uint32_t abcclass_shell_FileIO = 50;
const uint32_t abcclass_shell_Environment = 51;
const uint32_t abcclass_shell_BinaryData = 52;
const uint32_t abcclass_shell_async_EventLoop = 53;
const uint32_t abcclass_flash_accessibility_ISearchableText = 54;
const uint32_t abcclass_flash_accessibility_ISimpleTextSelection = 55;
const uint32_t abcclass_flash_accessibility_Accessibility = 56;
const uint32_t abcclass_flash_accessibility_AccessibilityImplementation = 57;
const uint32_t abcclass_flash_accessibility_AccessibilityProperties = 58;
const uint32_t abcclass_flash_data_EncryptedLocalStore = 59;
const uint32_t abcclass_flash_data_SQLCollationType = 60;
const uint32_t abcclass_flash_data_SQLColumnNameStyle = 61;
const uint32_t abcclass_flash_data_SQLColumnSchema = 62;
const uint32_t abcclass_flash_data_SQLConnection = 63;
const uint32_t abcclass_flash_data_SQLIndexSchema = 64;
const uint32_t abcclass_flash_data_SQLMode = 65;
const uint32_t abcclass_flash_data_SQLResult = 66;
const uint32_t abcclass_flash_data_SQLSchema = 67;
const uint32_t abcclass_flash_data_SQLSchemaResult = 68;
const uint32_t abcclass_flash_data_SQLStatement = 69;
const uint32_t abcclass_flash_data_SQLTableSchema = 70;
const uint32_t abcclass_flash_data_SQLTransactionLockType = 71;
const uint32_t abcclass_flash_data_SQLTriggerSchema = 72;
const uint32_t abcclass_flash_data_SQLViewSchema = 73;
const uint32_t abcclass_flash_display_IBitmapDrawable = 74;
const uint32_t abcclass_flash_display_IDrawCommand = 75;
const uint32_t abcclass_flash_display_IGraphicsData = 76;
const uint32_t abcclass_flash_display_IGraphicsFill = 77;
const uint32_t abcclass_flash_display_IGraphicsPath = 78;
const uint32_t abcclass_flash_display_IGraphicsStroke = 79;
const uint32_t abcclass_flash_display_ActionScriptVersion = 80;
const uint32_t abcclass_flash_display_PixelSnapping = 81;
const uint32_t abcclass_flash_display_PNGEncoderOptions = 82;
const uint32_t abcclass_flash_display_Scene = 83;
const uint32_t abcclass_flash_display_StageAlign = 84;
const uint32_t abcclass_flash_display_StageAspectRatio = 85;
const uint32_t abcclass_flash_display_StageDisplayState = 86;
const uint32_t abcclass_flash_display_StageOrientation = 87;
const uint32_t abcclass_flash_display_StageQuality = 88;
const uint32_t abcclass_flash_display_StageScaleMode = 89;
const uint32_t abcclass_flash_display_SWFVersion = 90;
const uint32_t abcclass_flash_display_TriangleCulling = 91;
const uint32_t abcclass_flash_errors_ScriptTimeoutError = 92;
const uint32_t abcclass_flash_errors_StackOverflowError = 93;
const uint32_t abcclass_flash_errors_InvalidSWFError = 94;
const uint32_t abcclass_flash_errors_SQLErrorOperation = 95;
const uint32_t abcclass_flash_errors_SQLError = 96;
const uint32_t abcclass_flash_errors_DRMManagerError = 97;
const uint32_t abcclass_flash_events_IEventDispatcher = 98;
const uint32_t abcclass_flash_events_Event = 99;
const uint32_t abcclass_flash_geom_Orientation3D = 100;
const uint32_t abcclass_flash_geom_Point = 101;
const uint32_t abcclass_flash_geom_Rectangle = 102;
const uint32_t abcclass_flash_net_URLRequestHeader = 103;
const uint32_t abcclass_flash_sampler_StackFrame = 104;
const uint32_t abcclass_flash_sampler_Sample = 105;
const uint32_t abcclass_flash_sampler_ClassFactory = 106;
const uint32_t abcclass_flash_system_Capabilities = 107;
const uint32_t abcclass_flash_system_System = 108;
const uint32_t abcclass_flash_system_WorkerState = 109;
const uint32_t abcclass_flash_system_Worker = 110;
const uint32_t abcclass_flash_system_WorkerEvent = 111;
const uint32_t abcclass_flash_system_WorkerDomain = 112;
const uint32_t abcclass_flash_trace_Trace = 113;
const uint32_t abcclass_flash_utils_Endian = 114;
const uint32_t abcclass_shell_async_CoreEventLoop = 115;
const uint32_t abcclass_flash_events_EventDispatcher = 116;
const uint32_t abcclass_flash_events_HTTPStatusEvent = 117;
const uint32_t abcclass_flash_events_TimerEvent = 118;
const uint32_t abcclass_flash_sampler_NewObjectSample = 119;
const uint32_t abcclass_flash_sampler_DeleteObjectSample = 120;
const uint32_t abcclass_flash_utils_Timer = 121;

/* methods */
const uint32_t native_script_function_flash_sampler_getMasterString = 14; // native
const uint32_t native_script_function_flash_sampler_getSavedThis = 15; // native
const uint32_t native_script_function_flash_sampler_getLexicalScopes = 16; // native
const uint32_t native_script_function_flash_sampler_isGetterSetter = 17; // native
const uint32_t native_script_function_flash_sampler__getInvocationCount = 18; // native
const uint32_t native_script_function_flash_sampler_getSampleCount = 22; // native
const uint32_t native_script_function_flash_sampler__getSamples = 23; // native
const uint32_t native_script_function_flash_sampler_getMemberNames = 25; // native
const uint32_t native_script_function_flash_sampler_getSize = 26; // native
const uint32_t native_script_function_flash_sampler__setSamplerCallback = 27; // native
const uint32_t native_script_function_flash_sampler_sampleInternalAllocs = 30; // native
const uint32_t native_script_function_flash_sampler_pauseSampling = 31; // native
const uint32_t native_script_function_flash_sampler_stopSampling = 32; // native
const uint32_t native_script_function_flash_sampler_startSampling = 33; // native
const uint32_t native_script_function_flash_sampler_clearSamples = 34; // native
const uint32_t native_script_function_C_unistd_ftruncate = 48; // native
const uint32_t native_script_function_C_unistd_fsync = 49; // native
const uint32_t native_script_function_C_unistd_execvp = 50; // native
const uint32_t native_script_function_C_unistd_execve = 51; // native
const uint32_t native_script_function_C_unistd_execv = 52; // native
const uint32_t native_script_function_C_unistd_execlp = 53; // native
const uint32_t native_script_function_C_unistd_execle = 54; // native
const uint32_t native_script_function_C_unistd_execl = 55; // native
const uint32_t native_script_function_C_unistd_dup2 = 56; // native
const uint32_t native_script_function_C_unistd_dup = 57; // native
const uint32_t native_script_function_C_unistd_close = 58; // native
const uint32_t native_script_function_C_unistd_chdir = 59; // native
const uint32_t native_script_function_C_unistd_access = 60; // native
const uint32_t native_script_function_C_sys_wait_waitpid = 61; // native
const uint32_t native_script_function_C_sys_wait_waitid = 62; // native
const uint32_t native_script_function_C_sys_wait_wait = 63; // native
const uint32_t native_script_function_C_sys_stat_umask = 71; // native
const uint32_t native_script_function_C_sys_stat_stat = 72; // native
const uint32_t native_script_function_C_sys_stat_fstat = 75; // native
const uint32_t native_script_function_C_sys_stat_chmod = 76; // native
const uint32_t native_script_function_C_spawn_spawnp = 84; // native
const uint32_t native_script_function_C_spawn_spawn = 85; // native
const uint32_t native_script_function_C_netdb_gethostent = 86; // native
const uint32_t native_script_function_C_netdb_getprotoent = 87; // native
const uint32_t native_script_function_C_netdb_getprotobynumber = 88; // native
const uint32_t native_script_function_C_fcntl_openat = 89; // native
const uint32_t native_script_function_C_fcntl_open = 90; // native
const uint32_t native_script_function_C_fcntl_fcntl = 91; // native
const uint32_t native_script_function_C_fcntl_creat = 92; // native
const uint32_t native_script_function_C_dirent_telldir = 93; // native
const uint32_t native_script_function_C_dirent_seekdir = 94; // native
const uint32_t native_script_function_C_dirent_rewinddir = 95; // native
const uint32_t native_script_function_C_dirent_readdir = 96; // native
const uint32_t native_script_function_C_dirent_opendir = 97; // native
const uint32_t native_script_function_C_dirent_fdopendir = 99; // native
const uint32_t native_script_function_C_dirent_dirfd = 100; // native
const uint32_t native_script_function_C_dirent_closedir = 101; // native
const uint32_t native_script_function_C_conio_kbhit = 102; // native
const uint32_t native_script_function_C_conio_echo = 103; // native
const uint32_t native_script_function_C_conio_canonical = 104; // native
const uint32_t native_script_function_C_string_strspn = 108; // native
const uint32_t native_script_function_C_string_strerror = 117; // native
const uint32_t native_script_function_C_string_strcoll = 118; // native
const uint32_t native_script_function_C_string_strcmp = 119; // native
const uint32_t native_script_function_C_stdlib_unsetenv = 122; // native
const uint32_t native_script_function_C_stdlib_system = 123; // native
const uint32_t native_script_function_C_stdlib_srand = 131; // native
const uint32_t native_script_function_C_stdlib_setenv = 132; // native
const uint32_t native_script_function_C_stdlib_realpath = 133; // native
const uint32_t native_script_function_C_stdlib_rand = 134; // native
const uint32_t native_script_function_C_stdlib_putenv = 135; // native
const uint32_t native_script_function_C_stdlib_mkstemp = 136; // native
const uint32_t native_script_function_C_stdlib_mkdtemp = 137; // native
const uint32_t native_script_function_C_stdlib_mblen = 138; // native
const uint32_t native_script_function_C_stdlib_lldiv = 140; // native
const uint32_t native_script_function_C_stdlib_ldiv = 141; // native
const uint32_t native_script_function_C_stdlib_getenv = 143; // native
const uint32_t native_script_function_C_stdlib_div = 145; // native
const uint32_t native_script_function_C_stdlib_atol = 147; // native
const uint32_t native_script_function_C_stdlib_atoi = 148; // native
const uint32_t native_script_function_C_stdlib_atof = 149; // native
const uint32_t native_script_function_C_stdio_rewind = 153; // native
const uint32_t native_script_function_C_stdio_rename = 154; // native
const uint32_t native_script_function_C_stdio_remove = 155; // native
const uint32_t native_script_function_C_stdio_popen = 156; // native
const uint32_t native_script_function_C_stdio_perror = 157; // native
const uint32_t native_script_function_C_stdio_pclose = 158; // native
const uint32_t native_script_function_C_stdio_getchar = 161; // native
const uint32_t native_script_function_C_stdio_fwrite = 163; // native
const uint32_t native_script_function_C_stdio_funlockfile = 164; // native
const uint32_t native_script_function_C_stdio_ftrylockfile = 165; // native
const uint32_t native_script_function_C_stdio_ftell = 166; // native
const uint32_t native_script_function_C_stdio_fsetpos = 167; // native
const uint32_t native_script_function_C_stdio_fseek = 168; // native
const uint32_t native_script_function_C_stdio_freopen = 169; // native
const uint32_t native_script_function_C_stdio_fread = 170; // native
const uint32_t native_script_function_C_stdio_fputs = 171; // native
const uint32_t native_script_function_C_stdio_fputc = 172; // native
const uint32_t native_script_function_C_stdio_fopen = 173; // native
const uint32_t native_script_function_C_stdio_flockfile = 174; // native
const uint32_t native_script_function_C_stdio_fileno = 175; // native
const uint32_t native_script_function_C_stdio_fgets = 176; // native
const uint32_t native_script_function_C_stdio_fgetpos = 177; // native
const uint32_t native_script_function_C_stdio_fgetc = 178; // native
const uint32_t native_script_function_C_stdio_fflush = 179; // native
const uint32_t native_script_function_C_stdio_ferror = 180; // native
const uint32_t native_script_function_C_stdio_feof = 181; // native
const uint32_t native_script_function_C_stdio_fdopen = 182; // native
const uint32_t native_script_function_C_stdio_fclose = 183; // native
const uint32_t native_script_function_C_stdio_clearerr = 184; // native
const uint32_t native_script_function_C_signal_kill = 185; // native
const uint32_t native_script_function_C_assert__debugBreak = 205; // native
const uint32_t C_ctype___ctype__avm_isalnum = 207; // native
const uint32_t C_ctype___ctype__avm_isalpha = 208; // native
const uint32_t C_ctype___ctype__avm_isascii = 209; // native
const uint32_t C_ctype___ctype__avm_isblank = 210; // native
const uint32_t C_ctype___ctype__avm_iscntrl = 211; // native
const uint32_t C_ctype___ctype__avm_isdigit = 212; // native
const uint32_t C_ctype___ctype__avm_isgraph = 213; // native
const uint32_t C_ctype___ctype__avm_islower = 214; // native
const uint32_t C_ctype___ctype__avm_isprint = 215; // native
const uint32_t C_ctype___ctype__avm_ispunct = 216; // native
const uint32_t C_ctype___ctype__avm_isspace = 217; // native
const uint32_t C_ctype___ctype__avm_isupper = 218; // native
const uint32_t C_ctype___ctype__avm_isxdigit = 219; // native
const uint32_t C_ctype___ctype__avm_toascii = 220; // native
const uint32_t C_ctype___ctype__avm_tolower = 221; // native
const uint32_t C_ctype___ctype__avm_toupper = 222; // native
const uint32_t C_errno___errno_EPERM_get = 225; // native
const uint32_t C_errno___errno_ENOENT_get = 226; // native
const uint32_t C_errno___errno_ESRCH_get = 227; // native
const uint32_t C_errno___errno_EINTR_get = 228; // native
const uint32_t C_errno___errno_EIO_get = 229; // native
const uint32_t C_errno___errno_ENXIO_get = 230; // native
const uint32_t C_errno___errno_E2BIG_get = 231; // native
const uint32_t C_errno___errno_ENOEXEC_get = 232; // native
const uint32_t C_errno___errno_EBADF_get = 233; // native
const uint32_t C_errno___errno_ECHILD_get = 234; // native
const uint32_t C_errno___errno_EAGAIN_get = 235; // native
const uint32_t C_errno___errno_ENOMEM_get = 236; // native
const uint32_t C_errno___errno_EACCES_get = 237; // native
const uint32_t C_errno___errno_EFAULT_get = 238; // native
const uint32_t C_errno___errno_ENOTBLK_get = 239; // native
const uint32_t C_errno___errno_EBUSY_get = 240; // native
const uint32_t C_errno___errno_EEXIST_get = 241; // native
const uint32_t C_errno___errno_EXDEV_get = 242; // native
const uint32_t C_errno___errno_ENODEV_get = 243; // native
const uint32_t C_errno___errno_ENOTDIR_get = 244; // native
const uint32_t C_errno___errno_EISDIR_get = 245; // native
const uint32_t C_errno___errno_EINVAL_get = 246; // native
const uint32_t C_errno___errno_ENFILE_get = 247; // native
const uint32_t C_errno___errno_EMFILE_get = 248; // native
const uint32_t C_errno___errno_ENOTTY_get = 249; // native
const uint32_t C_errno___errno_ETXTBSY_get = 250; // native
const uint32_t C_errno___errno_EFBIG_get = 251; // native
const uint32_t C_errno___errno_ENOSPC_get = 252; // native
const uint32_t C_errno___errno_ESPIPE_get = 253; // native
const uint32_t C_errno___errno_EROFS_get = 254; // native
const uint32_t C_errno___errno_EMLINK_get = 255; // native
const uint32_t C_errno___errno_EPIPE_get = 256; // native
const uint32_t C_errno___errno_EDOM_get = 257; // native
const uint32_t C_errno___errno_ERANGE_get = 258; // native
const uint32_t C_errno___errno_EDEADLK_get = 259; // native
const uint32_t C_errno___errno_ENAMETOOLONG_get = 260; // native
const uint32_t C_errno___errno_ENOLCK_get = 261; // native
const uint32_t C_errno___errno_ENOSYS_get = 262; // native
const uint32_t C_errno___errno_ENOTEMPTY_get = 263; // native
const uint32_t C_errno___errno_ELOOP_get = 264; // native
const uint32_t C_errno___errno_EWOULDBLOCK_get = 265; // native
const uint32_t C_errno___errno_ENOMSG_get = 266; // native
const uint32_t C_errno___errno_EIDRM_get = 267; // native
const uint32_t C_errno___errno_EDEADLOCK_get = 268; // native
const uint32_t C_errno___errno_ENOSTR_get = 269; // native
const uint32_t C_errno___errno_ENODATA_get = 270; // native
const uint32_t C_errno___errno_ETIME_get = 271; // native
const uint32_t C_errno___errno_ENOSR_get = 272; // native
const uint32_t C_errno___errno_ENOLINK_get = 273; // native
const uint32_t C_errno___errno_EBADMSG_get = 274; // native
const uint32_t C_errno___errno_EOVERFLOW_get = 275; // native
const uint32_t C_errno___errno_EILSEQ_get = 276; // native
const uint32_t C_errno___errno_ENOTSOCK_get = 277; // native
const uint32_t C_errno___errno_EDESTADDRREQ_get = 278; // native
const uint32_t C_errno___errno_EMSGSIZE_get = 279; // native
const uint32_t C_errno___errno_EPROTO_get = 280; // native
const uint32_t C_errno___errno_EPROTOTYPE_get = 281; // native
const uint32_t C_errno___errno_ENOPROTOOPT_get = 282; // native
const uint32_t C_errno___errno_EPROTONOSUPPORT_get = 283; // native
const uint32_t C_errno___errno_EOPNOTSUPP_get = 284; // native
const uint32_t C_errno___errno_EAFNOSUPPORT_get = 285; // native
const uint32_t C_errno___errno_EADDRINUSE_get = 286; // native
const uint32_t C_errno___errno_EADDRNOTAVAIL_get = 287; // native
const uint32_t C_errno___errno_ENETDOWN_get = 288; // native
const uint32_t C_errno___errno_ENETUNREACH_get = 289; // native
const uint32_t C_errno___errno_ENETRESET_get = 290; // native
const uint32_t C_errno___errno_ECONNABORTED_get = 291; // native
const uint32_t C_errno___errno_ECONNRESET_get = 292; // native
const uint32_t C_errno___errno_ENOBUFS_get = 293; // native
const uint32_t C_errno___errno_EISCONN_get = 294; // native
const uint32_t C_errno___errno_ENOTCONN_get = 295; // native
const uint32_t C_errno___errno_ETIMEDOUT_get = 296; // native
const uint32_t C_errno___errno_ECONNREFUSED_get = 297; // native
const uint32_t C_errno___errno_EHOSTUNREACH_get = 298; // native
const uint32_t C_errno___errno_EALREADY_get = 299; // native
const uint32_t C_errno___errno_EINPROGRESS_get = 300; // native
const uint32_t C_errno___errno_ECANCELED_get = 301; // native
const uint32_t C_errno___errno_EOWNERDEAD_get = 302; // native
const uint32_t C_errno___errno_ENOTRECOVERABLE_get = 303; // native
const uint32_t C_errno___errno_EREMOTE_get = 304; // native
const uint32_t C_errno___errno_EUSERS_get = 305; // native
const uint32_t C_errno___errno_ESOCKTNOSUPPORT_get = 306; // native
const uint32_t C_errno___errno_EPFNOSUPPORT_get = 307; // native
const uint32_t C_errno___errno_ESHUTDOWN_get = 308; // native
const uint32_t C_errno___errno_ETOOMANYREFS_get = 309; // native
const uint32_t C_errno___errno_EHOSTDOWN_get = 310; // native
const uint32_t C_errno___errno_ESTALE_get = 311; // native
const uint32_t C_errno___errno_EDQUOT_get = 312; // native
const uint32_t C_errno___errno_EMULTIHOP_get = 313; // native
const uint32_t C_errno___errno_ECHRNG_get = 314; // native
const uint32_t C_errno___errno_EL2NSYNC_get = 315; // native
const uint32_t C_errno___errno_EL3HLT_get = 316; // native
const uint32_t C_errno___errno_EL3RST_get = 317; // native
const uint32_t C_errno___errno_ELNRNG_get = 318; // native
const uint32_t C_errno___errno_EUNATCH_get = 319; // native
const uint32_t C_errno___errno_ENOCSI_get = 320; // native
const uint32_t C_errno___errno_EL2HLT_get = 321; // native
const uint32_t C_errno___errno_EBADE_get = 322; // native
const uint32_t C_errno___errno_EBADR_get = 323; // native
const uint32_t C_errno___errno_EXFULL_get = 324; // native
const uint32_t C_errno___errno_ENOANO_get = 325; // native
const uint32_t C_errno___errno_EBADRQC_get = 326; // native
const uint32_t C_errno___errno_EBADSLT_get = 327; // native
const uint32_t C_errno___errno_EBFONT_get = 328; // native
const uint32_t C_errno___errno_ENONET_get = 329; // native
const uint32_t C_errno___errno_ENOPKG_get = 330; // native
const uint32_t C_errno___errno_EADV_get = 331; // native
const uint32_t C_errno___errno_ESRMNT_get = 332; // native
const uint32_t C_errno___errno_ECOMM_get = 333; // native
const uint32_t C_errno___errno_EDOTDOT_get = 334; // native
const uint32_t C_errno___errno_ENOTUNIQ_get = 335; // native
const uint32_t C_errno___errno_EBADFD_get = 336; // native
const uint32_t C_errno___errno_EREMCHG_get = 337; // native
const uint32_t C_errno___errno_ELIBACC_get = 338; // native
const uint32_t C_errno___errno_ELIBBAD_get = 339; // native
const uint32_t C_errno___errno_ELIBSCN_get = 340; // native
const uint32_t C_errno___errno_ELIBMAX_get = 341; // native
const uint32_t C_errno___errno_ELIBEXEC_get = 342; // native
const uint32_t C_errno___errno_ERESTART_get = 343; // native
const uint32_t C_errno___errno_ESTRPIPE_get = 344; // native
const uint32_t C_errno___errno_EUCLEAN_get = 345; // native
const uint32_t C_errno___errno_ENOTNAM_get = 346; // native
const uint32_t C_errno___errno_ENAVAIL_get = 347; // native
const uint32_t C_errno___errno_EISNAM_get = 348; // native
const uint32_t C_errno___errno_EREMOTEIO_get = 349; // native
const uint32_t C_errno___errno_ENOMEDIUM_get = 350; // native
const uint32_t C_errno___errno_EMEDIUMTYPE_get = 351; // native
const uint32_t C_errno___errno_ENOKEY_get = 352; // native
const uint32_t C_errno___errno_EKEYEXPIRED_get = 353; // native
const uint32_t C_errno___errno_EKEYREVOKED_get = 354; // native
const uint32_t C_errno___errno_EKEYREJECTED_get = 355; // native
const uint32_t C_errno___errno_ERFKILL_get = 356; // native
const uint32_t C_errno___errno_EHWPOISON_get = 357; // native
const uint32_t C_errno___errno__GetErrno = 358; // native
const uint32_t C_errno___errno__SetErrno = 359; // native
const uint32_t C_errno_ErrorNumber_value_get = 363; // abc
const uint32_t C_errno_ErrorNumber_value_set = 364; // abc
const uint32_t C_errno_ErrorNumber_valueOf = 365; // abc
const uint32_t C_errno_ErrorNumber_toString = 366; // abc
const uint32_t C_limits___limits_CHAR_BIT_get = 370; // native
const uint32_t C_limits___limits_CHAR_MAX_get = 371; // native
const uint32_t C_limits___limits_CHAR_MIN_get = 372; // native
const uint32_t C_limits___limits_INT_MAX_get = 373; // native
const uint32_t C_limits___limits_INT_MIN_get = 374; // native
const uint32_t C_limits___limits_LLONG_MAX_get = 375; // native
const uint32_t C_limits___limits_LLONG_MIN_get = 376; // native
const uint32_t C_limits___limits_LONG_BIT_get = 377; // native
const uint32_t C_limits___limits_LONG_MAX_get = 378; // native
const uint32_t C_limits___limits_LONG_MIN_get = 379; // native
const uint32_t C_limits___limits_SCHAR_MAX_get = 380; // native
const uint32_t C_limits___limits_SCHAR_MIN_get = 381; // native
const uint32_t C_limits___limits_SHRT_MAX_get = 382; // native
const uint32_t C_limits___limits_SHRT_MIN_get = 383; // native
const uint32_t C_limits___limits_UCHAR_MAX_get = 384; // native
const uint32_t C_limits___limits_UINT_MAX_get = 385; // native
const uint32_t C_limits___limits_ULLONG_MAX_get = 386; // native
const uint32_t C_limits___limits_ULONG_MAX_get = 387; // native
const uint32_t C_limits___limits_USHRT_MAX_get = 388; // native
const uint32_t C_limits___limits_WORD_BIT_get = 389; // native
const uint32_t C_limits___limits_ARG_MAX_get = 390; // native
const uint32_t C_limits___limits_ATEXIT_MAX_get = 391; // native
const uint32_t C_limits___limits_CHILD_MAX_get = 392; // native
const uint32_t C_limits___limits_LINK_MAX_get = 393; // native
const uint32_t C_limits___limits_MAX_CANON_get = 394; // native
const uint32_t C_limits___limits_MAX_INPUT_get = 395; // native
const uint32_t C_limits___limits_NAME_MAX_get = 396; // native
const uint32_t C_limits___limits_NGROUPS_MAX_get = 397; // native
const uint32_t C_limits___limits_OPEN_MAX_get = 398; // native
const uint32_t C_limits___limits_PATH_MAX_get = 399; // native
const uint32_t C_limits___limits_PIPE_BUF_get = 400; // native
const uint32_t C_limits___limits_SSIZE_MAX_get = 401; // native
const uint32_t C_limits___limits_STREAM_MAX_get = 402; // native
const uint32_t C_limits___limits_TZNAME_MAX_get = 403; // native
const uint32_t C_limits___limits_MB_LEN_MAX_get = 404; // native
const uint32_t C_limits___limits_SIZE_MAX_get = 405; // native
const uint32_t C_limits___limits_SYMLINK_MAX_get = 406; // native
const uint32_t C_limits___limits_AIO_LISTIO_MAX_get = 407; // native
const uint32_t C_limits___limits_AIO_MAX_get = 408; // native
const uint32_t C_limits___limits_AIO_PRIO_DELTA_MAX_get = 409; // native
const uint32_t C_limits___limits_DELAYTIMER_MAX_get = 410; // native
const uint32_t C_limits___limits_HOST_NAME_MAX_get = 411; // native
const uint32_t C_limits___limits_LOGIN_NAME_MAX_get = 412; // native
const uint32_t C_limits___limits_MQ_OPEN_MAX_get = 413; // native
const uint32_t C_limits___limits_MQ_PRIO_MAX_get = 414; // native
const uint32_t C_limits___limits_PAGESIZE_get = 415; // native
const uint32_t C_limits___limits_PAGE_SIZE_get = 416; // native
const uint32_t C_limits___limits_RE_DUP_MAX_get = 417; // native
const uint32_t C_limits___limits_RTSIG_MAX_get = 418; // native
const uint32_t C_limits___limits_SEM_NSEMS_MAX_get = 419; // native
const uint32_t C_limits___limits_SEM_VALUE_MAX_get = 420; // native
const uint32_t C_limits___limits_SIGQUEUE_MAX_get = 421; // native
const uint32_t C_limits___limits_SS_REPL_MAX_get = 422; // native
const uint32_t C_limits___limits_SYMLOOP_MAX_get = 423; // native
const uint32_t C_limits___limits_TIMER_MAX_get = 424; // native
const uint32_t C_limits___limits_TRACE_EVENT_NAME_MAX_get = 425; // native
const uint32_t C_limits___limits_TRACE_NAME_MAX_get = 426; // native
const uint32_t C_limits___limits_TRACE_SYS_MAX_get = 427; // native
const uint32_t C_limits___limits_TRACE_USER_EVENT_MAX_get = 428; // native
const uint32_t C_limits___limits_TTY_NAME_MAX_get = 429; // native
const uint32_t C_limits___limits__POSIX_ARG_MAX_get = 430; // native
const uint32_t C_limits___limits__POSIX_CHILD_MAX_get = 431; // native
const uint32_t C_limits___limits__POSIX_LINK_MAX_get = 432; // native
const uint32_t C_limits___limits__POSIX_MAX_CANON_get = 433; // native
const uint32_t C_limits___limits__POSIX_MAX_INPUT_get = 434; // native
const uint32_t C_limits___limits__POSIX_NAME_MAX_get = 435; // native
const uint32_t C_limits___limits__POSIX_NGROUPS_MAX_get = 436; // native
const uint32_t C_limits___limits__POSIX_OPEN_MAX_get = 437; // native
const uint32_t C_limits___limits__POSIX_PATH_MAX_get = 438; // native
const uint32_t C_limits___limits__POSIX_PIPE_BUF_get = 439; // native
const uint32_t C_limits___limits__POSIX_SSIZE_MAX_get = 440; // native
const uint32_t C_limits___limits__POSIX_STREAM_MAX_get = 441; // native
const uint32_t C_limits___limits__POSIX_TZNAME_MAX_get = 442; // native
const uint32_t C_limits___limits__POSIX_SYMLINK_MAX_get = 443; // native
const uint32_t C_limits___limits__POSIX_AIO_LISTIO_MAX_get = 444; // native
const uint32_t C_limits___limits__POSIX_AIO_MAX_get = 445; // native
const uint32_t C_limits___limits__POSIX_DELAYTIMER_MAX_get = 446; // native
const uint32_t C_limits___limits__POSIX_HOST_NAME_MAX_get = 447; // native
const uint32_t C_limits___limits__POSIX_LOGIN_NAME_MAX_get = 448; // native
const uint32_t C_limits___limits__POSIX_MQ_OPEN_MAX_get = 449; // native
const uint32_t C_limits___limits__POSIX_MQ_PRIO_MAX_get = 450; // native
const uint32_t C_limits___limits__POSIX_RE_DUP_MAX_get = 451; // native
const uint32_t C_limits___limits__POSIX_RTSIG_MAX_get = 452; // native
const uint32_t C_limits___limits__POSIX_SEM_NSEMS_MAX_get = 453; // native
const uint32_t C_limits___limits__POSIX_SEM_VALUE_MAX_get = 454; // native
const uint32_t C_limits___limits__POSIX_SIGQUEUE_MAX_get = 455; // native
const uint32_t C_limits___limits__POSIX_SS_REPL_MAX_get = 456; // native
const uint32_t C_limits___limits__POSIX_SYMLOOP_MAX_get = 457; // native
const uint32_t C_limits___limits__POSIX_TIMER_MAX_get = 458; // native
const uint32_t C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get = 459; // native
const uint32_t C_limits___limits__POSIX_TRACE_NAME_MAX_get = 460; // native
const uint32_t C_limits___limits__POSIX_TRACE_SYS_MAX_get = 461; // native
const uint32_t C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get = 462; // native
const uint32_t C_limits___limits__POSIX_TTY_NAME_MAX_get = 463; // native
const uint32_t C_locale___locale_LC_ALL_get = 466; // native
const uint32_t C_signal___signal_SIGEV_NONE_get = 469; // native
const uint32_t C_signal___signal_SIGEV_SIGNAL_get = 470; // native
const uint32_t C_signal___signal_SIGEV_THREAD_get = 471; // native
const uint32_t C_stdio___stdio_BUFSIZ_get = 478; // native
const uint32_t C_stdio___stdio__IOFBF_get = 479; // native
const uint32_t C_stdio___stdio__IOLBF_get = 480; // native
const uint32_t C_stdio___stdio__IONBF_get = 481; // native
const uint32_t C_stdio___stdio_SEEK_CUR_get = 482; // native
const uint32_t C_stdio___stdio_SEEK_END_get = 483; // native
const uint32_t C_stdio___stdio_SEEK_SET_get = 484; // native
const uint32_t C_stdio___stdio_FILENAME_MAX_get = 485; // native
const uint32_t C_stdio___stdio_FOPEN_MAX_get = 486; // native
const uint32_t C_stdio___stdio_TMP_MAX_get = 487; // native
const uint32_t C_stdio___stdio_EOF_get = 488; // native
const uint32_t C_stdio___stdio_stdin_get = 489; // native
const uint32_t C_stdio___stdio_stdout_get = 490; // native
const uint32_t C_stdio___stdio_stderr_get = 491; // native
const uint32_t C_stdio___stdio__getc = 492; // native
const uint32_t C_stdio___stdio__getc_unlocked = 493; // native
const uint32_t C_stdio___stdio__getchar_unlocked = 494; // native
const uint32_t C_stdlib___stdlib_EXIT_SUCCESS_get = 501; // native
const uint32_t C_stdlib___stdlib_EXIT_FAILURE_get = 502; // native
const uint32_t C_stdlib___stdlib_RAND_MAX_get = 503; // native
const uint32_t C_stdlib___stdlib_MB_CUR_MAX_get = 504; // native
const uint32_t C_stdlib___stdlib__str2num = 505; // abc
const uint32_t C_stdlib___stdlib__str2int = 506; // abc
const uint32_t C_stdlib___stdlib__str2uint = 507; // abc
const uint32_t C_stdlib_div_t_toString = 510; // abc
const uint32_t C_stdlib_ldiv_t_toString = 513; // abc
const uint32_t C_stdlib_lldiv_t_toString = 516; // abc
const uint32_t C_time___time_CLOCKS_PER_SEC_get = 519; // native
const uint32_t C_fcntl___fcntl_O_RDONLY_get = 526; // native
const uint32_t C_fcntl___fcntl_O_WRONLY_get = 527; // native
const uint32_t C_fcntl___fcntl_O_RDWR_get = 528; // native
const uint32_t C_fcntl___fcntl_O_ACCMODE_get = 529; // native
const uint32_t C_fcntl___fcntl_O_APPEND_get = 530; // native
const uint32_t C_fcntl___fcntl_O_CREAT_get = 531; // native
const uint32_t C_fcntl___fcntl_O_TRUNC_get = 532; // native
const uint32_t C_fcntl___fcntl_O_EXCL_get = 533; // native
const uint32_t C_fcntl___fcntl_O_EXEC_get = 534; // native
const uint32_t C_fcntl___fcntl_O_CLOEXEC_get = 535; // native
const uint32_t C_fcntl___fcntl_O_DIRECTORY_get = 536; // native
const uint32_t C_fcntl___fcntl_O_NOFOLLOW_get = 537; // native
const uint32_t C_fcntl___fcntl_O_NONBLOCK_get = 538; // native
const uint32_t C_fcntl___fcntl_O_NOCTTY_get = 539; // native
const uint32_t C_fcntl___fcntl_O_SEARCH_get = 540; // native
const uint32_t C_fcntl___fcntl_O_TTY_INIT_get = 541; // native
const uint32_t C_fcntl___fcntl_O_SYNC_get = 542; // native
const uint32_t C_fcntl___fcntl_O_DSYNC_get = 543; // native
const uint32_t C_fcntl___fcntl_O_RSYNC_get = 544; // native
const uint32_t C_fcntl___fcntl_O_ASYNC_get = 545; // native
const uint32_t C_fcntl___fcntl_O_FSYNC_get = 546; // native
const uint32_t C_fcntl___fcntl_O_SHLOCK_get = 547; // native
const uint32_t C_fcntl___fcntl_O_EXLOCK_get = 548; // native
const uint32_t C_fcntl___fcntl_O_TEXT_get = 549; // native
const uint32_t C_fcntl___fcntl_O_BINARY_get = 550; // native
const uint32_t C_fcntl___fcntl_O_WTEXT_get = 551; // native
const uint32_t C_fcntl___fcntl_O_U16TEXT_get = 552; // native
const uint32_t C_fcntl___fcntl_O_U8TEXT_get = 553; // native
const uint32_t C_fcntl___fcntl_O_RAW_get = 554; // native
const uint32_t C_fcntl___fcntl_O_NOINHERIT_get = 555; // native
const uint32_t C_fcntl___fcntl_O_TEMPORARY_get = 556; // native
const uint32_t C_fcntl___fcntl_O_SHORT_LIVED_get = 557; // native
const uint32_t C_fcntl___fcntl_O_SEQUENTIAL_get = 558; // native
const uint32_t C_fcntl___fcntl_O_RANDOM_get = 559; // native
const uint32_t C_fcntl___fcntl_F_DUPFD_get = 560; // native
const uint32_t C_fcntl___fcntl_F_DUPFD_CLOEXEC_get = 561; // native
const uint32_t C_fcntl___fcntl_F_GETFD_get = 562; // native
const uint32_t C_fcntl___fcntl_F_SETFD_get = 563; // native
const uint32_t C_fcntl___fcntl_F_GETFL_get = 564; // native
const uint32_t C_fcntl___fcntl_F_SETFL_get = 565; // native
const uint32_t C_fcntl___fcntl_F_GETOWN_get = 566; // native
const uint32_t C_fcntl___fcntl_F_SETOWN_get = 567; // native
const uint32_t C_netdb___netdb_AI_PASSIVE_get = 570; // native
const uint32_t C_netdb___netdb_AI_CANONNAME_get = 571; // native
const uint32_t C_netdb___netdb_AI_NUMERICHOST_get = 572; // native
const uint32_t C_netdb___netdb_AI_NUMERICSERV_get = 573; // native
const uint32_t C_netdb___netdb_AI_V4MAPPED_get = 574; // native
const uint32_t C_netdb___netdb_AI_ALL_get = 575; // native
const uint32_t C_netdb___netdb_AI_ADDRCONFIG_get = 576; // native
const uint32_t C_netdb_hostent_toString = 579; // abc
const uint32_t C_netdb_protoent_toString = 584; // abc
const uint32_t C_netinet___netinet_IPPROTO_IP_get = 591; // native
const uint32_t C_netinet___netinet_IPPROTO_IPV6_get = 592; // native
const uint32_t C_netinet___netinet_IPPROTO_ICMP_get = 593; // native
const uint32_t C_netinet___netinet_IPPROTO_RAW_get = 594; // native
const uint32_t C_netinet___netinet_IPPROTO_TCP_get = 595; // native
const uint32_t C_netinet___netinet_IPPROTO_UDP_get = 596; // native
const uint32_t C_netinet___netinet_INADDR_ANY_get = 597; // native
const uint32_t C_netinet___netinet_INADDR_BROADCAST_get = 598; // native
const uint32_t C_netinet___netinet_INET_ADDRSTRLEN_get = 599; // native
const uint32_t C_netinet___netinet_INET6_ADDRSTRLEN_get = 600; // native
const uint32_t C_netinet___netinet_IPV6_JOIN_GROUP_get = 601; // native
const uint32_t C_netinet___netinet_IPV6_LEAVE_GROUP_get = 602; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_HOPS_get = 603; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_IF_get = 604; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_LOOP_get = 605; // native
const uint32_t C_netinet___netinet_IPV6_UNICAST_HOPS_get = 606; // native
const uint32_t C_netinet___netinet_IPV6_V6ONLY_get = 607; // native
const uint32_t C_spawn_pid_t_valueOf = 620; // abc
const uint32_t C_spawn_pid_t_toString = 621; // abc
const uint32_t C_sys_socket___socket_SOCK_DGRAM_get = 624; // native
const uint32_t C_sys_socket___socket_SOCK_RAW_get = 625; // native
const uint32_t C_sys_socket___socket_SOCK_SEQPACKET_get = 626; // native
const uint32_t C_sys_socket___socket_SOCK_STREAM_get = 627; // native
const uint32_t C_sys_socket_sockaddr_toSockaddr_storage = 632; // abc
const uint32_t C_sys_socket_sockaddr_storage_toSockaddr = 635; // abc
const uint32_t C_sys_stat___stat_mkdir = 640; // native
const uint32_t C_sys_stat_status_toString = 643; // abc
const uint32_t C_sys_wait___wait_WCONTINUED_get = 646; // native
const uint32_t C_sys_wait___wait_WNOHANG_get = 647; // native
const uint32_t C_sys_wait___wait_WUNTRACED_get = 648; // native
const uint32_t C_sys_wait___wait_WEXITED_get = 649; // native
const uint32_t C_sys_wait___wait_WNOWAIT_get = 650; // native
const uint32_t C_sys_wait___wait_WSTOPPED_get = 651; // native
const uint32_t C_sys_wait___wait_P_ALL_get = 652; // native
const uint32_t C_sys_wait___wait_P_PGID_get = 653; // native
const uint32_t C_sys_wait___wait_P_PID_get = 654; // native
const uint32_t C_sys_wait___wait__WEXITSTATUS = 655; // native
const uint32_t C_sys_wait___wait__WIFCONTINUED = 656; // native
const uint32_t C_sys_wait___wait__WIFEXITED = 657; // native
const uint32_t C_sys_wait___wait__WIFSIGNALED = 658; // native
const uint32_t C_sys_wait___wait__WIFSTOPPED = 659; // native
const uint32_t C_sys_wait___wait__WSTOPSIG = 660; // native
const uint32_t C_sys_wait___wait__WTERMSIG = 661; // native
const uint32_t C_unistd___unistd_F_OK_get = 666; // native
const uint32_t C_unistd___unistd_X_OK_get = 667; // native
const uint32_t C_unistd___unistd_W_OK_get = 668; // native
const uint32_t C_unistd___unistd_R_OK_get = 669; // native
const uint32_t C_unistd___unistd_getcwd = 670; // native
const uint32_t C_unistd___unistd_gethostname = 671; // native
const uint32_t C_unistd___unistd_getlogin = 672; // native
const uint32_t C_unistd___unistd_getpid = 673; // native
const uint32_t C_unistd___unistd_rmdir = 674; // native
const uint32_t C_unistd___unistd_sleep = 675; // native
const uint32_t C_unistd___unistd_unlink = 676; // native
const uint32_t shell_Program_private__getArgv = 679; // native
const uint32_t shell_Program_private__getEnviron = 680; // native
const uint32_t shell_Program_private__getProgramFilename = 681; // native
const uint32_t shell_Program_private__setExitListener = 682; // native
const uint32_t shell_Program_private__popenRead = 683; // native
const uint32_t shell_Program_totalMemory_get = 684; // native
const uint32_t shell_Program_freeMemory_get = 685; // native
const uint32_t shell_Program_privateMemory_get = 686; // native
const uint32_t shell_Program_environ_get = 687; // abc
const uint32_t shell_Program_pid_get = 688; // abc
const uint32_t shell_Program_shell_get = 689; // abc
const uint32_t shell_Program_workingDirectory_get = 690; // abc
const uint32_t shell_Program_workingDirectory_set = 691; // abc
const uint32_t shell_Program_AVM2_atExit = 692; // abc
const uint32_t shell_Program_AVM2_setExitListener = 693; // abc
const uint32_t shell_Program_AVM2_setShell = 694; // abc
const uint32_t shell_Program_AVM2_selfCheck = 695; // abc
const uint32_t shell_Program_abort = 696; // native
const uint32_t shell_Program_exec = 697; // native
const uint32_t shell_Program_exit = 698; // native
const uint32_t shell_Program_open = 699; // abc
const uint32_t shell_Program_sleep = 700; // native
const uint32_t shell_Program_getNanosecondTimer = 701; // native
const uint32_t shell_Program_getTimer = 702; // native
const uint32_t shell_Program_readLine = 703; // native
const uint32_t shell_Program_write = 704; // native
const uint32_t shell_Program_writeLine = 705; // abc
const uint32_t shell_Program_trace = 706; // native
const uint32_t shell_Program_forceFullCollection = 707; // native
const uint32_t shell_Program_queueCollection = 708; // native
const uint32_t shell_Program_pauseForGCIfCollectionImminent = 709; // native
const uint32_t shell_Program_disposeXML = 710; // native
const uint32_t shell_Runtime_private__getAvmplusPlatform = 713; // native
const uint32_t shell_Runtime_private__getAvmplusArchitecture = 714; // native
const uint32_t shell_Runtime_private__getAvmplusVersion = 715; // native
const uint32_t shell_Runtime_private__getAvmplusDescription = 716; // native
const uint32_t shell_Runtime_private__getFeatures = 717; // native
const uint32_t shell_Runtime_private__getRunmode = 718; // native
const uint32_t shell_Runtime_private__getEndian = 719; // native
const uint32_t shell_Runtime_apiVersion_get = 720; // native
const uint32_t shell_Runtime_api_get = 721; // abc
const uint32_t shell_Runtime_swfVersion_get = 722; // native
const uint32_t shell_Runtime_platform_get = 723; // abc
const uint32_t shell_Runtime_architecture_get = 724; // abc
const uint32_t shell_Runtime_version_get = 725; // abc
const uint32_t shell_Runtime_description_get = 726; // abc
const uint32_t shell_Runtime_features_get = 727; // abc
const uint32_t shell_Runtime_runmode_get = 728; // abc
const uint32_t shell_Runtime_endian_get = 729; // abc
const uint32_t shell_Runtime_redtamarin_get = 730; // abc
const uint32_t shell_Runtime_loop_get = 731; // abc
const uint32_t shell_Runtime_loop_set = 732; // abc
const uint32_t shell_Runtime_eval = 733; // native
const uint32_t shell_Runtime_returnEval = 734; // native
const uint32_t shell_Runtime_is64bit = 735; // native
const uint32_t shell_Diagnostics_private__isGlobal = 738; // native
const uint32_t shell_Diagnostics_private__isIntptr = 739; // native
const uint32_t shell_Diagnostics_private__canonicalizeNumber = 740; // native
const uint32_t shell_Diagnostics_private__deopt = 741; // native
const uint32_t shell_Diagnostics_private__runInSafepoint = 742; // native
const uint32_t shell_Diagnostics_private__log = 743; // native
const uint32_t shell_Diagnostics_private__initializeLogging = 744; // native
const uint32_t shell_Diagnostics_debugger = 745; // native
const uint32_t shell_Diagnostics_isDebugger = 746; // native
const uint32_t shell_Diagnostics_AVM2_log = 747; // abc
const uint32_t shell_Diagnostics_AVM2_initializeLogging = 748; // abc
const uint32_t shell_Diagnostics_AVM2_isGlobal = 749; // abc
const uint32_t shell_Diagnostics_AVM2_isIntptr = 750; // abc
const uint32_t shell_Diagnostics_AVM2_canonicalizeNumber = 751; // abc
const uint32_t shell_Diagnostics_AVM2_deopt = 752; // abc
const uint32_t shell_Diagnostics_AVM2_runInSafepoint = 753; // abc
const uint32_t shell_HardwareInformation_private__getProcessorCountAtBoot = 756; // native
const uint32_t shell_HardwareInformation_private__getMemorySize = 757; // native
const uint32_t shell_HardwareInformation_private__getMemoryUsage = 758; // native
const uint32_t shell_HardwareInformation_private__getMemoryPeakUsage = 759; // native
const uint32_t shell_HardwareInformation_processors_get = 760; // abc
const uint32_t shell_HardwareInformation_memory_get = 761; // abc
const uint32_t shell_HardwareInformation_memoryUsage_get = 762; // abc
const uint32_t shell_HardwareInformation_memoryPeakUsage_get = 763; // abc
const uint32_t shell_OperatingSystem_isWindowsStore = 766; // native
const uint32_t shell_Domain_currentDomain_get = 771; // native
const uint32_t shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get = 772; // native
const uint32_t shell_Domain_private_init = 773; // native
const uint32_t shell_Domain_loadBytes = 775; // native
const uint32_t shell_Domain_getClass = 776; // native
const uint32_t shell_Domain_load = 777; // abc
const uint32_t shell_Domain_domainMemory_get = 778; // native
const uint32_t shell_Domain_domainMemory_set = 779; // native
const uint32_t shell_FileIO_exists = 781; // native
const uint32_t shell_FileIO_read = 782; // native
const uint32_t shell_FileIO_write = 783; // native
const uint32_t shell_FileIO_readByteArray = 784; // native
const uint32_t shell_FileIO_writeByteArray = 785; // native
const uint32_t shell_Environment_private__parse = 789; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_callProperty = 790; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_deleteProperty = 791; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_getProperty = 792; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_setProperty = 793; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_hasProperty = 794; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextNameIndex = 795; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextName = 796; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextValue = 797; // abc
const uint32_t shell_Environment_length_get = 798; // abc
const uint32_t shell_Environment_refresh = 799; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_get = 803; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_set = 804; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_get = 805; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_set = 806; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_get = 807; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_set = 808; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frame_get = 809; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_started_get = 810; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_elapsed_get = 811; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timerPending_get = 812; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_setCallback = 813; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_handleTimers = 814; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_start = 815; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_stop = 816; // abc
const uint32_t flash_accessibility_ISearchableText_flash_accessibility_ISearchableText_searchText_get = 819; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionAnchorIndex_get = 822; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionActiveIndex_get = 823; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accRole = 829; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accName = 830; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accValue = 831; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accState = 832; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accDefaultAction = 833; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accDoDefaultAction = 834; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_isLabeledBy = 835; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_getChildIDArray = 836; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accLocation = 837; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accSelection = 838; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accFocus = 839; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accSelect = 840; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionAnchorIndex = 841; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionActiveIndex = 842; // abc
const uint32_t flash_data_EncryptedLocalStore_isSupported_get = 846; // abc
const uint32_t flash_display_Scene_name_get = 896; // abc
const uint32_t flash_display_Scene_labels_get = 897; // abc
const uint32_t flash_display_Scene_numFrames_get = 898; // abc
const uint32_t flash_errors_SQLError_operation_get = 925; // abc
const uint32_t flash_errors_SQLError_details_get = 926; // abc
const uint32_t flash_errors_SQLError_detailID_get = 927; // abc
const uint32_t flash_errors_SQLError_detailArguments_get = 928; // abc
const uint32_t flash_errors_DRMManagerError_subErrorID_get = 931; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_addEventListener = 933; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_dispatchEvent = 934; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_hasEventListener = 935; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_removeEventListener = 936; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_willTrigger = 937; // abc
const uint32_t flash_events_Event_private_ctor = 941; // abc
const uint32_t flash_events_Event_type_get = 942; // abc
const uint32_t flash_events_Event_bubbles_get = 943; // abc
const uint32_t flash_events_Event_cancelable_get = 944; // abc
const uint32_t flash_events_Event_target_get = 945; // abc
const uint32_t flash_events_Event_currentTarget_get = 946; // abc
const uint32_t flash_events_Event_eventPhase_get = 947; // abc
const uint32_t flash_events_Event_formatToString = 948; // abc
const uint32_t flash_events_Event_clone = 949; // abc
const uint32_t flash_events_Event_isDefaultPrevented = 950; // abc
const uint32_t flash_events_Event_preventDefault = 951; // abc
const uint32_t flash_events_Event_stopImmediatePropagation = 952; // abc
const uint32_t flash_events_Event_stopPropagation = 953; // abc
const uint32_t flash_events_Event_toString = 954; // abc
const uint32_t flash_geom_Point_interpolate = 958; // abc
const uint32_t flash_geom_Point_distance = 959; // abc
const uint32_t flash_geom_Point_polar = 960; // abc
const uint32_t flash_geom_Point_length_get = 962; // abc
const uint32_t flash_geom_Point_clone = 963; // abc
const uint32_t flash_geom_Point_offset = 964; // abc
const uint32_t flash_geom_Point_equals = 965; // abc
const uint32_t flash_geom_Point_subtract = 966; // abc
const uint32_t flash_geom_Point_add = 967; // abc
const uint32_t flash_geom_Point_normalize = 968; // abc
const uint32_t flash_geom_Point_toString = 969; // abc
const uint32_t flash_geom_Rectangle_left_get = 972; // abc
const uint32_t flash_geom_Rectangle_left_set = 973; // abc
const uint32_t flash_geom_Rectangle_right_get = 974; // abc
const uint32_t flash_geom_Rectangle_right_set = 975; // abc
const uint32_t flash_geom_Rectangle_top_get = 976; // abc
const uint32_t flash_geom_Rectangle_top_set = 977; // abc
const uint32_t flash_geom_Rectangle_bottom_get = 978; // abc
const uint32_t flash_geom_Rectangle_bottom_set = 979; // abc
const uint32_t flash_geom_Rectangle_topLeft_get = 980; // abc
const uint32_t flash_geom_Rectangle_topLeft_set = 981; // abc
const uint32_t flash_geom_Rectangle_bottomRight_get = 982; // abc
const uint32_t flash_geom_Rectangle_bottomRight_set = 983; // abc
const uint32_t flash_geom_Rectangle_size_get = 984; // abc
const uint32_t flash_geom_Rectangle_size_set = 985; // abc
const uint32_t flash_geom_Rectangle_clone = 986; // abc
const uint32_t flash_geom_Rectangle_isEmpty = 987; // abc
const uint32_t flash_geom_Rectangle_setEmpty = 988; // abc
const uint32_t flash_geom_Rectangle_inflate = 989; // abc
const uint32_t flash_geom_Rectangle_inflatePoint = 990; // abc
const uint32_t flash_geom_Rectangle_offset = 991; // abc
const uint32_t flash_geom_Rectangle_offsetPoint = 992; // abc
const uint32_t flash_geom_Rectangle_contains = 993; // abc
const uint32_t flash_geom_Rectangle_containsPoint = 994; // abc
const uint32_t flash_geom_Rectangle_containsRect = 995; // abc
const uint32_t flash_geom_Rectangle_intersection = 996; // abc
const uint32_t flash_geom_Rectangle_intersects = 997; // abc
const uint32_t flash_geom_Rectangle_union = 998; // abc
const uint32_t flash_geom_Rectangle_equals = 999; // abc
const uint32_t flash_geom_Rectangle_toString = 1000; // abc
const uint32_t flash_sampler_StackFrame_toString = 1004; // abc
const uint32_t flash_system_Capabilities_playerType_get = 1011; // abc
const uint32_t flash_system_Capabilities_isDebugger_get = 1012; // abc
const uint32_t flash_system_System_setClipboard = 1015; // abc
const uint32_t flash_system_System_totalMemory_get = 1016; // abc
const uint32_t flash_system_System_totalMemoryNumber_get = 1017; // abc
const uint32_t flash_system_System_freeMemory_get = 1018; // native
const uint32_t flash_system_System_privateMemory_get = 1019; // abc
const uint32_t flash_system_System_useCodePage_get = 1020; // abc
const uint32_t flash_system_System_useCodePage_set = 1021; // abc
const uint32_t flash_system_System_vmVersion_get = 1022; // abc
const uint32_t flash_system_System_pause = 1023; // abc
const uint32_t flash_system_System_resume = 1024; // abc
const uint32_t flash_system_System_exit = 1025; // abc
const uint32_t flash_system_System_gc = 1026; // abc
const uint32_t flash_system_System_disposeXML = 1027; // abc
const uint32_t flash_system_WorkerState_code = 1030; // abc
const uint32_t flash_system_Worker_current_get = 1033; // abc
const uint32_t flash_system_Worker_pr = 1034; // native
const uint32_t flash_system_Worker_state_get = 1036; // native
const uint32_t flash_system_Worker_start = 1037; // native
const uint32_t flash_system_Worker_isParentOf = 1038; // native
const uint32_t flash_system_Worker_isPrimordial_get = 1039; // native
const uint32_t flash_system_Worker_setSharedProperty = 1040; // native
const uint32_t flash_system_Worker_getSharedProperty = 1041; // native
const uint32_t flash_system_Worker_terminate = 1042; // native
const uint32_t flash_system_WorkerEvent_currentState_get = 1045; // abc
const uint32_t flash_system_WorkerEvent_previousState_get = 1046; // abc
const uint32_t flash_system_WorkerEvent_target_get = 1047; // abc
const uint32_t flash_system_WorkerDomain_current_get = 1049; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromByteArray = 1051; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromPrimordial = 1052; // abc
const uint32_t flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal = 1053; // native
const uint32_t flash_system_WorkerDomain_listWorkers = 1054; // native
const uint32_t flash_trace_Trace_setLevel = 1056; // native
const uint32_t flash_trace_Trace_getLevel = 1057; // native
const uint32_t flash_trace_Trace_setListener = 1058; // native
const uint32_t flash_trace_Trace_getListener = 1059; // native
const uint32_t shell_async_CoreEventLoop_running_get = 1065; // abc
const uint32_t shell_async_CoreEventLoop_running_set = 1066; // abc
const uint32_t shell_async_CoreEventLoop_frequency_get = 1067; // abc
const uint32_t shell_async_CoreEventLoop_frequency_set = 1068; // abc
const uint32_t shell_async_CoreEventLoop_timers_get = 1069; // abc
const uint32_t shell_async_CoreEventLoop_timers_set = 1070; // abc
const uint32_t shell_async_CoreEventLoop_frame_get = 1071; // abc
const uint32_t shell_async_CoreEventLoop_started_get = 1072; // abc
const uint32_t shell_async_CoreEventLoop_elapsed_get = 1073; // abc
const uint32_t shell_async_CoreEventLoop_private_tick = 1074; // abc
const uint32_t shell_async_CoreEventLoop_setCallback = 1075; // abc
const uint32_t shell_async_CoreEventLoop_private__loop = 1076; // abc
const uint32_t shell_async_CoreEventLoop_timerPending_get = 1077; // abc
const uint32_t shell_async_CoreEventLoop_handleTimers = 1078; // abc
const uint32_t shell_async_CoreEventLoop_start = 1079; // abc
const uint32_t shell_async_CoreEventLoop_stop = 1080; // abc
const uint32_t flash_events_EventDispatcher_private_trimHeaderValue = 1082; // abc
const uint32_t flash_events_EventDispatcher_private_ctor = 1084; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchEventFunction = 1085; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchHttpStatusEvent = 1087; // abc
const uint32_t flash_events_EventDispatcher_addEventListener = 1088; // abc
const uint32_t flash_events_EventDispatcher_dispatchEvent = 1089; // abc
const uint32_t flash_events_EventDispatcher_hasEventListener = 1090; // abc
const uint32_t flash_events_EventDispatcher_removeEventListener = 1091; // abc
const uint32_t flash_events_EventDispatcher_willTrigger = 1092; // abc
const uint32_t flash_events_EventDispatcher_toString = 1093; // abc
const uint32_t flash_events_HTTPStatusEvent_status_get = 1096; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_get = 1097; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_set = 1098; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_get = 1099; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_set = 1100; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_get = 1101; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_set = 1102; // abc
const uint32_t flash_events_HTTPStatusEvent_clone = 1103; // abc
const uint32_t flash_events_HTTPStatusEvent_toString = 1104; // abc
const uint32_t flash_events_TimerEvent_clone = 1107; // abc
const uint32_t flash_events_TimerEvent_toString = 1108; // abc
const uint32_t flash_events_TimerEvent_updateAfterEvent = 1109; // abc
const uint32_t flash_sampler_NewObjectSample_object_get = 1111; // native
const uint32_t flash_sampler_NewObjectSample_size_get = 1112; // native
const uint32_t flash_utils_Timer_private__timerDispatch = 1118; // abc
const uint32_t flash_utils_Timer_private__start = 1119; // abc
const uint32_t flash_utils_Timer_tick = 1120; // abc
const uint32_t flash_utils_Timer_delay_get = 1121; // abc
const uint32_t flash_utils_Timer_delay_set = 1122; // abc
const uint32_t flash_utils_Timer_repeatCount_get = 1123; // abc
const uint32_t flash_utils_Timer_repeatCount_set = 1124; // abc
const uint32_t flash_utils_Timer_currentCount_get = 1125; // abc
const uint32_t flash_utils_Timer_running_get = 1126; // abc
const uint32_t flash_utils_Timer_reset = 1127; // abc
const uint32_t flash_utils_Timer_start = 1128; // abc
const uint32_t flash_utils_Timer_stop = 1129; // abc

extern avmplus::Atom native_script_function_C_assert__debugBreak_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_assert__debugBreak_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalnum_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalnum_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalpha_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalpha_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isblank_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isblank_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_iscntrl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_iscntrl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isgraph_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isgraph_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_islower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_islower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isprint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isprint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_ispunct_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_ispunct_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isspace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isspace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isxdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isxdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_tolower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_tolower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPERM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPERM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOENT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOENT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINTR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINTR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENXIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENXIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_E2BIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_E2BIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHILD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHILD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAGAIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAGAIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EACCES_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EACCES_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFAULT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFAULT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTBLK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTBLK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBUSY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBUSY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EEXIST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EEXIST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXDEV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXDEV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODEV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODEV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTDIR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTDIR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISDIR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISDIR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINVAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINVAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENFILE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENFILE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMFILE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMFILE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETXTBSY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETXTBSY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFBIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFBIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSPC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSPC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EROFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EROFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMLINK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMLINK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERANGE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERANGE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAMETOOLONG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAMETOOLONG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSYS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSYS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTEMPTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTEMPTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELOOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELOOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EWOULDBLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EWOULDBLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMSG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMSG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIDRM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIDRM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSTR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSTR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODATA_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODATA_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLINK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLINK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADMSG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADMSG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOVERFLOW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOVERFLOW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EILSEQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EILSEQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTSOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTSOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDESTADDRREQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDESTADDRREQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMSGSIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMSGSIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTOTYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTOTYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPROTOOPT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPROTOOPT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTONOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTONOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOPNOTSUPP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOPNOTSUPP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAFNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAFNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRINUSE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRINUSE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRNOTAVAIL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRNOTAVAIL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETUNREACH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETUNREACH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETRESET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETRESET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNABORTED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNABORTED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNRESET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNRESET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOBUFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOBUFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIMEDOUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIMEDOUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNREFUSED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNREFUSED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTUNREACH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTUNREACH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EALREADY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EALREADY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINPROGRESS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINPROGRESS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECANCELED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECANCELED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOWNERDEAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOWNERDEAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTRECOVERABLE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTRECOVERABLE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUSERS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUSERS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESOCKTNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESOCKTNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPFNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPFNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESHUTDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESHUTDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETOOMANYREFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETOOMANYREFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTALE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTALE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDQUOT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDQUOT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMULTIHOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMULTIHOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHRNG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHRNG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2NSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2NSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3HLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3HLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3RST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3RST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELNRNG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELNRNG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUNATCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUNATCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOCSI_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOCSI_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2HLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2HLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXFULL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXFULL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOANO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOANO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADRQC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADRQC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADSLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADSLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBFONT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBFONT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENONET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENONET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPKG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPKG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRMNT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRMNT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECOMM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECOMM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOTDOT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOTDOT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTUNIQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTUNIQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMCHG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMCHG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBACC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBACC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBBAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBBAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBSCN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBSCN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBMAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBMAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERESTART_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERESTART_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTRPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTRPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUCLEAN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUCLEAN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTNAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTNAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAVAIL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAVAIL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISNAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISNAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTEIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTEIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEDIUM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEDIUM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMEDIUMTYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMEDIUMTYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOKEY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOKEY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYEXPIRED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYEXPIRED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREVOKED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREVOKED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREJECTED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREJECTED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERFKILL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERFKILL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHWPOISON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHWPOISON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__GetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__GetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__SetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__SetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UCHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UCHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UINT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UINT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_ULLONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_ULLONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ULONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ULONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_USHRT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_USHRT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_WORD_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_WORD_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ARG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ARG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ATEXIT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ATEXIT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHILD_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHILD_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_CANON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_CANON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_INPUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_INPUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NGROUPS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NGROUPS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PIPE_BUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PIPE_BUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SSIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SSIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_STREAM_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_STREAM_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TZNAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TZNAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MB_LEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MB_LEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_LISTIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_LISTIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_PRIO_DELTA_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_PRIO_DELTA_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_DELAYTIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_DELAYTIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_HOST_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_HOST_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LOGIN_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LOGIN_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_PRIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_PRIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGESIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGESIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGE_SIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGE_SIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RE_DUP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RE_DUP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RTSIG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RTSIG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_NSEMS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_NSEMS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_VALUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_VALUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIGQUEUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIGQUEUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SS_REPL_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SS_REPL_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLOOP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLOOP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_EVENT_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_EVENT_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_SYS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_SYS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_USER_EVENT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_USER_EVENT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TTY_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TTY_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_ARG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_ARG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_CHILD_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_CHILD_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_CANON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_CANON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_INPUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_INPUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NGROUPS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NGROUPS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PIPE_BUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PIPE_BUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SSIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SSIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_STREAM_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_STREAM_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TZNAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TZNAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_LISTIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_LISTIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_DELAYTIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_DELAYTIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_HOST_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_HOST_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LOGIN_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LOGIN_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_PRIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_PRIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RE_DUP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RE_DUP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RTSIG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RTSIG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_NSEMS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_NSEMS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_VALUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_VALUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SIGQUEUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SIGQUEUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SS_REPL_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SS_REPL_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLOOP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLOOP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_SYS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_SYS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TTY_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TTY_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_remove_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_remove_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_closedir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_closedir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_dirfd_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_dirfd_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_fdopendir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_fdopendir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_opendir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_opendir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_readdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_readdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_rewinddir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_rewinddir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_seekdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_seekdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_dirent_telldir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_dirent_telldir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CLOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CLOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DIRECTORY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DIRECTORY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOFOLLOW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOFOLLOW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NONBLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NONBLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOCTTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOCTTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEARCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEARCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TTY_INIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TTY_INIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ASYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ASYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_FSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_FSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WTEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WTEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U16TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U16TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U8TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U8TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOINHERIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOINHERIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEMPORARY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEMPORARY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHORT_LIVED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHORT_LIVED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEQUENTIAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEQUENTIAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RANDOM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RANDOM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_CLOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_CLOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_creat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_creat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_fcntl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_fcntl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_open_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_open_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_openat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_openat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_ANY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_ANY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_BROADCAST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_BROADCAST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat_mkdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat_mkdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_exists_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_exists_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_read_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_read_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_write_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_write_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_readByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_readByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_writeByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_writeByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
class SlotOffsetsAndAsserts;
//-----------------------------------------------------------
// C.ctype::__ctype$
//-----------------------------------------------------------
class avmshell_CTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CTypeClass;
};
#define DECLARE_SLOTS_CTypeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.ctype::__ctype
//-----------------------------------------------------------
class avmplus___ctypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__ctypeObject;
#define GC_TRIVIAL_TRACER___ctypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::__errno$
//-----------------------------------------------------------
class avmshell_CErrnoClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CErrnoClass;
};
#define DECLARE_SLOTS_CErrnoClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::__errno
//-----------------------------------------------------------
class avmplus___errnoObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__errnoObject;
#define GC_TRIVIAL_TRACER___errnoObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::ErrorNumber$
//-----------------------------------------------------------
class avmplus_ErrorNumberClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberClass;
#define GC_TRIVIAL_TRACER_ErrorNumberClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::ErrorNumber
//-----------------------------------------------------------
class avmplus_ErrorNumberObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberObject;
private:
    uint32_t m_private__value;
#define GC_TRIVIAL_TRACER_ErrorNumberObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError$
//-----------------------------------------------------------
class avmplus_CErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CErrorClass;
#define GC_TRIVIAL_TRACER_CErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError
//-----------------------------------------------------------
class avmplus_CErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CErrorObject;
#define GC_TRIVIAL_TRACER_CErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits$
//-----------------------------------------------------------
class avmshell_CLimitsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLimitsClass;
};
#define DECLARE_SLOTS_CLimitsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits
//-----------------------------------------------------------
class avmplus___limitsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__limitsObject;
#define GC_TRIVIAL_TRACER___limitsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale$
//-----------------------------------------------------------
class avmshell_CLocaleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLocaleClass;
};
#define DECLARE_SLOTS_CLocaleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale
//-----------------------------------------------------------
class avmplus___localeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__localeObject;
#define GC_TRIVIAL_TRACER___localeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal$
//-----------------------------------------------------------
class avmshell_CSignalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSignalClass;
};
#define DECLARE_SLOTS_CSignalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal
//-----------------------------------------------------------
class avmplus___signalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__signalObject;
#define GC_TRIVIAL_TRACER___signalObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval$
//-----------------------------------------------------------
class avmshell_CsigvalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalClass;
};
#define DECLARE_SLOTS_CsigvalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CsigvalObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval
//-----------------------------------------------------------
class avmshell_CsigvalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalObject;
private:
    int32_t m_sival_int;
};
#define DECLARE_SLOTS_CsigvalObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_sival_int() const { return m_slots_CsigvalObject.m_sival_int; } \
        REALLY_INLINE void set_sival_int(int32_t newVal) { m_slots_CsigvalObject.m_sival_int = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CsigvalObjectSlots m_slots_CsigvalObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t$
//-----------------------------------------------------------
class avmshell_Csiginfo_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tClass;
};
#define DECLARE_SLOTS_Csiginfo_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Csiginfo_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t
//-----------------------------------------------------------
class avmshell_Csiginfo_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tObject;
private:
    int32_t m_si_signo;
    int32_t m_si_code;
    int32_t m_si_errno;
    int32_t m_si_pid;
    int32_t m_si_uid;
    int32_t m_si_status;
    double m_si_band;
};
#define DECLARE_SLOTS_Csiginfo_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_si_signo() const { return m_slots_Csiginfo_tObject.m_si_signo; } \
        REALLY_INLINE void set_si_signo(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_signo = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_code() const { return m_slots_Csiginfo_tObject.m_si_code; } \
        REALLY_INLINE void set_si_code(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_code = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_errno() const { return m_slots_Csiginfo_tObject.m_si_errno; } \
        REALLY_INLINE void set_si_errno(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_errno = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_pid() const { return m_slots_Csiginfo_tObject.m_si_pid; } \
        REALLY_INLINE void set_si_pid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_pid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_uid() const { return m_slots_Csiginfo_tObject.m_si_uid; } \
        REALLY_INLINE void set_si_uid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_status() const { return m_slots_Csiginfo_tObject.m_si_status; } \
        REALLY_INLINE void set_si_status(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_status = newVal; } \
    public: \
        REALLY_INLINE double get_si_band() const { return m_slots_Csiginfo_tObject.m_si_band; } \
        REALLY_INLINE void set_si_band(double newVal) { m_slots_Csiginfo_tObject.m_si_band = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Csiginfo_tObjectSlots m_slots_Csiginfo_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio$
//-----------------------------------------------------------
class avmshell_CStdioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdioClass;
};
#define DECLARE_SLOTS_CStdioClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio
//-----------------------------------------------------------
class avmplus___stdioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdioObject;
#define GC_TRIVIAL_TRACER___stdioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE$
//-----------------------------------------------------------
class avmshell_CFILEClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEClass;
};
#define DECLARE_SLOTS_CFILEClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CFILEObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE
//-----------------------------------------------------------
class avmshell_CFILEObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEObject;
};
#define DECLARE_SLOTS_CFILEObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t$
//-----------------------------------------------------------
class avmshell_Cfpos_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tClass;
};
#define DECLARE_SLOTS_Cfpos_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cfpos_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t
//-----------------------------------------------------------
class avmshell_Cfpos_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tObject;
};
#define DECLARE_SLOTS_Cfpos_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib$
//-----------------------------------------------------------
class avmshell_CStdlibClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdlibClass;
};
#define DECLARE_SLOTS_CStdlibClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib
//-----------------------------------------------------------
class avmplus___stdlibObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdlibObject;
#define GC_TRIVIAL_TRACER___stdlibObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t$
//-----------------------------------------------------------
class avmshell_Cdiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tClass;
};
#define DECLARE_SLOTS_Cdiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cdiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t
//-----------------------------------------------------------
class avmshell_Cdiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tObject;
private:
    int32_t m_quot;
    int32_t m_rem;
};
#define DECLARE_SLOTS_Cdiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_quot() const { return m_slots_Cdiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(int32_t newVal) { m_slots_Cdiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE int32_t get_rem() const { return m_slots_Cdiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(int32_t newVal) { m_slots_Cdiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cdiv_tObjectSlots m_slots_Cdiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t$
//-----------------------------------------------------------
class avmshell_Cldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tClass;
};
#define DECLARE_SLOTS_Cldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t
//-----------------------------------------------------------
class avmshell_Cldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Cldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Cldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Cldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Cldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Cldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cldiv_tObjectSlots m_slots_Cldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t$
//-----------------------------------------------------------
class avmshell_Clldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tClass;
};
#define DECLARE_SLOTS_Clldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Clldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t
//-----------------------------------------------------------
class avmshell_Clldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Clldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Clldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Clldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Clldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Clldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Clldiv_tObjectSlots m_slots_Clldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time$
//-----------------------------------------------------------
class avmshell_CTimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CTimeClass;
};
#define DECLARE_SLOTS_CTimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time
//-----------------------------------------------------------
class avmplus___timeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__timeObject;
#define GC_TRIVIAL_TRACER___timeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::DIR$
//-----------------------------------------------------------
class avmshell_CDIRClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CDIRClass;
};
#define DECLARE_SLOTS_CDIRClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CDIRObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::DIR
//-----------------------------------------------------------
class avmshell_CDIRObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CDIRObject;
};
#define DECLARE_SLOTS_CDIRObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::dirent$
//-----------------------------------------------------------
class avmshell_CdirentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CdirentClass;
};
#define DECLARE_SLOTS_CdirentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CdirentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::dirent
//-----------------------------------------------------------
class avmshell_CdirentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CdirentObject;
private:
    uint32_t m_d_ino;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_d_name;
};
#define DECLARE_SLOTS_CdirentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE uint32_t get_d_ino() const { return m_slots_CdirentObject.m_d_ino; } \
        REALLY_INLINE void set_d_ino(uint32_t newVal) { m_slots_CdirentObject.m_d_ino = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_d_name() const { return m_slots_CdirentObject.m_d_name; } \
        REALLY_INLINE void set_d_name(avmplus::String* newVal) { m_slots_CdirentObject.m_d_name = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CdirentObjectSlots m_slots_CdirentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl$
//-----------------------------------------------------------
class avmshell_CFcntlClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFcntlClass;
};
#define DECLARE_SLOTS_CFcntlClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl
//-----------------------------------------------------------
class avmplus___fcntlObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__fcntlObject;
#define GC_TRIVIAL_TRACER___fcntlObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb$
//-----------------------------------------------------------
class avmshell_CNetdbClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetdbClass;
};
#define DECLARE_SLOTS_CNetdbClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb
//-----------------------------------------------------------
class avmplus___netdbObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netdbObject;
#define GC_TRIVIAL_TRACER___netdbObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent$
//-----------------------------------------------------------
class avmshell_ChostentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentClass;
};
#define DECLARE_SLOTS_ChostentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ChostentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent
//-----------------------------------------------------------
class avmshell_ChostentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentObject;
private:
    int32_t m_h_addrtype;
    int32_t m_h_length;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_h_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_aliases;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_addr_list;
};
#define DECLARE_SLOTS_ChostentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_h_addrtype() const { return m_slots_ChostentObject.m_h_addrtype; } \
        REALLY_INLINE void set_h_addrtype(int32_t newVal) { m_slots_ChostentObject.m_h_addrtype = newVal; } \
    public: \
        REALLY_INLINE int32_t get_h_length() const { return m_slots_ChostentObject.m_h_length; } \
        REALLY_INLINE void set_h_length(int32_t newVal) { m_slots_ChostentObject.m_h_length = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_h_name() const { return m_slots_ChostentObject.m_h_name; } \
        REALLY_INLINE void set_h_name(avmplus::String* newVal) { m_slots_ChostentObject.m_h_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_aliases() const { return m_slots_ChostentObject.m_h_aliases; } \
        REALLY_INLINE void set_h_aliases(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_aliases = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_addr_list() const { return m_slots_ChostentObject.m_h_addr_list; } \
        REALLY_INLINE void set_h_addr_list(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_addr_list = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ChostentObjectSlots m_slots_ChostentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent$
//-----------------------------------------------------------
class avmplus_netentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentClass;
#define GC_TRIVIAL_TRACER_netentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent
//-----------------------------------------------------------
class avmplus_netentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentObject;
#define GC_TRIVIAL_TRACER_netentObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent$
//-----------------------------------------------------------
class avmshell_CprotoentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentClass;
};
#define DECLARE_SLOTS_CprotoentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CprotoentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent
//-----------------------------------------------------------
class avmshell_CprotoentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentObject;
private:
    int32_t m_p_proto;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_p_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_p_aliases;
};
#define DECLARE_SLOTS_CprotoentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_p_proto() const { return m_slots_CprotoentObject.m_p_proto; } \
        REALLY_INLINE void set_p_proto(int32_t newVal) { m_slots_CprotoentObject.m_p_proto = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_p_name() const { return m_slots_CprotoentObject.m_p_name; } \
        REALLY_INLINE void set_p_name(avmplus::String* newVal) { m_slots_CprotoentObject.m_p_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_p_aliases() const { return m_slots_CprotoentObject.m_p_aliases; } \
        REALLY_INLINE void set_p_aliases(avmplus::ArrayObject* newVal) { m_slots_CprotoentObject.m_p_aliases = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CprotoentObjectSlots m_slots_CprotoentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent$
//-----------------------------------------------------------
class avmplus_serventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventClass;
#define GC_TRIVIAL_TRACER_serventClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent
//-----------------------------------------------------------
class avmplus_serventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventObject;
#define GC_TRIVIAL_TRACER_serventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo$
//-----------------------------------------------------------
class avmplus_addrinfoClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::addrinfoClass;
#define GC_TRIVIAL_TRACER_addrinfoClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo
//-----------------------------------------------------------
class avmplus_addrinfoObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::addrinfoObject;
#define GC_TRIVIAL_TRACER_addrinfoObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet$
//-----------------------------------------------------------
class avmshell_CNetinetInClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetinetInClass;
};
#define DECLARE_SLOTS_CNetinetInClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet
//-----------------------------------------------------------
class avmplus___netinetObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netinetObject;
#define GC_TRIVIAL_TRACER___netinetObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr$
//-----------------------------------------------------------
class avmplus_in_addrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in_addrClass;
#define GC_TRIVIAL_TRACER_in_addrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr
//-----------------------------------------------------------
class avmplus_in_addrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in_addrObject;
private:
    uint32_t m_s_addr;
#define GC_TRIVIAL_TRACER_in_addrObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in$
//-----------------------------------------------------------
class avmplus_sockaddr_inClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_inClass;
#define GC_TRIVIAL_TRACER_sockaddr_inClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in
//-----------------------------------------------------------
class avmplus_sockaddr_inObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_inObject;
private:
    uint32_t m_sin_family;
    uint32_t m_sin_port;
    MMgc::GCTraceableObject::GCMember<avmplus::in_addrObject> m_sin_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sin_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr$
//-----------------------------------------------------------
class avmplus_in6_addrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in6_addrClass;
#define GC_TRIVIAL_TRACER_in6_addrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr
//-----------------------------------------------------------
class avmplus_in6_addrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in6_addrObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::UIntVectorObject> m_s6_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_s6_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6$
//-----------------------------------------------------------
class avmplus_sockaddr_in6ClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_in6Class;
#define GC_TRIVIAL_TRACER_sockaddr_in6Class
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6
//-----------------------------------------------------------
class avmplus_sockaddr_in6ObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_in6Object;
private:
    uint32_t m_sin6_family;
    uint32_t m_sin6_port;
    uint32_t m_sin6_flowinfo;
    uint32_t m_sin6_scope_id;
    MMgc::GCTraceableObject::GCMember<avmplus::in6_addrObject> m_sin6_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sin6_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq$
//-----------------------------------------------------------
class avmplus_ipv6_mreqClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqClass;
#define GC_TRIVIAL_TRACER_ipv6_mreqClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq
//-----------------------------------------------------------
class avmplus_ipv6_mreqObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqObject;
private:
    uint32_t m_ipv6mr_interface;
    MMgc::GCTraceableObject::GCMember<avmplus::in6_addrObject> m_ipv6mr_multiaddr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ipv6mr_multiaddr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t$
//-----------------------------------------------------------
class avmshell_Cpid_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tClass;
};
#define DECLARE_SLOTS_Cpid_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cpid_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t
//-----------------------------------------------------------
class avmshell_Cpid_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tObject;
private:
    int32_t m_value;
};
#define DECLARE_SLOTS_Cpid_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_value() const { return m_slots_Cpid_tObject.m_value; } \
        REALLY_INLINE void set_value(int32_t newVal) { m_slots_Cpid_tObject.m_value = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cpid_tObjectSlots m_slots_Cpid_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket$
//-----------------------------------------------------------
class avmshell_CSysSocketClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysSocketClass;
};
#define DECLARE_SLOTS_CSysSocketClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket
//-----------------------------------------------------------
class avmplus___socketObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__socketObject;
#define GC_TRIVIAL_TRACER___socketObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockd$
//-----------------------------------------------------------
class avmplus_sockdClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockdClass;
#define GC_TRIVIAL_TRACER_sockdClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockd
//-----------------------------------------------------------
class avmplus_sockdObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockdObject;
#define GC_TRIVIAL_TRACER_sockdObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr$
//-----------------------------------------------------------
class avmplus_sockaddrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddrClass;
#define GC_TRIVIAL_TRACER_sockaddrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr
//-----------------------------------------------------------
class avmplus_sockaddrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddrObject;
private:
    uint32_t m_sa_family;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_sa_data;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sa_data);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage$
//-----------------------------------------------------------
class avmplus_sockaddr_storageClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageClass;
#define GC_TRIVIAL_TRACER_sockaddr_storageClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage
//-----------------------------------------------------------
class avmplus_sockaddr_storageObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageObject;
private:
    uint32_t m_ss_family;
#define GC_TRIVIAL_TRACER_sockaddr_storageObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr$
//-----------------------------------------------------------
class avmplus_msghdrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrClass;
#define GC_TRIVIAL_TRACER_msghdrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr
//-----------------------------------------------------------
class avmplus_msghdrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrObject;
private:
    int32_t m_msg_namelen;
    int32_t m_msg_iovlen;
    int32_t m_msg_controllen;
    int32_t m_msg_flags;
    avmplus::AtomWB m_msg_name;
    avmplus::AtomWB m_msg_iov;
    avmplus::AtomWB m_msg_control;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceAtom(&m_msg_name);
        gc->TraceAtom(&m_msg_iov);
        gc->TraceAtom(&m_msg_control);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat$
//-----------------------------------------------------------
class avmshell_CSysStatClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysStatClass;
};
#define DECLARE_SLOTS_CSysStatClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat
//-----------------------------------------------------------
class avmplus___statObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__statObject;
#define GC_TRIVIAL_TRACER___statObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status$
//-----------------------------------------------------------
class avmshell_CStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusClass;
};
#define DECLARE_SLOTS_CStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status
//-----------------------------------------------------------
class avmshell_CStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusObject;
private:
    int32_t m_st_dev;
    uint32_t m_st_ino;
    int32_t m_st_mode;
    int32_t m_st_nlink;
    int32_t m_st_uid;
    int32_t m_st_gid;
    int32_t m_st_rdev;
    double m_st_size;
    double m_st_atime;
    double m_st_mtime;
    double m_st_ctime;
};
#define DECLARE_SLOTS_CStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_st_dev() const { return m_slots_CStatusObject.m_st_dev; } \
        REALLY_INLINE void set_st_dev(int32_t newVal) { m_slots_CStatusObject.m_st_dev = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_st_ino() const { return m_slots_CStatusObject.m_st_ino; } \
        REALLY_INLINE void set_st_ino(uint32_t newVal) { m_slots_CStatusObject.m_st_ino = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_mode() const { return m_slots_CStatusObject.m_st_mode; } \
        REALLY_INLINE void set_st_mode(int32_t newVal) { m_slots_CStatusObject.m_st_mode = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_nlink() const { return m_slots_CStatusObject.m_st_nlink; } \
        REALLY_INLINE void set_st_nlink(int32_t newVal) { m_slots_CStatusObject.m_st_nlink = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_uid() const { return m_slots_CStatusObject.m_st_uid; } \
        REALLY_INLINE void set_st_uid(int32_t newVal) { m_slots_CStatusObject.m_st_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_gid() const { return m_slots_CStatusObject.m_st_gid; } \
        REALLY_INLINE void set_st_gid(int32_t newVal) { m_slots_CStatusObject.m_st_gid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_rdev() const { return m_slots_CStatusObject.m_st_rdev; } \
        REALLY_INLINE void set_st_rdev(int32_t newVal) { m_slots_CStatusObject.m_st_rdev = newVal; } \
    public: \
        REALLY_INLINE double get_st_size() const { return m_slots_CStatusObject.m_st_size; } \
        REALLY_INLINE void set_st_size(double newVal) { m_slots_CStatusObject.m_st_size = newVal; } \
    public: \
        REALLY_INLINE double get_st_atime() const { return m_slots_CStatusObject.m_st_atime; } \
        REALLY_INLINE void set_st_atime(double newVal) { m_slots_CStatusObject.m_st_atime = newVal; } \
    public: \
        REALLY_INLINE double get_st_mtime() const { return m_slots_CStatusObject.m_st_mtime; } \
        REALLY_INLINE void set_st_mtime(double newVal) { m_slots_CStatusObject.m_st_mtime = newVal; } \
    public: \
        REALLY_INLINE double get_st_ctime() const { return m_slots_CStatusObject.m_st_ctime; } \
        REALLY_INLINE void set_st_ctime(double newVal) { m_slots_CStatusObject.m_st_ctime = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CStatusObjectSlots m_slots_CStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait$
//-----------------------------------------------------------
class avmshell_CSysWaitClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysWaitClass;
};
#define DECLARE_SLOTS_CSysWaitClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait
//-----------------------------------------------------------
class avmplus___waitObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__waitObject;
#define GC_TRIVIAL_TRACER___waitObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status$
//-----------------------------------------------------------
class avmshell_CWaitStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusClass;
};
#define DECLARE_SLOTS_CWaitStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CWaitStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status
//-----------------------------------------------------------
class avmshell_CWaitStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusObject;
private:
    int32_t m_stat_loc;
};
#define DECLARE_SLOTS_CWaitStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_stat_loc() const { return m_slots_CWaitStatusObject.m_stat_loc; } \
        REALLY_INLINE void set_stat_loc(int32_t newVal) { m_slots_CWaitStatusObject.m_stat_loc = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CWaitStatusObjectSlots m_slots_CWaitStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd$
//-----------------------------------------------------------
class avmshell_CUnistdClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CUnistdClass;
};
#define DECLARE_SLOTS_CUnistdClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd
//-----------------------------------------------------------
class avmplus___unistdObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__unistdObject;
#define GC_TRIVIAL_TRACER___unistdObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program$
//-----------------------------------------------------------
class avmshell_ProgramClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ProgramClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_http___code_google_com_p_redtamarin_AVM2__shell;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_http___code_google_com_p_redtamarin_AVM2__exitcall;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_argv;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_filename;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_startupDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_onExit;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_findShell;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__shell);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__exitcall);
        gc->TraceLocation(&m_argv);
        gc->TraceLocation(&m_filename);
        gc->TraceLocation(&m_startupDirectory);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_onExit);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_findShell);
    }
};
#define DECLARE_SLOTS_ProgramClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::String* get__shell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell; } \
        REALLY_INLINE void set__shell(avmplus::String* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__exitcall() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall; } \
        REALLY_INLINE void set__exitcall(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_argv() const { return m_slots_ProgramClass.m_argv; } \
        REALLY_INLINE void setconst_argv(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_argv = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_filename() const { return m_slots_ProgramClass.m_filename; } \
        REALLY_INLINE void setconst_filename(avmplus::String* newVal) { m_slots_ProgramClass.m_filename = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_startupDirectory() const { return m_slots_ProgramClass.m_startupDirectory; } \
        REALLY_INLINE void setconst_startupDirectory(avmplus::String* newVal) { m_slots_ProgramClass.m_startupDirectory = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_onExit() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit; } \
        REALLY_INLINE void set_onExit(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_findShell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell; } \
        REALLY_INLINE void set_findShell(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ProgramClassSlots m_slots_ProgramClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program
//-----------------------------------------------------------
class avmplus_ProgramObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ProgramObject;
#define GC_TRIVIAL_TRACER_ProgramObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime$
//-----------------------------------------------------------
class avmshell_RuntimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::RuntimeClass;
private:
    avmplus::AtomWB m_private__localAvmplusDescription;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__API;
    MMgc::GCTraceableObject::GCMember<avmplus::EventLoopInterface> m_private__loop;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_goAsync;
};
#define DECLARE_SLOTS_RuntimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::Atom get__localAvmplusDescription() const { return m_slots_RuntimeClass.m_private__localAvmplusDescription; } \
        REALLY_INLINE void set__localAvmplusDescription(avmplus::Atom newVal) { m_slots_RuntimeClass.m_private__localAvmplusDescription = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__API() const { return m_slots_RuntimeClass.m_private__API; } \
        REALLY_INLINE void set__API(avmplus::ArrayObject* newVal) { m_slots_RuntimeClass.m_private__API = newVal; } \
    protected: \
        REALLY_INLINE avmplus::EventLoopInterface* get__loop() const { return m_slots_RuntimeClass.m_private__loop; } \
        REALLY_INLINE void set__loop(avmplus::EventLoopInterface* newVal) { m_slots_RuntimeClass.m_private__loop = newVal; } \
    public: \
        REALLY_INLINE avmplus::FunctionObject* get_goAsync() const { return m_slots_RuntimeClass.m_goAsync; } \
        REALLY_INLINE void set_goAsync(avmplus::FunctionObject* newVal) { m_slots_RuntimeClass.m_goAsync = newVal; } \
    private: \
        avmplus::NativeID::avmshell_RuntimeClassSlots m_slots_RuntimeClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime
//-----------------------------------------------------------
class avmplus_RuntimeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RuntimeObject;
#define GC_TRIVIAL_TRACER_RuntimeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics$
//-----------------------------------------------------------
class avmshell_DiagnosticsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::DiagnosticsClass;
};
#define DECLARE_SLOTS_DiagnosticsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics
//-----------------------------------------------------------
class avmplus_DiagnosticsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DiagnosticsObject;
#define GC_TRIVIAL_TRACER_DiagnosticsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation$
//-----------------------------------------------------------
class avmshell_HardwareInformationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::HardwareInformationClass;
};
#define DECLARE_SLOTS_HardwareInformationClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation
//-----------------------------------------------------------
class avmplus_HardwareInformationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HardwareInformationObject;
#define GC_TRIVIAL_TRACER_HardwareInformationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem$
//-----------------------------------------------------------
class avmshell_OperatingSystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::OperatingSystemClass;
};
#define DECLARE_SLOTS_OperatingSystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem
//-----------------------------------------------------------
class avmplus_OperatingSystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::OperatingSystemObject;
#define GC_TRIVIAL_TRACER_OperatingSystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode$
//-----------------------------------------------------------
class avmplus_RunModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MIXED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JITORDIE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INTERP;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_MIXED);
        gc->TraceLocation(&m_JITORDIE);
        gc->TraceLocation(&m_JIT);
        gc->TraceLocation(&m_INTERP);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode
//-----------------------------------------------------------
class avmplus_RunModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeObject;
#define GC_TRIVIAL_TRACER_RunModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain$
//-----------------------------------------------------------
class avmplus_DomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainClass;
#define GC_TRIVIAL_TRACER_DomainClass
};
#define DECLARE_SLOTS_DomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::DomainObject> constructObject(GCRef<avmplus::DomainObject> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain
//-----------------------------------------------------------
class avmplus_DomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainObject;
#define GC_TRIVIAL_TRACER_DomainObject
};
#define DECLARE_SLOTS_DomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileIO$
//-----------------------------------------------------------
class avmshell_FileClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileClass;
};
#define DECLARE_SLOTS_FileClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileIO
//-----------------------------------------------------------
class avmplus_FileIOObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileIOObject;
#define GC_TRIVIAL_TRACER_FileIOObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment$
//-----------------------------------------------------------
class avmplus_EnvironmentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentClass;
#define GC_TRIVIAL_TRACER_EnvironmentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment
//-----------------------------------------------------------
class avmplus_EnvironmentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__vars;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__idx;
    avmplus::AtomWB m_private__env;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__vars);
        gc->TraceLocation(&m_private__idx);
        gc->TraceAtom(&m_private__env);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData$
//-----------------------------------------------------------
class avmplus_BinaryDataClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataClass;
#define GC_TRIVIAL_TRACER_BinaryDataClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData
//-----------------------------------------------------------
class avmplus_BinaryDataObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataObject;
#define GC_TRIVIAL_TRACER_BinaryDataObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility$
//-----------------------------------------------------------
class avmplus_AccessibilityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityClass;
#define GC_TRIVIAL_TRACER_AccessibilityClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility
//-----------------------------------------------------------
class avmplus_AccessibilityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityObject;
#define GC_TRIVIAL_TRACER_AccessibilityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation$
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationClass;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationObject;
private:
    uint32_t m_errno;
    avmplus::bool32 m_stub;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties$
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesClass;
#define GC_TRIVIAL_TRACER_AccessibilityPropertiesClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesObject;
private:
    avmplus::bool32 m_silent;
    avmplus::bool32 m_forceSimple;
    avmplus::bool32 m_noAutoLabeling;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_description;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_shortcut;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_description);
        gc->TraceLocation(&m_shortcut);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore$
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreClass;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreObject;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType$
//-----------------------------------------------------------
class avmplus_SQLCollationTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeClass;
#define GC_TRIVIAL_TRACER_SQLCollationTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType
//-----------------------------------------------------------
class avmplus_SQLCollationTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeObject;
#define GC_TRIVIAL_TRACER_SQLCollationTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle$
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleClass;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleObject;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema$
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaClass;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaObject;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection$
//-----------------------------------------------------------
class avmplus_SQLConnectionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionClass;
#define GC_TRIVIAL_TRACER_SQLConnectionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection
//-----------------------------------------------------------
class avmplus_SQLConnectionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionObject;
#define GC_TRIVIAL_TRACER_SQLConnectionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema$
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaClass;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaObject;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode$
//-----------------------------------------------------------
class avmplus_SQLModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeClass;
#define GC_TRIVIAL_TRACER_SQLModeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode
//-----------------------------------------------------------
class avmplus_SQLModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeObject;
#define GC_TRIVIAL_TRACER_SQLModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult$
//-----------------------------------------------------------
class avmplus_SQLResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultClass;
#define GC_TRIVIAL_TRACER_SQLResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult
//-----------------------------------------------------------
class avmplus_SQLResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultObject;
#define GC_TRIVIAL_TRACER_SQLResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema$
//-----------------------------------------------------------
class avmplus_SQLSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaClass;
#define GC_TRIVIAL_TRACER_SQLSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema
//-----------------------------------------------------------
class avmplus_SQLSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaObject;
#define GC_TRIVIAL_TRACER_SQLSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult$
//-----------------------------------------------------------
class avmplus_SQLSchemaResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultClass;
#define GC_TRIVIAL_TRACER_SQLSchemaResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult
//-----------------------------------------------------------
class avmplus_SQLSchemaResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultObject;
#define GC_TRIVIAL_TRACER_SQLSchemaResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement$
//-----------------------------------------------------------
class avmplus_SQLStatementClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementClass;
#define GC_TRIVIAL_TRACER_SQLStatementClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement
//-----------------------------------------------------------
class avmplus_SQLStatementObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementObject;
#define GC_TRIVIAL_TRACER_SQLStatementObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema$
//-----------------------------------------------------------
class avmplus_SQLTableSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTableSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema
//-----------------------------------------------------------
class avmplus_SQLTableSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTableSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType$
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeClass;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeObject;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema$
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema$
//-----------------------------------------------------------
class avmplus_SQLViewSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaClass;
#define GC_TRIVIAL_TRACER_SQLViewSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema
//-----------------------------------------------------------
class avmplus_SQLViewSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaObject;
#define GC_TRIVIAL_TRACER_SQLViewSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion$
//-----------------------------------------------------------
class avmplus_ActionScriptVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionClass;
private:
    uint32_t m_ACTIONSCRIPT2;
    uint32_t m_ACTIONSCRIPT3;
#define GC_TRIVIAL_TRACER_ActionScriptVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion
//-----------------------------------------------------------
class avmplus_ActionScriptVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionObject;
#define GC_TRIVIAL_TRACER_ActionScriptVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping$
//-----------------------------------------------------------
class avmplus_PixelSnappingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEVER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ALWAYS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AUTO;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEVER);
        gc->TraceLocation(&m_ALWAYS);
        gc->TraceLocation(&m_AUTO);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping
//-----------------------------------------------------------
class avmplus_PixelSnappingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingObject;
#define GC_TRIVIAL_TRACER_PixelSnappingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions$
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsClass;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsObject;
private:
    avmplus::bool32 m_fastCompression;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene$
//-----------------------------------------------------------
class avmplus_SceneClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneClass;
#define GC_TRIVIAL_TRACER_SceneClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene
//-----------------------------------------------------------
class avmplus_SceneObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneObject;
private:
    int32_t m_private__numFrames;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__labels;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__name);
        gc->TraceLocation(&m_private__labels);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign$
//-----------------------------------------------------------
class avmplus_StageAlignClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_RIGHT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TOP);
        gc->TraceLocation(&m_LEFT);
        gc->TraceLocation(&m_BOTTOM);
        gc->TraceLocation(&m_RIGHT);
        gc->TraceLocation(&m_TOP_LEFT);
        gc->TraceLocation(&m_TOP_RIGHT);
        gc->TraceLocation(&m_BOTTOM_LEFT);
        gc->TraceLocation(&m_BOTTOM_RIGHT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign
//-----------------------------------------------------------
class avmplus_StageAlignObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignObject;
#define GC_TRIVIAL_TRACER_StageAlignObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio$
//-----------------------------------------------------------
class avmplus_StageAspectRatioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LANDSCAPE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PORTRAIT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANY);
        gc->TraceLocation(&m_LANDSCAPE);
        gc->TraceLocation(&m_PORTRAIT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio
//-----------------------------------------------------------
class avmplus_StageAspectRatioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioObject;
#define GC_TRIVIAL_TRACER_StageAspectRatioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState$
//-----------------------------------------------------------
class avmplus_StageDisplayStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN_INTERACTIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NORMAL;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_FULL_SCREEN);
        gc->TraceLocation(&m_FULL_SCREEN_INTERACTIVE);
        gc->TraceLocation(&m_NORMAL);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState
//-----------------------------------------------------------
class avmplus_StageDisplayStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateObject;
#define GC_TRIVIAL_TRACER_StageDisplayStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation$
//-----------------------------------------------------------
class avmplus_StageOrientationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEFAULT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UPSIDE_DOWN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_DEFAULT);
        gc->TraceLocation(&m_ROTATED_LEFT);
        gc->TraceLocation(&m_ROTATED_RIGHT);
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_UPSIDE_DOWN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation
//-----------------------------------------------------------
class avmplus_StageOrientationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationObject;
#define GC_TRIVIAL_TRACER_StageOrientationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality$
//-----------------------------------------------------------
class avmplus_StageQualityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MEDIUM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEST;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8_LINEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16_LINEAR;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_LOW);
        gc->TraceLocation(&m_MEDIUM);
        gc->TraceLocation(&m_HIGH);
        gc->TraceLocation(&m_BEST);
        gc->TraceLocation(&m_HIGH_8X8);
        gc->TraceLocation(&m_HIGH_8X8_LINEAR);
        gc->TraceLocation(&m_HIGH_16X16);
        gc->TraceLocation(&m_HIGH_16X16_LINEAR);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality
//-----------------------------------------------------------
class avmplus_StageQualityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityObject;
#define GC_TRIVIAL_TRACER_StageQualityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode$
//-----------------------------------------------------------
class avmplus_StageScaleModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SHOW_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXACT_FIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_BORDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_SCALE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_SHOW_ALL);
        gc->TraceLocation(&m_EXACT_FIT);
        gc->TraceLocation(&m_NO_BORDER);
        gc->TraceLocation(&m_NO_SCALE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode
//-----------------------------------------------------------
class avmplus_StageScaleModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeObject;
#define GC_TRIVIAL_TRACER_StageScaleModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion$
//-----------------------------------------------------------
class avmplus_SWFVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionClass;
private:
    uint32_t m_FLASH1;
    uint32_t m_FLASH2;
    uint32_t m_FLASH3;
    uint32_t m_FLASH4;
    uint32_t m_FLASH5;
    uint32_t m_FLASH6;
    uint32_t m_FLASH7;
    uint32_t m_FLASH8;
    uint32_t m_FLASH9;
    uint32_t m_FLASH10;
    uint32_t m_FLASH11;
    uint32_t m_FLASH12;
    uint32_t m_FLASH13;
    uint32_t m_FLASH14;
    uint32_t m_FLASH15;
    uint32_t m_FLASH16;
    uint32_t m_FLASH17;
    uint32_t m_FLASH18;
    uint32_t m_FLASH19;
#define GC_TRIVIAL_TRACER_SWFVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion
//-----------------------------------------------------------
class avmplus_SWFVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionObject;
#define GC_TRIVIAL_TRACER_SWFVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling$
//-----------------------------------------------------------
class avmplus_TriangleCullingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NONE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_POSITIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEGATIVE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NONE);
        gc->TraceLocation(&m_POSITIVE);
        gc->TraceLocation(&m_NEGATIVE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling
//-----------------------------------------------------------
class avmplus_TriangleCullingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingObject;
#define GC_TRIVIAL_TRACER_TriangleCullingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError$
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorClass;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorObject;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError$
//-----------------------------------------------------------
class avmplus_StackOverflowErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorClass;
#define GC_TRIVIAL_TRACER_StackOverflowErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError
//-----------------------------------------------------------
class avmplus_StackOverflowErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorObject;
#define GC_TRIVIAL_TRACER_StackOverflowErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError$
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorClass;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorObject;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation$
//-----------------------------------------------------------
class avmplus_SQLErrorOperationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ATTACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEGIN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMMIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPACT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DETACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXECUTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REENCRYPT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RELEASE_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK_TO_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCHEMA;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SET_SAVEPOINT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANALYZE);
        gc->TraceLocation(&m_ATTACH);
        gc->TraceLocation(&m_BEGIN);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMMIT);
        gc->TraceLocation(&m_COMPACT);
        gc->TraceLocation(&m_DEANALYZE);
        gc->TraceLocation(&m_DETACH);
        gc->TraceLocation(&m_EXECUTE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_REENCRYPT);
        gc->TraceLocation(&m_RELEASE_SAVEPOINT);
        gc->TraceLocation(&m_ROLLBACK);
        gc->TraceLocation(&m_ROLLBACK_TO_SAVEPOINT);
        gc->TraceLocation(&m_SCHEMA);
        gc->TraceLocation(&m_SET_SAVEPOINT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation
//-----------------------------------------------------------
class avmplus_SQLErrorOperationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationObject;
#define GC_TRIVIAL_TRACER_SQLErrorOperationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError$
//-----------------------------------------------------------
class avmplus_SQLErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorClass;
#define GC_TRIVIAL_TRACER_SQLErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError
//-----------------------------------------------------------
class avmplus_SQLErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorObject;
private:
    int32_t m_private__detailID;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__operation;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__details;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__detailArguments;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__operation);
        gc->TraceLocation(&m_private__details);
        gc->TraceLocation(&m_private__detailArguments);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError$
//-----------------------------------------------------------
class avmplus_DRMManagerErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorClass;
#define GC_TRIVIAL_TRACER_DRMManagerErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError
//-----------------------------------------------------------
class avmplus_DRMManagerErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorObject;
private:
    int32_t m_private__subErrorID;
#define GC_TRIVIAL_TRACER_DRMManagerErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event$
//-----------------------------------------------------------
class avmplus_EventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED_TO_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CANCEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONNECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COPY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CUT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ENTER_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_CONSTRUCTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXIT_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_LABEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ID3;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MOUSE_LEAVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PASTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED_FROM_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RESIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCROLL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXT_INTERACTION_MODE_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SOUND_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_CHILDREN_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_ENABLED_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_INDEX_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNLOAD;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULLSCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONTEXT3D_CREATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXTURE_READY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_VIDEO_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SUSPEND;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_MESSAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXITING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DISPLAYING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PREPARING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NETWORK_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_IDLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_PRESENT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_OUTPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_ERROR_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_INPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_BOUNDS_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_DOM_INITIALIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCATION_CHANGE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ACTIVATE);
        gc->TraceLocation(&m_ADDED);
        gc->TraceLocation(&m_ADDED_TO_STAGE);
        gc->TraceLocation(&m_CANCEL);
        gc->TraceLocation(&m_CHANGE);
        gc->TraceLocation(&m_CLEAR);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMPLETE);
        gc->TraceLocation(&m_CONNECT);
        gc->TraceLocation(&m_COPY);
        gc->TraceLocation(&m_CUT);
        gc->TraceLocation(&m_DEACTIVATE);
        gc->TraceLocation(&m_ENTER_FRAME);
        gc->TraceLocation(&m_FRAME_CONSTRUCTED);
        gc->TraceLocation(&m_EXIT_FRAME);
        gc->TraceLocation(&m_FRAME_LABEL);
        gc->TraceLocation(&m_ID3);
        gc->TraceLocation(&m_INIT);
        gc->TraceLocation(&m_MOUSE_LEAVE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_PASTE);
        gc->TraceLocation(&m_REMOVED);
        gc->TraceLocation(&m_REMOVED_FROM_STAGE);
        gc->TraceLocation(&m_RENDER);
        gc->TraceLocation(&m_RESIZE);
        gc->TraceLocation(&m_SCROLL);
        gc->TraceLocation(&m_TEXT_INTERACTION_MODE_CHANGE);
        gc->TraceLocation(&m_SELECT);
        gc->TraceLocation(&m_SELECT_ALL);
        gc->TraceLocation(&m_SOUND_COMPLETE);
        gc->TraceLocation(&m_TAB_CHILDREN_CHANGE);
        gc->TraceLocation(&m_TAB_ENABLED_CHANGE);
        gc->TraceLocation(&m_TAB_INDEX_CHANGE);
        gc->TraceLocation(&m_UNLOAD);
        gc->TraceLocation(&m_FULLSCREEN);
        gc->TraceLocation(&m_CONTEXT3D_CREATE);
        gc->TraceLocation(&m_TEXTURE_READY);
        gc->TraceLocation(&m_VIDEO_FRAME);
        gc->TraceLocation(&m_SUSPEND);
        gc->TraceLocation(&m_CHANNEL_MESSAGE);
        gc->TraceLocation(&m_CHANNEL_STATE);
        gc->TraceLocation(&m_WORKER_STATE);
        gc->TraceLocation(&m_CLOSING);
        gc->TraceLocation(&m_EXITING);
        gc->TraceLocation(&m_DISPLAYING);
        gc->TraceLocation(&m_PREPARING);
        gc->TraceLocation(&m_NETWORK_CHANGE);
        gc->TraceLocation(&m_USER_IDLE);
        gc->TraceLocation(&m_USER_PRESENT);
        gc->TraceLocation(&m_STANDARD_OUTPUT_CLOSE);
        gc->TraceLocation(&m_STANDARD_ERROR_CLOSE);
        gc->TraceLocation(&m_STANDARD_INPUT_CLOSE);
        gc->TraceLocation(&m_HTML_BOUNDS_CHANGE);
        gc->TraceLocation(&m_HTML_RENDER);
        gc->TraceLocation(&m_HTML_DOM_INITIALIZE);
        gc->TraceLocation(&m_LOCATION_CHANGE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event
//-----------------------------------------------------------
class avmplus_EventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventObject;
private:
    avmplus::bool32 m_private__bubbles;
    avmplus::bool32 m_private__cancelable;
    uint32_t m_private__currentphase;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__type;
    avmplus::AtomWB m_private__target;
    avmplus::AtomWB m_private__currenttarget;
    avmplus::AtomWB m_private__preventdefault;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__type);
        gc->TraceAtom(&m_private__target);
        gc->TraceAtom(&m_private__currenttarget);
        gc->TraceAtom(&m_private__preventdefault);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D$
//-----------------------------------------------------------
class avmplus_Orientation3DClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EULER_ANGLES;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AXIS_ANGLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_QUATERNION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_EULER_ANGLES);
        gc->TraceLocation(&m_AXIS_ANGLE);
        gc->TraceLocation(&m_QUATERNION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D
//-----------------------------------------------------------
class avmplus_Orientation3DObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DObject;
#define GC_TRIVIAL_TRACER_Orientation3DObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point$
//-----------------------------------------------------------
class avmplus_PointClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointClass;
#define GC_TRIVIAL_TRACER_PointClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point
//-----------------------------------------------------------
class avmplus_PointObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointObject;
private:
    double m_x;
    double m_y;
#define GC_TRIVIAL_TRACER_PointObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle$
//-----------------------------------------------------------
class avmplus_RectangleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleClass;
#define GC_TRIVIAL_TRACER_RectangleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle
//-----------------------------------------------------------
class avmplus_RectangleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleObject;
private:
    double m_x;
    double m_y;
    double m_width;
    double m_height;
#define GC_TRIVIAL_TRACER_RectangleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader$
//-----------------------------------------------------------
class avmplus_URLRequestHeaderClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderClass;
#define GC_TRIVIAL_TRACER_URLRequestHeaderClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader
//-----------------------------------------------------------
class avmplus_URLRequestHeaderObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_value;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_value);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame$
//-----------------------------------------------------------
class avmplus_StackFrameClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameClass;
#define GC_TRIVIAL_TRACER_StackFrameClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame
//-----------------------------------------------------------
class avmplus_StackFrameObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameObject;
private:
    uint32_t m_line;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_file;
    double m_scriptID;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_file);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample$
//-----------------------------------------------------------
class avmplus_SampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleClass;
#define GC_TRIVIAL_TRACER_SampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample
//-----------------------------------------------------------
class avmplus_SampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_stack;
    double m_time;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_stack);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory$
//-----------------------------------------------------------
class avmplus_ClassFactoryClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_StackFrameClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_SampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_DeleteObjectSampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_NewObjectSampleClass;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_StackFrameClass);
        gc->TraceLocation(&m_SampleClass);
        gc->TraceLocation(&m_DeleteObjectSampleClass);
        gc->TraceLocation(&m_NewObjectSampleClass);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory
//-----------------------------------------------------------
class avmplus_ClassFactoryObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryObject;
#define GC_TRIVIAL_TRACER_ClassFactoryObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities$
//-----------------------------------------------------------
class avmplus_CapabilitiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesClass;
#define GC_TRIVIAL_TRACER_CapabilitiesClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities
//-----------------------------------------------------------
class avmplus_CapabilitiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesObject;
#define GC_TRIVIAL_TRACER_CapabilitiesObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System$
//-----------------------------------------------------------
class avmshell_SystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::SystemClass;
private:
    avmplus::bool32 m_private__useCodePage;
};
#define DECLARE_SLOTS_SystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE bool get__useCodePage() const { return m_slots_SystemClass.m_private__useCodePage != 0; } \
        REALLY_INLINE void set__useCodePage(avmplus::bool32 newVal) { m_slots_SystemClass.m_private__useCodePage = newVal; } \
    private: \
        avmplus::NativeID::avmshell_SystemClassSlots m_slots_SystemClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System
//-----------------------------------------------------------
class avmplus_SystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SystemObject;
#define GC_TRIVIAL_TRACER_SystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState$
//-----------------------------------------------------------
class avmplus_WorkerStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RUNNING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TERMINATED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FAILED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ABORTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXCEPTION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEW);
        gc->TraceLocation(&m_RUNNING);
        gc->TraceLocation(&m_TERMINATED);
        gc->TraceLocation(&m_FAILED);
        gc->TraceLocation(&m_ABORTED);
        gc->TraceLocation(&m_EXCEPTION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState
//-----------------------------------------------------------
class avmplus_WorkerStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateObject;
#define GC_TRIVIAL_TRACER_WorkerStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker$
//-----------------------------------------------------------
class avmshell_ShellWorkerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct_native(avmshell::ShellWorkerClass::createInstanceProc, 0, args); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerObject* get_m_current() const { return m_slots_ShellWorkerClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerObject* newVal) { m_slots_ShellWorkerClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerClassSlots m_slots_ShellWorkerClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker
//-----------------------------------------------------------
class avmshell_ShellWorkerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ByteArrayObject> m_private_m_byteCode;
};
#define DECLARE_SLOTS_ShellWorkerObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::ByteArrayObject* get_m_byteCode() const { return m_slots_ShellWorkerObject.m_private_m_byteCode; } \
        REALLY_INLINE void set_m_byteCode(avmplus::ByteArrayObject* newVal) { m_slots_ShellWorkerObject.m_private_m_byteCode = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerObjectSlots m_slots_ShellWorkerObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent$
//-----------------------------------------------------------
class avmplus_WorkerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_WORKER_STATE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent
//-----------------------------------------------------------
class avmplus_WorkerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_previousState;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_currentState;
    avmplus::AtomWB m_flash_system_m_target;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private_m_previousState);
        gc->TraceLocation(&m_private_m_currentState);
        gc->TraceAtom(&m_flash_system_m_target);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain$
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerDomainObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerDomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerDomainObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerDomainObject* get_m_current() const { return m_slots_ShellWorkerDomainClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerDomainObject* newVal) { m_slots_ShellWorkerDomainClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerDomainClassSlots m_slots_ShellWorkerDomainClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainObject;
};
#define DECLARE_SLOTS_ShellWorkerDomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace$
//-----------------------------------------------------------
class avmplus_TraceClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceClass;
private:
    int32_t m_OFF;
    int32_t m_METHODS;
    int32_t m_METHODS_WITH_ARGS;
    int32_t m_METHODS_AND_LINES;
    int32_t m_METHODS_AND_LINES_WITH_ARGS;
    avmplus::AtomWB m_FILE;
    avmplus::AtomWB m_LISTENER;
};
#define DECLARE_SLOTS_TraceClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_OFF() const { return m_slots_TraceClass.m_OFF; } \
        REALLY_INLINE void setconst_OFF(int32_t newVal) { m_slots_TraceClass.m_OFF = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS() const { return m_slots_TraceClass.m_METHODS; } \
        REALLY_INLINE void setconst_METHODS(int32_t newVal) { m_slots_TraceClass.m_METHODS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES() const { return m_slots_TraceClass.m_METHODS_AND_LINES; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_FILE() const { return m_slots_TraceClass.m_FILE; } \
        REALLY_INLINE void setconst_FILE(avmplus::Atom newVal) { m_slots_TraceClass.m_FILE = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_LISTENER() const { return m_slots_TraceClass.m_LISTENER; } \
        REALLY_INLINE void setconst_LISTENER(avmplus::Atom newVal) { m_slots_TraceClass.m_LISTENER = newVal; } \
    private: \
        avmplus::NativeID::avmplus_TraceClassSlots m_slots_TraceClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace
//-----------------------------------------------------------
class avmplus_TraceObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceObject;
#define GC_TRIVIAL_TRACER_TraceObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian$
//-----------------------------------------------------------
class avmplus_EndianClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BIG_ENDIAN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LITTLE_ENDIAN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_BIG_ENDIAN);
        gc->TraceLocation(&m_LITTLE_ENDIAN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian
//-----------------------------------------------------------
class avmplus_EndianObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianObject;
#define GC_TRIVIAL_TRACER_EndianObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop$
//-----------------------------------------------------------
class avmplus_CoreEventLoopClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopClass;
#define GC_TRIVIAL_TRACER_CoreEventLoopClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop
//-----------------------------------------------------------
class avmplus_CoreEventLoopObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopObject;
private:
    avmplus::bool32 m_private__running;
    uint32_t m_private__frequency;
    uint32_t m_private__started;
    uint32_t m_private__elapsed;
    uint32_t m_private__frame;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__timers;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__callback;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__timers);
        gc->TraceLocation(&m_private__callback);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher$
//-----------------------------------------------------------
class avmplus_EventDispatcherClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectlist;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectmap;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m__objectlist);
        gc->TraceLocation(&m__objectmap);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher
//-----------------------------------------------------------
class avmplus_EventDispatcherObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::IEventDispatcherInterface> m_private__target;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listeners;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersNames;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersCalls;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__target);
        gc->TraceLocation(&m__listeners);
        gc->TraceLocation(&m__listenersNames);
        gc->TraceLocation(&m__listenersCalls);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent$
//-----------------------------------------------------------
class avmplus_HTTPStatusEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_STATUS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_RESPONSE_STATUS;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_HTTP_STATUS);
        gc->TraceLocation(&m_HTTP_RESPONSE_STATUS);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent
//-----------------------------------------------------------
class avmplus_HTTPStatusEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventObject;
private:
    int32_t m_private__status;
    avmplus::bool32 m_private__redirected;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__responseHeaders;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__responseUrl;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__responseHeaders);
        gc->TraceLocation(&m_private__responseUrl);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent$
//-----------------------------------------------------------
class avmplus_TimerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER_COMPLETE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TIMER);
        gc->TraceLocation(&m_TIMER_COMPLETE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent
//-----------------------------------------------------------
class avmplus_TimerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventObject;
#define GC_TRIVIAL_TRACER_TimerEventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample$
//-----------------------------------------------------------
class avmplus_NewObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleClass;
};
#define DECLARE_SLOTS_NewObjectSampleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::NewObjectSampleObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample
//-----------------------------------------------------------
class avmplus_NewObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_type;
    double m_id;
};
#define DECLARE_SLOTS_NewObjectSampleObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE avmplus::ClassClosure* get_type() const { return m_slots_NewObjectSampleObject.m_type; } \
        REALLY_INLINE void setconst_type(avmplus::ClassClosure* newVal) { m_slots_NewObjectSampleObject.m_type = newVal; } \
    public: \
        REALLY_INLINE double get_id() const { return m_slots_NewObjectSampleObject.m_id; } \
        REALLY_INLINE void setconst_id(double newVal) { m_slots_NewObjectSampleObject.m_id = newVal; } \
    private: \
        avmplus::NativeID::avmplus_NewObjectSampleObjectSlots m_slots_NewObjectSampleObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample$
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleClass;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleObject;
private:
    double m_id;
    double m_size;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer$
//-----------------------------------------------------------
class avmplus_TimerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerClass;
#define GC_TRIVIAL_TRACER_TimerClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer
//-----------------------------------------------------------
class avmplus_TimerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerObject;
private:
    int32_t m_private__repeatCount;
    int32_t m_private__iteration;
    avmplus::bool32 m_private__running;
    uint32_t m__started;
    uint32_t m__elapsed;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__closure;
    double m_private__delay;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__closure);
    }
};
//-----------------------------------------------------------

} }
namespace avmplus {

class shell_toplevelClassManifest : public avmplus::ClassManifestBase
{
    friend class avmplus::AvmCore;
    friend class avmplus::IntVectorClass;
    friend class avmplus::UIntVectorClass;
    FLOAT_ONLY(friend class avmplus::FloatVectorClass;)
    FLOAT_ONLY(friend class avmplus::Float4VectorClass;)
    friend class avmplus::DoubleVectorClass;
    friend class avmplus::ObjectVectorClass;
private:
    REALLY_INLINE shell_toplevelClassManifest(avmplus::ScriptEnv* e) : ClassManifestBase(122, e) { }
    REALLY_INLINE static shell_toplevelClassManifest* create(avmplus::ScriptEnv* e) { return new (MMgc::GC::GetGC(e), MMgc::kExact, sizeof(ClassClosure*)*121) shell_toplevelClassManifest(e); }
public:
    REALLY_INLINE GCRef<avmplus::AccessibilityClass> get_AccessibilityClass() { return (avmplus::AccessibilityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_Accessibility)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityImplementationClass> get_AccessibilityImplementationClass() { return (avmplus::AccessibilityImplementationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityImplementation)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityPropertiesClass> get_AccessibilityPropertiesClass() { return (avmplus::AccessibilityPropertiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityProperties)); }
    REALLY_INLINE GCRef<avmplus::ActionScriptVersionClass> get_ActionScriptVersionClass() { return (avmplus::ActionScriptVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_ActionScriptVersion)); }
    REALLY_INLINE GCRef<avmplus::BinaryDataClass> get_BinaryDataClass() { return (avmplus::BinaryDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_BinaryData)); }
    REALLY_INLINE GCRef<avmplus::CErrorClass> get_CErrorClass() { return (avmplus::CErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_CError)); }
    REALLY_INLINE GCRef<avmplus::CapabilitiesClass> get_CapabilitiesClass() { return (avmplus::CapabilitiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Capabilities)); }
    REALLY_INLINE GCRef<avmplus::ClassFactoryClass> get_ClassFactoryClass() { return (avmplus::ClassFactoryClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_ClassFactory)); }
    REALLY_INLINE GCRef<avmplus::CoreEventLoopClass> get_CoreEventLoopClass() { return (avmplus::CoreEventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_CoreEventLoop)); }
    REALLY_INLINE GCRef<avmshell::CDIRClass> get_DIRClass() { return (avmshell::CDIRClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_dirent_DIR)); }
    REALLY_INLINE GCRef<avmplus::DRMManagerErrorClass> get_DRMManagerErrorClass() { return (avmplus::DRMManagerErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_DRMManagerError)); }
    REALLY_INLINE GCRef<avmplus::DeleteObjectSampleClass> get_DeleteObjectSampleClass() { return (avmplus::DeleteObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_DeleteObjectSample)); }
    REALLY_INLINE GCRef<avmshell::DiagnosticsClass> get_DiagnosticsClass() { return (avmshell::DiagnosticsClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Diagnostics)); }
    REALLY_INLINE GCRef<avmplus::DomainClass> get_DomainClass() { return (avmplus::DomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Domain)); }
    REALLY_INLINE GCRef<avmplus::EncryptedLocalStoreClass> get_EncryptedLocalStoreClass() { return (avmplus::EncryptedLocalStoreClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_EncryptedLocalStore)); }
    REALLY_INLINE GCRef<avmplus::EndianClass> get_EndianClass() { return (avmplus::EndianClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Endian)); }
    REALLY_INLINE GCRef<avmplus::EnvironmentClass> get_EnvironmentClass() { return (avmplus::EnvironmentClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Environment)); }
    REALLY_INLINE GCRef<avmplus::ErrorNumberClass> get_ErrorNumberClass() { return (avmplus::ErrorNumberClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_ErrorNumber)); }
    REALLY_INLINE GCRef<avmplus::EventClass> get_EventClass() { return (avmplus::EventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_Event)); }
    REALLY_INLINE GCRef<avmplus::EventDispatcherClass> get_EventDispatcherClass() { return (avmplus::EventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_EventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::EventLoopClass> get_EventLoopClass() { return (avmplus::EventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_EventLoop)); }
    REALLY_INLINE GCRef<avmshell::CFILEClass> get_FILEClass() { return (avmshell::CFILEClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_FILE)); }
    REALLY_INLINE GCRef<avmshell::FileClass> get_FileIOClass() { return (avmshell::FileClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_FileIO)); }
    REALLY_INLINE GCRef<avmplus::HTTPStatusEventClass> get_HTTPStatusEventClass() { return (avmplus::HTTPStatusEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_HTTPStatusEvent)); }
    REALLY_INLINE GCRef<avmshell::HardwareInformationClass> get_HardwareInformationClass() { return (avmshell::HardwareInformationClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_HardwareInformation)); }
    REALLY_INLINE GCRef<avmplus::IBitmapDrawableClass> get_IBitmapDrawableClass() { return (avmplus::IBitmapDrawableClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IBitmapDrawable)); }
    REALLY_INLINE GCRef<avmplus::IDrawCommandClass> get_IDrawCommandClass() { return (avmplus::IDrawCommandClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IDrawCommand)); }
    REALLY_INLINE GCRef<avmplus::IEventDispatcherClass> get_IEventDispatcherClass() { return (avmplus::IEventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_IEventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsDataClass> get_IGraphicsDataClass() { return (avmplus::IGraphicsDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsData)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsFillClass> get_IGraphicsFillClass() { return (avmplus::IGraphicsFillClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsFill)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsPathClass> get_IGraphicsPathClass() { return (avmplus::IGraphicsPathClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsPath)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsStrokeClass> get_IGraphicsStrokeClass() { return (avmplus::IGraphicsStrokeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsStroke)); }
    REALLY_INLINE GCRef<avmplus::ISearchableTextClass> get_ISearchableTextClass() { return (avmplus::ISearchableTextClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISearchableText)); }
    REALLY_INLINE GCRef<avmplus::ISimpleTextSelectionClass> get_ISimpleTextSelectionClass() { return (avmplus::ISimpleTextSelectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISimpleTextSelection)); }
    REALLY_INLINE GCRef<avmplus::InvalidSWFErrorClass> get_InvalidSWFErrorClass() { return (avmplus::InvalidSWFErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_InvalidSWFError)); }
    REALLY_INLINE GCRef<avmplus::NewObjectSampleClass> get_NewObjectSampleClass() { return (avmplus::NewObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_NewObjectSample)); }
    REALLY_INLINE GCRef<avmshell::OperatingSystemClass> get_OperatingSystemClass() { return (avmshell::OperatingSystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_OperatingSystem)); }
    REALLY_INLINE GCRef<avmplus::Orientation3DClass> get_Orientation3DClass() { return (avmplus::Orientation3DClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Orientation3D)); }
    REALLY_INLINE GCRef<avmplus::PNGEncoderOptionsClass> get_PNGEncoderOptionsClass() { return (avmplus::PNGEncoderOptionsClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PNGEncoderOptions)); }
    REALLY_INLINE GCRef<avmplus::PixelSnappingClass> get_PixelSnappingClass() { return (avmplus::PixelSnappingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PixelSnapping)); }
    REALLY_INLINE GCRef<avmplus::PointClass> get_PointClass() { return (avmplus::PointClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Point)); }
    REALLY_INLINE GCRef<avmshell::ProgramClass> get_ProgramClass() { return (avmshell::ProgramClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Program)); }
    REALLY_INLINE GCRef<avmplus::RectangleClass> get_RectangleClass() { return (avmplus::RectangleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Rectangle)); }
    REALLY_INLINE GCRef<avmplus::RunModeClass> get_RunModeClass() { return (avmplus::RunModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_RunMode)); }
    REALLY_INLINE GCRef<avmshell::RuntimeClass> get_RuntimeClass() { return (avmshell::RuntimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Runtime)); }
    REALLY_INLINE GCRef<avmplus::SQLCollationTypeClass> get_SQLCollationTypeClass() { return (avmplus::SQLCollationTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLCollationType)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnNameStyleClass> get_SQLColumnNameStyleClass() { return (avmplus::SQLColumnNameStyleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnNameStyle)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnSchemaClass> get_SQLColumnSchemaClass() { return (avmplus::SQLColumnSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLConnectionClass> get_SQLConnectionClass() { return (avmplus::SQLConnectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLConnection)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorClass> get_SQLErrorClass() { return (avmplus::SQLErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLError)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorOperationClass> get_SQLErrorOperationClass() { return (avmplus::SQLErrorOperationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLErrorOperation)); }
    REALLY_INLINE GCRef<avmplus::SQLIndexSchemaClass> get_SQLIndexSchemaClass() { return (avmplus::SQLIndexSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLIndexSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLModeClass> get_SQLModeClass() { return (avmplus::SQLModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLMode)); }
    REALLY_INLINE GCRef<avmplus::SQLResultClass> get_SQLResultClass() { return (avmplus::SQLResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLResult)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaClass> get_SQLSchemaClass() { return (avmplus::SQLSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaResultClass> get_SQLSchemaResultClass() { return (avmplus::SQLSchemaResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchemaResult)); }
    REALLY_INLINE GCRef<avmplus::SQLStatementClass> get_SQLStatementClass() { return (avmplus::SQLStatementClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLStatement)); }
    REALLY_INLINE GCRef<avmplus::SQLTableSchemaClass> get_SQLTableSchemaClass() { return (avmplus::SQLTableSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTableSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLTransactionLockTypeClass> get_SQLTransactionLockTypeClass() { return (avmplus::SQLTransactionLockTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTransactionLockType)); }
    REALLY_INLINE GCRef<avmplus::SQLTriggerSchemaClass> get_SQLTriggerSchemaClass() { return (avmplus::SQLTriggerSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTriggerSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLViewSchemaClass> get_SQLViewSchemaClass() { return (avmplus::SQLViewSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLViewSchema)); }
    REALLY_INLINE GCRef<avmplus::SWFVersionClass> get_SWFVersionClass() { return (avmplus::SWFVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_SWFVersion)); }
    REALLY_INLINE GCRef<avmplus::SampleClass> get_SampleClass() { return (avmplus::SampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_Sample)); }
    REALLY_INLINE GCRef<avmplus::SceneClass> get_SceneClass() { return (avmplus::SceneClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_Scene)); }
    REALLY_INLINE GCRef<avmplus::ScriptTimeoutErrorClass> get_ScriptTimeoutErrorClass() { return (avmplus::ScriptTimeoutErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_ScriptTimeoutError)); }
    REALLY_INLINE GCRef<avmplus::StackFrameClass> get_StackFrameClass() { return (avmplus::StackFrameClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_StackFrame)); }
    REALLY_INLINE GCRef<avmplus::StackOverflowErrorClass> get_StackOverflowErrorClass() { return (avmplus::StackOverflowErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_StackOverflowError)); }
    REALLY_INLINE GCRef<avmplus::StageAlignClass> get_StageAlignClass() { return (avmplus::StageAlignClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAlign)); }
    REALLY_INLINE GCRef<avmplus::StageAspectRatioClass> get_StageAspectRatioClass() { return (avmplus::StageAspectRatioClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAspectRatio)); }
    REALLY_INLINE GCRef<avmplus::StageDisplayStateClass> get_StageDisplayStateClass() { return (avmplus::StageDisplayStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageDisplayState)); }
    REALLY_INLINE GCRef<avmplus::StageOrientationClass> get_StageOrientationClass() { return (avmplus::StageOrientationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageOrientation)); }
    REALLY_INLINE GCRef<avmplus::StageQualityClass> get_StageQualityClass() { return (avmplus::StageQualityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageQuality)); }
    REALLY_INLINE GCRef<avmplus::StageScaleModeClass> get_StageScaleModeClass() { return (avmplus::StageScaleModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageScaleMode)); }
    REALLY_INLINE GCRef<avmshell::SystemClass> get_SystemClass() { return (avmshell::SystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_System)); }
    REALLY_INLINE GCRef<avmplus::TimerClass> get_TimerClass() { return (avmplus::TimerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Timer)); }
    REALLY_INLINE GCRef<avmplus::TimerEventClass> get_TimerEventClass() { return (avmplus::TimerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_TimerEvent)); }
    REALLY_INLINE GCRef<avmplus::TraceClass> get_TraceClass() { return (avmplus::TraceClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_trace_Trace)); }
    REALLY_INLINE GCRef<avmplus::TriangleCullingClass> get_TriangleCullingClass() { return (avmplus::TriangleCullingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_TriangleCulling)); }
    REALLY_INLINE GCRef<avmplus::URLRequestHeaderClass> get_URLRequestHeaderClass() { return (avmplus::URLRequestHeaderClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_URLRequestHeader)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerClass> get_WorkerClass() { return (avmshell::ShellWorkerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Worker)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerDomainClass> get_WorkerDomainClass() { return (avmshell::ShellWorkerDomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerDomain)); }
    REALLY_INLINE GCRef<avmplus::WorkerEventClass> get_WorkerEventClass() { return (avmplus::WorkerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerEvent)); }
    REALLY_INLINE GCRef<avmplus::WorkerStateClass> get_WorkerStateClass() { return (avmplus::WorkerStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerState)); }
    REALLY_INLINE GCRef<avmshell::CTypeClass> get___ctypeClass() { return (avmshell::CTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_ctype___ctype)); }
    REALLY_INLINE GCRef<avmshell::CErrnoClass> get___errnoClass() { return (avmshell::CErrnoClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno___errno)); }
    REALLY_INLINE GCRef<avmshell::CFcntlClass> get___fcntlClass() { return (avmshell::CFcntlClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_fcntl___fcntl)); }
    REALLY_INLINE GCRef<avmshell::CLimitsClass> get___limitsClass() { return (avmshell::CLimitsClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_limits___limits)); }
    REALLY_INLINE GCRef<avmshell::CLocaleClass> get___localeClass() { return (avmshell::CLocaleClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_locale___locale)); }
    REALLY_INLINE GCRef<avmshell::CNetdbClass> get___netdbClass() { return (avmshell::CNetdbClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb___netdb)); }
    REALLY_INLINE GCRef<avmshell::CNetinetInClass> get___netinetClass() { return (avmshell::CNetinetInClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet___netinet)); }
    REALLY_INLINE GCRef<avmshell::CSignalClass> get___signalClass() { return (avmshell::CSignalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal___signal)); }
    REALLY_INLINE GCRef<avmshell::CSysSocketClass> get___socketClass() { return (avmshell::CSysSocketClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket___socket)); }
    REALLY_INLINE GCRef<avmshell::CSysStatClass> get___statClass() { return (avmshell::CSysStatClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat___stat)); }
    REALLY_INLINE GCRef<avmshell::CStdioClass> get___stdioClass() { return (avmshell::CStdioClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio___stdio)); }
    REALLY_INLINE GCRef<avmshell::CStdlibClass> get___stdlibClass() { return (avmshell::CStdlibClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib___stdlib)); }
    REALLY_INLINE GCRef<avmshell::CTimeClass> get___timeClass() { return (avmshell::CTimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time___time)); }
    REALLY_INLINE GCRef<avmshell::CUnistdClass> get___unistdClass() { return (avmshell::CUnistdClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_unistd___unistd)); }
    REALLY_INLINE GCRef<avmshell::CSysWaitClass> get___waitClass() { return (avmshell::CSysWaitClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait___wait)); }
    REALLY_INLINE GCRef<avmplus::addrinfoClass> get_addrinfoClass() { return (avmplus::addrinfoClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_addrinfo)); }
    REALLY_INLINE GCRef<avmshell::CdirentClass> get_direntClass() { return (avmshell::CdirentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_dirent_dirent)); }
    REALLY_INLINE GCRef<avmshell::Cdiv_tClass> get_div_tClass() { return (avmshell::Cdiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_div_t)); }
    REALLY_INLINE GCRef<avmshell::Cfpos_tClass> get_fpos_tClass() { return (avmshell::Cfpos_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_fpos_t)); }
    REALLY_INLINE GCRef<avmshell::ChostentClass> get_hostentClass() { return (avmshell::ChostentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_hostent)); }
    REALLY_INLINE GCRef<avmplus::in6_addrClass> get_in6_addrClass() { return (avmplus::in6_addrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in6_addr)); }
    REALLY_INLINE GCRef<avmplus::in_addrClass> get_in_addrClass() { return (avmplus::in_addrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in_addr)); }
    REALLY_INLINE GCRef<avmplus::ipv6_mreqClass> get_ipv6_mreqClass() { return (avmplus::ipv6_mreqClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_ipv6_mreq)); }
    REALLY_INLINE GCRef<avmshell::Cldiv_tClass> get_ldiv_tClass() { return (avmshell::Cldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_ldiv_t)); }
    REALLY_INLINE GCRef<avmshell::Clldiv_tClass> get_lldiv_tClass() { return (avmshell::Clldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_lldiv_t)); }
    REALLY_INLINE GCRef<avmplus::msghdrClass> get_msghdrClass() { return (avmplus::msghdrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_msghdr)); }
    REALLY_INLINE GCRef<avmplus::netentClass> get_netentClass() { return (avmplus::netentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_netent)); }
    REALLY_INLINE GCRef<avmshell::Cpid_tClass> get_pid_tClass() { return (avmshell::Cpid_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_spawn_pid_t)); }
    REALLY_INLINE GCRef<avmshell::CprotoentClass> get_protoentClass() { return (avmshell::CprotoentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_protoent)); }
    REALLY_INLINE GCRef<avmplus::serventClass> get_serventClass() { return (avmplus::serventClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_servent)); }
    REALLY_INLINE GCRef<avmshell::Csiginfo_tClass> get_siginfo_tClass() { return (avmshell::Csiginfo_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_siginfo_t)); }
    REALLY_INLINE GCRef<avmshell::CsigvalClass> get_sigvalClass() { return (avmshell::CsigvalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_sigval)); }
    REALLY_INLINE GCRef<avmplus::sockaddrClass> get_sockaddrClass() { return (avmplus::sockaddrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_in6Class> get_sockaddr_in6Class() { return (avmplus::sockaddr_in6Class*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in6)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_inClass> get_sockaddr_inClass() { return (avmplus::sockaddr_inClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_storageClass> get_sockaddr_storageClass() { return (avmplus::sockaddr_storageClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr_storage)); }
    REALLY_INLINE GCRef<avmplus::sockdClass> get_sockdClass() { return (avmplus::sockdClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockd)); }
    REALLY_INLINE GCRef<avmshell::CStatusClass> get_statusClass() { return (avmshell::CStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat_status)); }
    REALLY_INLINE GCRef<avmshell::CWaitStatusClass> get_wait_statusClass() { return (avmshell::CWaitStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait_wait_status)); }
};
}
#endif // _H_nativegen_header_shell_toplevel
