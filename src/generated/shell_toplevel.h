/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* machine generated file -- do not edit */

#ifndef _H_nativegen_header_shell_toplevel
#define _H_nativegen_header_shell_toplevel

namespace avmplus {
    class AccessibilityClass; // flash.accessibility::Accessibility$
    class AccessibilityImplementationClass; // flash.accessibility::AccessibilityImplementation$
    class AccessibilityImplementationObject; // flash.accessibility::AccessibilityImplementation
    class AccessibilityObject; // flash.accessibility::Accessibility
    class AccessibilityPropertiesClass; // flash.accessibility::AccessibilityProperties$
    class AccessibilityPropertiesObject; // flash.accessibility::AccessibilityProperties
    class ActionScriptVersionClass; // flash.display::ActionScriptVersion$
    class ActionScriptVersionObject; // flash.display::ActionScriptVersion
    class ArrayObject; // Array
    class BinaryDataClass; // shell::BinaryData$
    class BinaryDataObject; // shell::BinaryData
    class ByteArrayObject; // flash.utils::ByteArray
    class CErrorClass; // C.errno::CError$
    class CErrorObject; // C.errno::CError
    class CapabilitiesClass; // flash.system::Capabilities$
    class CapabilitiesObject; // flash.system::Capabilities
    class ClassClosure; // Class
    class ClassFactoryClass; // flash.sampler::ClassFactory$
    class ClassFactoryObject; // flash.sampler::ClassFactory
    class CoreEventLoopClass; // shell.async::CoreEventLoop$
    class CoreEventLoopObject; // shell.async::CoreEventLoop
    class DRMManagerErrorClass; // flash.errors::DRMManagerError$
    class DRMManagerErrorObject; // flash.errors::DRMManagerError
    class DeleteObjectSampleClass; // flash.sampler::DeleteObjectSample$
    class DeleteObjectSampleObject; // flash.sampler::DeleteObjectSample
    class DiagnosticsObject; // shell::Diagnostics
    class DomainClass; // shell::Domain$
    class DomainObject; // shell::Domain
    class EncryptedLocalStoreClass; // flash.data::EncryptedLocalStore$
    class EncryptedLocalStoreObject; // flash.data::EncryptedLocalStore
    class EndianClass; // flash.utils::Endian$
    class EndianObject; // flash.utils::Endian
    class EnvironmentClass; // shell::Environment$
    class EnvironmentObject; // shell::Environment
    class ErrorNumberClass; // C.errno::ErrorNumber$
    class ErrorNumberObject; // C.errno::ErrorNumber
    class EventClass; // flash.events::Event$
    class EventDispatcherClass; // flash.events::EventDispatcher$
    class EventDispatcherObject; // flash.events::EventDispatcher
    class EventLoopClass; // shell.async::EventLoop$
    class EventLoopInterface; // shell.async::EventLoop
    class EventObject; // flash.events::Event
    class FileIOObject; // shell::FileIO
    class FunctionObject; // Function
    class HTTPStatusEventClass; // flash.events::HTTPStatusEvent$
    class HTTPStatusEventObject; // flash.events::HTTPStatusEvent
    class HardwareInformationObject; // shell::HardwareInformation
    class IBitmapDrawableClass; // flash.display::IBitmapDrawable$
    class IBitmapDrawableInterface; // flash.display::IBitmapDrawable
    class IDrawCommandClass; // flash.display::IDrawCommand$
    class IDrawCommandInterface; // flash.display::IDrawCommand
    class IEventDispatcherClass; // flash.events::IEventDispatcher$
    class IEventDispatcherInterface; // flash.events::IEventDispatcher
    class IGraphicsDataClass; // flash.display::IGraphicsData$
    class IGraphicsDataInterface; // flash.display::IGraphicsData
    class IGraphicsFillClass; // flash.display::IGraphicsFill$
    class IGraphicsFillInterface; // flash.display::IGraphicsFill
    class IGraphicsPathClass; // flash.display::IGraphicsPath$
    class IGraphicsPathInterface; // flash.display::IGraphicsPath
    class IGraphicsStrokeClass; // flash.display::IGraphicsStroke$
    class IGraphicsStrokeInterface; // flash.display::IGraphicsStroke
    class ISearchableTextClass; // flash.accessibility::ISearchableText$
    class ISearchableTextInterface; // flash.accessibility::ISearchableText
    class ISimpleTextSelectionClass; // flash.accessibility::ISimpleTextSelection$
    class ISimpleTextSelectionInterface; // flash.accessibility::ISimpleTextSelection
    class InvalidSWFErrorClass; // flash.errors::InvalidSWFError$
    class InvalidSWFErrorObject; // flash.errors::InvalidSWFError
    class NewObjectSampleClass; // flash.sampler::NewObjectSample$
    class NewObjectSampleObject; // flash.sampler::NewObjectSample
    class OperatingSystemObject; // shell::OperatingSystem
    class Orientation3DClass; // flash.geom::Orientation3D$
    class Orientation3DObject; // flash.geom::Orientation3D
    class PNGEncoderOptionsClass; // flash.display::PNGEncoderOptions$
    class PNGEncoderOptionsObject; // flash.display::PNGEncoderOptions
    class PixelSnappingClass; // flash.display::PixelSnapping$
    class PixelSnappingObject; // flash.display::PixelSnapping
    class PointClass; // flash.geom::Point$
    class PointObject; // flash.geom::Point
    class ProgramObject; // shell::Program
    class RectangleClass; // flash.geom::Rectangle$
    class RectangleObject; // flash.geom::Rectangle
    class RunModeClass; // shell::RunMode$
    class RunModeObject; // shell::RunMode
    class RuntimeObject; // shell::Runtime
    class SQLCollationTypeClass; // flash.data::SQLCollationType$
    class SQLCollationTypeObject; // flash.data::SQLCollationType
    class SQLColumnNameStyleClass; // flash.data::SQLColumnNameStyle$
    class SQLColumnNameStyleObject; // flash.data::SQLColumnNameStyle
    class SQLColumnSchemaClass; // flash.data::SQLColumnSchema$
    class SQLColumnSchemaObject; // flash.data::SQLColumnSchema
    class SQLConnectionClass; // flash.data::SQLConnection$
    class SQLConnectionObject; // flash.data::SQLConnection
    class SQLErrorClass; // flash.errors::SQLError$
    class SQLErrorObject; // flash.errors::SQLError
    class SQLErrorOperationClass; // flash.errors::SQLErrorOperation$
    class SQLErrorOperationObject; // flash.errors::SQLErrorOperation
    class SQLIndexSchemaClass; // flash.data::SQLIndexSchema$
    class SQLIndexSchemaObject; // flash.data::SQLIndexSchema
    class SQLModeClass; // flash.data::SQLMode$
    class SQLModeObject; // flash.data::SQLMode
    class SQLResultClass; // flash.data::SQLResult$
    class SQLResultObject; // flash.data::SQLResult
    class SQLSchemaClass; // flash.data::SQLSchema$
    class SQLSchemaObject; // flash.data::SQLSchema
    class SQLSchemaResultClass; // flash.data::SQLSchemaResult$
    class SQLSchemaResultObject; // flash.data::SQLSchemaResult
    class SQLStatementClass; // flash.data::SQLStatement$
    class SQLStatementObject; // flash.data::SQLStatement
    class SQLTableSchemaClass; // flash.data::SQLTableSchema$
    class SQLTableSchemaObject; // flash.data::SQLTableSchema
    class SQLTransactionLockTypeClass; // flash.data::SQLTransactionLockType$
    class SQLTransactionLockTypeObject; // flash.data::SQLTransactionLockType
    class SQLTriggerSchemaClass; // flash.data::SQLTriggerSchema$
    class SQLTriggerSchemaObject; // flash.data::SQLTriggerSchema
    class SQLViewSchemaClass; // flash.data::SQLViewSchema$
    class SQLViewSchemaObject; // flash.data::SQLViewSchema
    class SWFVersionClass; // flash.display::SWFVersion$
    class SWFVersionObject; // flash.display::SWFVersion
    class SampleClass; // flash.sampler::Sample$
    class SampleObject; // flash.sampler::Sample
    class SceneClass; // flash.display::Scene$
    class SceneObject; // flash.display::Scene
    class ScriptTimeoutErrorClass; // flash.errors::ScriptTimeoutError$
    class ScriptTimeoutErrorObject; // flash.errors::ScriptTimeoutError
    class StackFrameClass; // flash.sampler::StackFrame$
    class StackFrameObject; // flash.sampler::StackFrame
    class StackOverflowErrorClass; // flash.errors::StackOverflowError$
    class StackOverflowErrorObject; // flash.errors::StackOverflowError
    class StageAlignClass; // flash.display::StageAlign$
    class StageAlignObject; // flash.display::StageAlign
    class StageAspectRatioClass; // flash.display::StageAspectRatio$
    class StageAspectRatioObject; // flash.display::StageAspectRatio
    class StageDisplayStateClass; // flash.display::StageDisplayState$
    class StageDisplayStateObject; // flash.display::StageDisplayState
    class StageOrientationClass; // flash.display::StageOrientation$
    class StageOrientationObject; // flash.display::StageOrientation
    class StageQualityClass; // flash.display::StageQuality$
    class StageQualityObject; // flash.display::StageQuality
    class StageScaleModeClass; // flash.display::StageScaleMode$
    class StageScaleModeObject; // flash.display::StageScaleMode
    class String; // String
    class SystemObject; // flash.system::System
    class TimerClass; // flash.utils::Timer$
    class TimerEventClass; // flash.events::TimerEvent$
    class TimerEventObject; // flash.events::TimerEvent
    class TimerObject; // flash.utils::Timer
    class TraceClass; // flash.trace::Trace$
    class TraceObject; // flash.trace::Trace
    class TriangleCullingClass; // flash.display::TriangleCulling$
    class TriangleCullingObject; // flash.display::TriangleCulling
    class UIntVectorObject; // __AS3__.vec::Vector$uint
    class URLRequestHeaderClass; // flash.net::URLRequestHeader$
    class URLRequestHeaderObject; // flash.net::URLRequestHeader
    class WorkerEventClass; // flash.system::WorkerEvent$
    class WorkerEventObject; // flash.system::WorkerEvent
    class WorkerStateClass; // flash.system::WorkerState$
    class WorkerStateObject; // flash.system::WorkerState
    class __fcntlObject; // C.fcntl::__fcntl
    class __limitsObject; // C.limits::__limits
    class __localeObject; // C.locale::__locale
    class __netdbObject; // C.netdb::__netdb
    class __netinetObject; // C.netinet::__netinet
    class __signalObject; // C.signal::__signal
    class __socketObject; // C.sys.socket::__socket
    class __statObject; // C.sys.stat::__stat
    class __stdioObject; // C.stdio::__stdio
    class __stdlibObject; // C.stdlib::__stdlib
    class __timeObject; // C.time::__time
    class __unistdObject; // C.unistd::__unistd
    class __waitObject; // C.sys.wait::__wait
    class addrinfoClass; // C.netdb::addrinfo$
    class addrinfoObject; // C.netdb::addrinfo
    class in6_addrClass; // C.netinet::in6_addr$
    class in6_addrObject; // C.netinet::in6_addr
    class in_addrClass; // C.netinet::in_addr$
    class in_addrObject; // C.netinet::in_addr
    class ipv6_mreqClass; // C.netinet::ipv6_mreq$
    class ipv6_mreqObject; // C.netinet::ipv6_mreq
    class msghdrClass; // C.sys.socket::msghdr$
    class msghdrObject; // C.sys.socket::msghdr
    class netentClass; // C.netdb::netent$
    class netentObject; // C.netdb::netent
    class serventClass; // C.netdb::servent$
    class serventObject; // C.netdb::servent
    class sockaddrClass; // C.sys.socket::sockaddr$
    class sockaddrObject; // C.sys.socket::sockaddr
    class sockaddr_in6Class; // C.netinet::sockaddr_in6$
    class sockaddr_in6Object; // C.netinet::sockaddr_in6
    class sockaddr_inClass; // C.netinet::sockaddr_in$
    class sockaddr_inObject; // C.netinet::sockaddr_in
    class sockaddr_storageClass; // C.sys.socket::sockaddr_storage$
    class sockaddr_storageObject; // C.sys.socket::sockaddr_storage
    class sockdClass; // C.sys.socket::sockd$
    class sockdObject; // C.sys.socket::sockd
}

namespace avmshell {
    class CFILEClass; // C.stdio::FILE$
    class CFILEObject; // C.stdio::FILE
    class CFcntlClass; // C.fcntl::__fcntl$
    class CLimitsClass; // C.limits::__limits$
    class CLocaleClass; // C.locale::__locale$
    class CNetdbClass; // C.netdb::__netdb$
    class CNetinetInClass; // C.netinet::__netinet$
    class CSignalClass; // C.signal::__signal$
    class CStatusClass; // C.sys.stat::status$
    class CStatusObject; // C.sys.stat::status
    class CStdioClass; // C.stdio::__stdio$
    class CStdlibClass; // C.stdlib::__stdlib$
    class CSysSocketClass; // C.sys.socket::__socket$
    class CSysStatClass; // C.sys.stat::__stat$
    class CSysWaitClass; // C.sys.wait::__wait$
    class CTimeClass; // C.time::__time$
    class CUnistdClass; // C.unistd::__unistd$
    class CWaitStatusClass; // C.sys.wait::wait_status$
    class CWaitStatusObject; // C.sys.wait::wait_status
    class Cdiv_tClass; // C.stdlib::div_t$
    class Cdiv_tObject; // C.stdlib::div_t
    class Cfpos_tClass; // C.stdio::fpos_t$
    class Cfpos_tObject; // C.stdio::fpos_t
    class ChostentClass; // C.netdb::hostent$
    class ChostentObject; // C.netdb::hostent
    class Cldiv_tClass; // C.stdlib::ldiv_t$
    class Cldiv_tObject; // C.stdlib::ldiv_t
    class Clldiv_tClass; // C.stdlib::lldiv_t$
    class Clldiv_tObject; // C.stdlib::lldiv_t
    class Cpid_tClass; // C.spawn::pid_t$
    class Cpid_tObject; // C.spawn::pid_t
    class CprotoentClass; // C.netdb::protoent$
    class CprotoentObject; // C.netdb::protoent
    class Csiginfo_tClass; // C.signal::siginfo_t$
    class Csiginfo_tObject; // C.signal::siginfo_t
    class CsigvalClass; // C.signal::sigval$
    class CsigvalObject; // C.signal::sigval
    class DiagnosticsClass; // shell::Diagnostics$
    class FileClass; // shell::FileIO$
    class HardwareInformationClass; // shell::HardwareInformation$
    class OperatingSystemClass; // shell::OperatingSystem$
    class ProgramClass; // shell::Program$
    class RuntimeClass; // shell::Runtime$
    class ShellWorkerClass; // flash.system::Worker$
    class ShellWorkerDomainClass; // flash.system::WorkerDomain$
    class ShellWorkerDomainObject; // flash.system::WorkerDomain
    class ShellWorkerObject; // flash.system::Worker
    class SystemClass; // flash.system::System$
}

namespace avmplus { namespace NativeID {

extern const uint32_t shell_toplevel_abc_class_count;
extern const uint32_t shell_toplevel_abc_script_count;
extern const uint32_t shell_toplevel_abc_method_count;
extern const uint32_t shell_toplevel_abc_length;
extern const uint8_t shell_toplevel_abc_data[];
extern const char* const shell_toplevel_versioned_uris[];
AVMTHUNK_DECLARE_NATIVE_INITIALIZER(shell_toplevel)

/* classes */
const uint32_t abcclass_C_errno_ErrorNumber = 0;
const uint32_t abcclass_C_errno_CError = 1;
const uint32_t abcclass_C_limits___limits = 2;
const uint32_t abcclass_C_locale___locale = 3;
const uint32_t abcclass_C_signal___signal = 4;
const uint32_t abcclass_C_signal_sigval = 5;
const uint32_t abcclass_C_signal_siginfo_t = 6;
const uint32_t abcclass_C_stdio___stdio = 7;
const uint32_t abcclass_C_stdio_FILE = 8;
const uint32_t abcclass_C_stdio_fpos_t = 9;
const uint32_t abcclass_C_stdlib___stdlib = 10;
const uint32_t abcclass_C_stdlib_div_t = 11;
const uint32_t abcclass_C_stdlib_ldiv_t = 12;
const uint32_t abcclass_C_stdlib_lldiv_t = 13;
const uint32_t abcclass_C_time___time = 14;
const uint32_t abcclass_C_fcntl___fcntl = 15;
const uint32_t abcclass_C_netdb___netdb = 16;
const uint32_t abcclass_C_netdb_hostent = 17;
const uint32_t abcclass_C_netdb_netent = 18;
const uint32_t abcclass_C_netdb_protoent = 19;
const uint32_t abcclass_C_netdb_servent = 20;
const uint32_t abcclass_C_netdb_addrinfo = 21;
const uint32_t abcclass_C_netinet___netinet = 22;
const uint32_t abcclass_C_netinet_in_addr = 23;
const uint32_t abcclass_C_netinet_sockaddr_in = 24;
const uint32_t abcclass_C_netinet_in6_addr = 25;
const uint32_t abcclass_C_netinet_sockaddr_in6 = 26;
const uint32_t abcclass_C_netinet_ipv6_mreq = 27;
const uint32_t abcclass_C_spawn_pid_t = 28;
const uint32_t abcclass_C_sys_socket___socket = 29;
const uint32_t abcclass_C_sys_socket_sockd = 30;
const uint32_t abcclass_C_sys_socket_sockaddr = 31;
const uint32_t abcclass_C_sys_socket_sockaddr_storage = 32;
const uint32_t abcclass_C_sys_socket_msghdr = 33;
const uint32_t abcclass_C_sys_stat___stat = 34;
const uint32_t abcclass_C_sys_stat_status = 35;
const uint32_t abcclass_C_sys_wait___wait = 36;
const uint32_t abcclass_C_sys_wait_wait_status = 37;
const uint32_t abcclass_C_unistd___unistd = 38;
const uint32_t abcclass_shell_Program = 39;
const uint32_t abcclass_shell_Runtime = 40;
const uint32_t abcclass_shell_Diagnostics = 41;
const uint32_t abcclass_shell_HardwareInformation = 42;
const uint32_t abcclass_shell_OperatingSystem = 43;
const uint32_t abcclass_shell_RunMode = 44;
const uint32_t abcclass_shell_Domain = 45;
const uint32_t abcclass_shell_FileIO = 46;
const uint32_t abcclass_shell_Environment = 47;
const uint32_t abcclass_shell_BinaryData = 48;
const uint32_t abcclass_shell_async_EventLoop = 49;
const uint32_t abcclass_flash_accessibility_ISearchableText = 50;
const uint32_t abcclass_flash_accessibility_ISimpleTextSelection = 51;
const uint32_t abcclass_flash_accessibility_Accessibility = 52;
const uint32_t abcclass_flash_accessibility_AccessibilityImplementation = 53;
const uint32_t abcclass_flash_accessibility_AccessibilityProperties = 54;
const uint32_t abcclass_flash_data_EncryptedLocalStore = 55;
const uint32_t abcclass_flash_data_SQLCollationType = 56;
const uint32_t abcclass_flash_data_SQLColumnNameStyle = 57;
const uint32_t abcclass_flash_data_SQLColumnSchema = 58;
const uint32_t abcclass_flash_data_SQLConnection = 59;
const uint32_t abcclass_flash_data_SQLIndexSchema = 60;
const uint32_t abcclass_flash_data_SQLMode = 61;
const uint32_t abcclass_flash_data_SQLResult = 62;
const uint32_t abcclass_flash_data_SQLSchema = 63;
const uint32_t abcclass_flash_data_SQLSchemaResult = 64;
const uint32_t abcclass_flash_data_SQLStatement = 65;
const uint32_t abcclass_flash_data_SQLTableSchema = 66;
const uint32_t abcclass_flash_data_SQLTransactionLockType = 67;
const uint32_t abcclass_flash_data_SQLTriggerSchema = 68;
const uint32_t abcclass_flash_data_SQLViewSchema = 69;
const uint32_t abcclass_flash_display_IBitmapDrawable = 70;
const uint32_t abcclass_flash_display_IDrawCommand = 71;
const uint32_t abcclass_flash_display_IGraphicsData = 72;
const uint32_t abcclass_flash_display_IGraphicsFill = 73;
const uint32_t abcclass_flash_display_IGraphicsPath = 74;
const uint32_t abcclass_flash_display_IGraphicsStroke = 75;
const uint32_t abcclass_flash_display_ActionScriptVersion = 76;
const uint32_t abcclass_flash_display_PixelSnapping = 77;
const uint32_t abcclass_flash_display_PNGEncoderOptions = 78;
const uint32_t abcclass_flash_display_Scene = 79;
const uint32_t abcclass_flash_display_StageAlign = 80;
const uint32_t abcclass_flash_display_StageAspectRatio = 81;
const uint32_t abcclass_flash_display_StageDisplayState = 82;
const uint32_t abcclass_flash_display_StageOrientation = 83;
const uint32_t abcclass_flash_display_StageQuality = 84;
const uint32_t abcclass_flash_display_StageScaleMode = 85;
const uint32_t abcclass_flash_display_SWFVersion = 86;
const uint32_t abcclass_flash_display_TriangleCulling = 87;
const uint32_t abcclass_flash_errors_ScriptTimeoutError = 88;
const uint32_t abcclass_flash_errors_StackOverflowError = 89;
const uint32_t abcclass_flash_errors_InvalidSWFError = 90;
const uint32_t abcclass_flash_errors_SQLErrorOperation = 91;
const uint32_t abcclass_flash_errors_SQLError = 92;
const uint32_t abcclass_flash_errors_DRMManagerError = 93;
const uint32_t abcclass_flash_events_IEventDispatcher = 94;
const uint32_t abcclass_flash_events_Event = 95;
const uint32_t abcclass_flash_geom_Orientation3D = 96;
const uint32_t abcclass_flash_geom_Point = 97;
const uint32_t abcclass_flash_geom_Rectangle = 98;
const uint32_t abcclass_flash_net_URLRequestHeader = 99;
const uint32_t abcclass_flash_sampler_StackFrame = 100;
const uint32_t abcclass_flash_sampler_Sample = 101;
const uint32_t abcclass_flash_sampler_ClassFactory = 102;
const uint32_t abcclass_flash_system_Capabilities = 103;
const uint32_t abcclass_flash_system_System = 104;
const uint32_t abcclass_flash_system_WorkerState = 105;
const uint32_t abcclass_flash_system_Worker = 106;
const uint32_t abcclass_flash_system_WorkerEvent = 107;
const uint32_t abcclass_flash_system_WorkerDomain = 108;
const uint32_t abcclass_flash_trace_Trace = 109;
const uint32_t abcclass_flash_utils_Endian = 110;
const uint32_t abcclass_shell_async_CoreEventLoop = 111;
const uint32_t abcclass_flash_events_EventDispatcher = 112;
const uint32_t abcclass_flash_events_HTTPStatusEvent = 113;
const uint32_t abcclass_flash_events_TimerEvent = 114;
const uint32_t abcclass_flash_sampler_NewObjectSample = 115;
const uint32_t abcclass_flash_sampler_DeleteObjectSample = 116;
const uint32_t abcclass_flash_utils_Timer = 117;

/* methods */
const uint32_t native_script_function_flash_sampler_getMasterString = 14; // native
const uint32_t native_script_function_flash_sampler_getSavedThis = 15; // native
const uint32_t native_script_function_flash_sampler_getLexicalScopes = 16; // native
const uint32_t native_script_function_flash_sampler_isGetterSetter = 17; // native
const uint32_t native_script_function_flash_sampler__getInvocationCount = 18; // native
const uint32_t native_script_function_flash_sampler_getSampleCount = 22; // native
const uint32_t native_script_function_flash_sampler__getSamples = 23; // native
const uint32_t native_script_function_flash_sampler_getMemberNames = 25; // native
const uint32_t native_script_function_flash_sampler_getSize = 26; // native
const uint32_t native_script_function_flash_sampler__setSamplerCallback = 27; // native
const uint32_t native_script_function_flash_sampler_sampleInternalAllocs = 30; // native
const uint32_t native_script_function_flash_sampler_pauseSampling = 31; // native
const uint32_t native_script_function_flash_sampler_stopSampling = 32; // native
const uint32_t native_script_function_flash_sampler_startSampling = 33; // native
const uint32_t native_script_function_flash_sampler_clearSamples = 34; // native
const uint32_t native_script_function_C_unistd_ftruncate = 50; // native
const uint32_t native_script_function_C_unistd_fsync = 51; // native
const uint32_t native_script_function_C_unistd_execvp = 52; // native
const uint32_t native_script_function_C_unistd_execve = 53; // native
const uint32_t native_script_function_C_unistd_execv = 54; // native
const uint32_t native_script_function_C_unistd_execlp = 55; // native
const uint32_t native_script_function_C_unistd_execle = 56; // native
const uint32_t native_script_function_C_unistd_execl = 57; // native
const uint32_t native_script_function_C_unistd_dup2 = 58; // native
const uint32_t native_script_function_C_unistd_dup = 59; // native
const uint32_t native_script_function_C_unistd_close = 60; // native
const uint32_t native_script_function_C_unistd_chdir = 61; // native
const uint32_t native_script_function_C_unistd_access = 62; // native
const uint32_t native_script_function_C_sys_wait_waitpid = 63; // native
const uint32_t native_script_function_C_sys_wait_waitid = 64; // native
const uint32_t native_script_function_C_sys_wait_wait = 65; // native
const uint32_t native_script_function_C_sys_stat_umask = 73; // native
const uint32_t native_script_function_C_sys_stat_stat = 74; // native
const uint32_t native_script_function_C_sys_stat_fstat = 77; // native
const uint32_t native_script_function_C_sys_stat_chmod = 78; // native
const uint32_t native_script_function_C_spawn_spawnp = 86; // native
const uint32_t native_script_function_C_spawn_spawn = 87; // native
const uint32_t native_script_function_C_netdb_gethostent = 88; // native
const uint32_t native_script_function_C_netdb_getprotoent = 89; // native
const uint32_t native_script_function_C_netdb_getprotobynumber = 90; // native
const uint32_t native_script_function_C_conio_kbhit = 91; // native
const uint32_t native_script_function_C_conio_echo = 92; // native
const uint32_t native_script_function_C_conio_canonical = 93; // native
const uint32_t native_script_function_C_string_strspn = 97; // native
const uint32_t native_script_function_C_string_strerror = 106; // native
const uint32_t native_script_function_C_string_strcoll = 107; // native
const uint32_t native_script_function_C_string_strcmp = 108; // native
const uint32_t native_script_function_C_stdlib_unsetenv = 111; // native
const uint32_t native_script_function_C_stdlib_system = 112; // native
const uint32_t native_script_function_C_stdlib_srand = 120; // native
const uint32_t native_script_function_C_stdlib_setenv = 121; // native
const uint32_t native_script_function_C_stdlib_realpath = 122; // native
const uint32_t native_script_function_C_stdlib_rand = 123; // native
const uint32_t native_script_function_C_stdlib_putenv = 124; // native
const uint32_t native_script_function_C_stdlib_mkstemp = 125; // native
const uint32_t native_script_function_C_stdlib_mkdtemp = 126; // native
const uint32_t native_script_function_C_stdlib_mblen = 127; // native
const uint32_t native_script_function_C_stdlib_lldiv = 129; // native
const uint32_t native_script_function_C_stdlib_ldiv = 130; // native
const uint32_t native_script_function_C_stdlib_getenv = 132; // native
const uint32_t native_script_function_C_stdlib_div = 134; // native
const uint32_t native_script_function_C_stdlib_atol = 136; // native
const uint32_t native_script_function_C_stdlib_atoi = 137; // native
const uint32_t native_script_function_C_stdlib_atof = 138; // native
const uint32_t native_script_function_C_stdio_rewind = 144; // native
const uint32_t native_script_function_C_stdio_rename = 145; // native
const uint32_t native_script_function_C_stdio_popen = 147; // native
const uint32_t native_script_function_C_stdio_perror = 148; // native
const uint32_t native_script_function_C_stdio_pclose = 149; // native
const uint32_t native_script_function_C_stdio_getchar = 152; // native
const uint32_t native_script_function_C_stdio_getc = 153; // native
const uint32_t native_script_function_C_stdio_fwrite = 154; // native
const uint32_t native_script_function_C_stdio_funlockfile = 155; // native
const uint32_t native_script_function_C_stdio_ftrylockfile = 156; // native
const uint32_t native_script_function_C_stdio_ftell = 157; // native
const uint32_t native_script_function_C_stdio_fsetpos = 158; // native
const uint32_t native_script_function_C_stdio_fseek = 159; // native
const uint32_t native_script_function_C_stdio_freopen = 160; // native
const uint32_t native_script_function_C_stdio_fread = 161; // native
const uint32_t native_script_function_C_stdio_fputs = 162; // native
const uint32_t native_script_function_C_stdio_fputc = 163; // native
const uint32_t native_script_function_C_stdio_fopen = 164; // native
const uint32_t native_script_function_C_stdio_flockfile = 165; // native
const uint32_t native_script_function_C_stdio_fileno = 166; // native
const uint32_t native_script_function_C_stdio_fgets = 167; // native
const uint32_t native_script_function_C_stdio_fgetpos = 168; // native
const uint32_t native_script_function_C_stdio_fgetc = 169; // native
const uint32_t native_script_function_C_stdio_fflush = 170; // native
const uint32_t native_script_function_C_stdio_ferror = 171; // native
const uint32_t native_script_function_C_stdio_feof = 172; // native
const uint32_t native_script_function_C_stdio_fdopen = 173; // native
const uint32_t native_script_function_C_stdio_fclose = 174; // native
const uint32_t native_script_function_C_stdio_clearerr = 175; // native
const uint32_t native_script_function_C_signal_kill = 176; // native
const uint32_t native_script_function_C_errno__SetErrno = 179; // native
const uint32_t native_script_function_C_errno__GetErrno = 180; // native
const uint32_t native_script_function_C_ctype_toupper = 181; // native
const uint32_t native_script_function_C_ctype_tolower = 182; // native
const uint32_t native_script_function_C_ctype_toascii = 183; // native
const uint32_t native_script_function_C_ctype_isxdigit = 184; // native
const uint32_t native_script_function_C_ctype_isupper = 185; // native
const uint32_t native_script_function_C_ctype_isspace = 186; // native
const uint32_t native_script_function_C_ctype_ispunct = 187; // native
const uint32_t native_script_function_C_ctype_isprint = 188; // native
const uint32_t native_script_function_C_ctype_islower = 189; // native
const uint32_t native_script_function_C_ctype_isgraph = 190; // native
const uint32_t native_script_function_C_ctype_isdigit = 191; // native
const uint32_t native_script_function_C_ctype_iscntrl = 192; // native
const uint32_t native_script_function_C_ctype_isblank = 193; // native
const uint32_t native_script_function_C_ctype_isascii = 194; // native
const uint32_t native_script_function_C_ctype_isalpha = 195; // native
const uint32_t native_script_function_C_ctype_isalnum = 196; // native
const uint32_t native_script_function_C_assert__debugBreak = 198; // native
const uint32_t C_errno_ErrorNumber_value_get = 201; // abc
const uint32_t C_errno_ErrorNumber_value_set = 202; // abc
const uint32_t C_errno_ErrorNumber_valueOf = 203; // abc
const uint32_t C_errno_ErrorNumber_toString = 204; // abc
const uint32_t C_limits___limits_PATH_MAX_get = 208; // native
const uint32_t C_locale___locale_LC_ALL_get = 211; // native
const uint32_t C_signal___signal_SIGEV_NONE_get = 214; // native
const uint32_t C_signal___signal_SIGEV_SIGNAL_get = 215; // native
const uint32_t C_signal___signal_SIGEV_THREAD_get = 216; // native
const uint32_t C_stdio___stdio_BUFSIZ_get = 223; // native
const uint32_t C_stdio___stdio__IOFBF_get = 224; // native
const uint32_t C_stdio___stdio__IOLBF_get = 225; // native
const uint32_t C_stdio___stdio__IONBF_get = 226; // native
const uint32_t C_stdio___stdio_SEEK_CUR_get = 227; // native
const uint32_t C_stdio___stdio_SEEK_END_get = 228; // native
const uint32_t C_stdio___stdio_SEEK_SET_get = 229; // native
const uint32_t C_stdio___stdio_FILENAME_MAX_get = 230; // native
const uint32_t C_stdio___stdio_FOPEN_MAX_get = 231; // native
const uint32_t C_stdio___stdio_TMP_MAX_get = 232; // native
const uint32_t C_stdio___stdio_EOF_get = 233; // native
const uint32_t C_stdio___stdio_stdin_get = 234; // native
const uint32_t C_stdio___stdio_stdout_get = 235; // native
const uint32_t C_stdio___stdio_stderr_get = 236; // native
const uint32_t C_stdio___stdio__getc_unlocked = 237; // native
const uint32_t C_stdio___stdio__getchar_unlocked = 238; // native
const uint32_t C_stdio___stdio_PATH_MAX_get = 239; // native
const uint32_t C_stdio___stdio_NONBLOCKING_DISABLE_get = 240; // native
const uint32_t C_stdio___stdio_NONBLOCKING_ENABLE_get = 241; // native
const uint32_t C_stdio___stdio_remove = 242; // native
const uint32_t C_stdio___stdio_con_stream_mode = 243; // native
const uint32_t C_stdio___stdio_con_trans_mode = 244; // native
const uint32_t C_stdlib___stdlib_EXIT_SUCCESS_get = 251; // native
const uint32_t C_stdlib___stdlib_EXIT_FAILURE_get = 252; // native
const uint32_t C_stdlib___stdlib_RAND_MAX_get = 253; // native
const uint32_t C_stdlib___stdlib_MB_CUR_MAX_get = 254; // native
const uint32_t C_stdlib___stdlib__str2num = 255; // abc
const uint32_t C_stdlib___stdlib__str2int = 256; // abc
const uint32_t C_stdlib___stdlib__str2uint = 257; // abc
const uint32_t C_stdlib_div_t_toString = 260; // abc
const uint32_t C_stdlib_ldiv_t_toString = 263; // abc
const uint32_t C_stdlib_lldiv_t_toString = 266; // abc
const uint32_t C_time___time_CLOCKS_PER_SEC_get = 269; // native
const uint32_t C_fcntl___fcntl_O_RDONLY_get = 272; // native
const uint32_t C_fcntl___fcntl_O_WRONLY_get = 273; // native
const uint32_t C_fcntl___fcntl_O_RDWR_get = 274; // native
const uint32_t C_fcntl___fcntl_O_ACCMODE_get = 275; // native
const uint32_t C_fcntl___fcntl_O_APPEND_get = 276; // native
const uint32_t C_fcntl___fcntl_O_CREAT_get = 277; // native
const uint32_t C_fcntl___fcntl_O_TRUNC_get = 278; // native
const uint32_t C_fcntl___fcntl_O_EXCL_get = 279; // native
const uint32_t C_fcntl___fcntl_O_TEXT_get = 280; // native
const uint32_t C_fcntl___fcntl_O_BINARY_get = 281; // native
const uint32_t C_netdb___netdb_AI_PASSIVE_get = 284; // native
const uint32_t C_netdb___netdb_AI_CANONNAME_get = 285; // native
const uint32_t C_netdb___netdb_AI_NUMERICHOST_get = 286; // native
const uint32_t C_netdb___netdb_AI_NUMERICSERV_get = 287; // native
const uint32_t C_netdb___netdb_AI_V4MAPPED_get = 288; // native
const uint32_t C_netdb___netdb_AI_ALL_get = 289; // native
const uint32_t C_netdb___netdb_AI_ADDRCONFIG_get = 290; // native
const uint32_t C_netdb_hostent_toString = 293; // abc
const uint32_t C_netdb_protoent_toString = 298; // abc
const uint32_t C_netinet___netinet_IPPROTO_IP_get = 305; // native
const uint32_t C_netinet___netinet_IPPROTO_IPV6_get = 306; // native
const uint32_t C_netinet___netinet_IPPROTO_ICMP_get = 307; // native
const uint32_t C_netinet___netinet_IPPROTO_RAW_get = 308; // native
const uint32_t C_netinet___netinet_IPPROTO_TCP_get = 309; // native
const uint32_t C_netinet___netinet_IPPROTO_UDP_get = 310; // native
const uint32_t C_netinet___netinet_INADDR_ANY_get = 311; // native
const uint32_t C_netinet___netinet_INADDR_BROADCAST_get = 312; // native
const uint32_t C_netinet___netinet_INET_ADDRSTRLEN_get = 313; // native
const uint32_t C_netinet___netinet_INET6_ADDRSTRLEN_get = 314; // native
const uint32_t C_netinet___netinet_IPV6_JOIN_GROUP_get = 315; // native
const uint32_t C_netinet___netinet_IPV6_LEAVE_GROUP_get = 316; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_HOPS_get = 317; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_IF_get = 318; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_LOOP_get = 319; // native
const uint32_t C_netinet___netinet_IPV6_UNICAST_HOPS_get = 320; // native
const uint32_t C_netinet___netinet_IPV6_V6ONLY_get = 321; // native
const uint32_t C_spawn_pid_t_valueOf = 334; // abc
const uint32_t C_spawn_pid_t_toString = 335; // abc
const uint32_t C_sys_socket___socket_SOCK_DGRAM_get = 338; // native
const uint32_t C_sys_socket___socket_SOCK_RAW_get = 339; // native
const uint32_t C_sys_socket___socket_SOCK_SEQPACKET_get = 340; // native
const uint32_t C_sys_socket___socket_SOCK_STREAM_get = 341; // native
const uint32_t C_sys_socket_sockaddr_toSockaddr_storage = 346; // abc
const uint32_t C_sys_socket_sockaddr_storage_toSockaddr = 349; // abc
const uint32_t C_sys_stat___stat__mkdir = 354; // native
const uint32_t C_sys_stat_status_toString = 357; // abc
const uint32_t C_sys_wait___wait_WCONTINUED_get = 360; // native
const uint32_t C_sys_wait___wait_WNOHANG_get = 361; // native
const uint32_t C_sys_wait___wait_WUNTRACED_get = 362; // native
const uint32_t C_sys_wait___wait_WEXITED_get = 363; // native
const uint32_t C_sys_wait___wait_WNOWAIT_get = 364; // native
const uint32_t C_sys_wait___wait_WSTOPPED_get = 365; // native
const uint32_t C_sys_wait___wait_P_ALL_get = 366; // native
const uint32_t C_sys_wait___wait_P_PGID_get = 367; // native
const uint32_t C_sys_wait___wait_P_PID_get = 368; // native
const uint32_t C_sys_wait___wait__WEXITSTATUS = 369; // native
const uint32_t C_sys_wait___wait__WIFCONTINUED = 370; // native
const uint32_t C_sys_wait___wait__WIFEXITED = 371; // native
const uint32_t C_sys_wait___wait__WIFSIGNALED = 372; // native
const uint32_t C_sys_wait___wait__WIFSTOPPED = 373; // native
const uint32_t C_sys_wait___wait__WSTOPSIG = 374; // native
const uint32_t C_sys_wait___wait__WTERMSIG = 375; // native
const uint32_t C_unistd___unistd_F_OK_get = 380; // native
const uint32_t C_unistd___unistd_X_OK_get = 381; // native
const uint32_t C_unistd___unistd_W_OK_get = 382; // native
const uint32_t C_unistd___unistd_R_OK_get = 383; // native
const uint32_t C_unistd___unistd_getcwd = 384; // native
const uint32_t C_unistd___unistd_gethostname = 385; // native
const uint32_t C_unistd___unistd_getlogin = 386; // native
const uint32_t C_unistd___unistd_getpid = 387; // native
const uint32_t C_unistd___unistd_rmdir = 388; // native
const uint32_t C_unistd___unistd_sleep = 389; // native
const uint32_t C_unistd___unistd_unlink = 390; // native
const uint32_t shell_Program_private__getArgv = 393; // native
const uint32_t shell_Program_private__getEnviron = 394; // native
const uint32_t shell_Program_private__getProgramFilename = 395; // native
const uint32_t shell_Program_private__setExitListener = 396; // native
const uint32_t shell_Program_private__popenRead = 397; // native
const uint32_t shell_Program_totalMemory_get = 398; // native
const uint32_t shell_Program_freeMemory_get = 399; // native
const uint32_t shell_Program_privateMemory_get = 400; // native
const uint32_t shell_Program_environ_get = 401; // abc
const uint32_t shell_Program_pid_get = 402; // abc
const uint32_t shell_Program_shell_get = 403; // abc
const uint32_t shell_Program_workingDirectory_get = 404; // abc
const uint32_t shell_Program_workingDirectory_set = 405; // abc
const uint32_t shell_Program_AVM2_atExit = 406; // abc
const uint32_t shell_Program_AVM2_setExitListener = 407; // abc
const uint32_t shell_Program_AVM2_setShell = 408; // abc
const uint32_t shell_Program_AVM2_selfCheck = 409; // abc
const uint32_t shell_Program_abort = 410; // native
const uint32_t shell_Program_exec = 411; // native
const uint32_t shell_Program_exit = 412; // native
const uint32_t shell_Program_open = 413; // abc
const uint32_t shell_Program_sleep = 414; // native
const uint32_t shell_Program_getNanosecondTimer = 415; // native
const uint32_t shell_Program_getTimer = 416; // native
const uint32_t shell_Program_readLine = 417; // native
const uint32_t shell_Program_write = 418; // native
const uint32_t shell_Program_writeLine = 419; // abc
const uint32_t shell_Program_trace = 420; // native
const uint32_t shell_Program_forceFullCollection = 421; // native
const uint32_t shell_Program_queueCollection = 422; // native
const uint32_t shell_Program_pauseForGCIfCollectionImminent = 423; // native
const uint32_t shell_Program_disposeXML = 424; // native
const uint32_t shell_Runtime_private__getAvmplusPlatform = 427; // native
const uint32_t shell_Runtime_private__getAvmplusArchitecture = 428; // native
const uint32_t shell_Runtime_private__getAvmplusVersion = 429; // native
const uint32_t shell_Runtime_private__getAvmplusDescription = 430; // native
const uint32_t shell_Runtime_private__getFeatures = 431; // native
const uint32_t shell_Runtime_private__getRunmode = 432; // native
const uint32_t shell_Runtime_private__getEndian = 433; // native
const uint32_t shell_Runtime_apiVersion_get = 434; // native
const uint32_t shell_Runtime_api_get = 435; // abc
const uint32_t shell_Runtime_swfVersion_get = 436; // native
const uint32_t shell_Runtime_platform_get = 437; // abc
const uint32_t shell_Runtime_architecture_get = 438; // abc
const uint32_t shell_Runtime_version_get = 439; // abc
const uint32_t shell_Runtime_description_get = 440; // abc
const uint32_t shell_Runtime_features_get = 441; // abc
const uint32_t shell_Runtime_runmode_get = 442; // abc
const uint32_t shell_Runtime_endian_get = 443; // abc
const uint32_t shell_Runtime_redtamarin_get = 444; // abc
const uint32_t shell_Runtime_loop_get = 445; // abc
const uint32_t shell_Runtime_loop_set = 446; // abc
const uint32_t shell_Runtime_eval = 447; // native
const uint32_t shell_Runtime_returnEval = 448; // native
const uint32_t shell_Runtime_is64bit = 449; // native
const uint32_t shell_Diagnostics_private__isGlobal = 452; // native
const uint32_t shell_Diagnostics_private__isIntptr = 453; // native
const uint32_t shell_Diagnostics_private__canonicalizeNumber = 454; // native
const uint32_t shell_Diagnostics_private__deopt = 455; // native
const uint32_t shell_Diagnostics_private__runInSafepoint = 456; // native
const uint32_t shell_Diagnostics_private__log = 457; // native
const uint32_t shell_Diagnostics_private__initializeLogging = 458; // native
const uint32_t shell_Diagnostics_debugger = 459; // native
const uint32_t shell_Diagnostics_isDebugger = 460; // native
const uint32_t shell_Diagnostics_AVM2_log = 461; // abc
const uint32_t shell_Diagnostics_AVM2_initializeLogging = 462; // abc
const uint32_t shell_Diagnostics_AVM2_isGlobal = 463; // abc
const uint32_t shell_Diagnostics_AVM2_isIntptr = 464; // abc
const uint32_t shell_Diagnostics_AVM2_canonicalizeNumber = 465; // abc
const uint32_t shell_Diagnostics_AVM2_deopt = 466; // abc
const uint32_t shell_Diagnostics_AVM2_runInSafepoint = 467; // abc
const uint32_t shell_HardwareInformation_private__getProcessorCountAtBoot = 470; // native
const uint32_t shell_HardwareInformation_private__getMemorySize = 471; // native
const uint32_t shell_HardwareInformation_private__getMemoryUsage = 472; // native
const uint32_t shell_HardwareInformation_private__getMemoryPeakUsage = 473; // native
const uint32_t shell_HardwareInformation_processors_get = 474; // abc
const uint32_t shell_HardwareInformation_memory_get = 475; // abc
const uint32_t shell_HardwareInformation_memoryUsage_get = 476; // abc
const uint32_t shell_HardwareInformation_memoryPeakUsage_get = 477; // abc
const uint32_t shell_OperatingSystem_isWindowsStore = 480; // native
const uint32_t shell_Domain_currentDomain_get = 485; // native
const uint32_t shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get = 486; // native
const uint32_t shell_Domain_private_init = 487; // native
const uint32_t shell_Domain_loadBytes = 489; // native
const uint32_t shell_Domain_getClass = 490; // native
const uint32_t shell_Domain_load = 491; // abc
const uint32_t shell_Domain_domainMemory_get = 492; // native
const uint32_t shell_Domain_domainMemory_set = 493; // native
const uint32_t shell_FileIO_exists = 495; // native
const uint32_t shell_FileIO_read = 496; // native
const uint32_t shell_FileIO_write = 497; // native
const uint32_t shell_FileIO_readByteArray = 498; // native
const uint32_t shell_FileIO_writeByteArray = 499; // native
const uint32_t shell_Environment_private__parse = 503; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_callProperty = 504; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_deleteProperty = 505; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_getProperty = 506; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_setProperty = 507; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_hasProperty = 508; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextNameIndex = 509; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextName = 510; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextValue = 511; // abc
const uint32_t shell_Environment_length_get = 512; // abc
const uint32_t shell_Environment_refresh = 513; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_get = 517; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_set = 518; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_get = 519; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_set = 520; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_get = 521; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_set = 522; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frame_get = 523; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_started_get = 524; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_elapsed_get = 525; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timerPending_get = 526; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_setCallback = 527; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_handleTimers = 528; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_start = 529; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_stop = 530; // abc
const uint32_t flash_accessibility_ISearchableText_flash_accessibility_ISearchableText_searchText_get = 533; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionAnchorIndex_get = 536; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionActiveIndex_get = 537; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accRole = 543; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accName = 544; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accValue = 545; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accState = 546; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accDefaultAction = 547; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accDoDefaultAction = 548; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_isLabeledBy = 549; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_getChildIDArray = 550; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accLocation = 551; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accSelection = 552; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accFocus = 553; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accSelect = 554; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionAnchorIndex = 555; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionActiveIndex = 556; // abc
const uint32_t flash_data_EncryptedLocalStore_isSupported_get = 560; // abc
const uint32_t flash_display_Scene_name_get = 610; // abc
const uint32_t flash_display_Scene_labels_get = 611; // abc
const uint32_t flash_display_Scene_numFrames_get = 612; // abc
const uint32_t flash_errors_SQLError_operation_get = 639; // abc
const uint32_t flash_errors_SQLError_details_get = 640; // abc
const uint32_t flash_errors_SQLError_detailID_get = 641; // abc
const uint32_t flash_errors_SQLError_detailArguments_get = 642; // abc
const uint32_t flash_errors_DRMManagerError_subErrorID_get = 645; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_addEventListener = 647; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_dispatchEvent = 648; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_hasEventListener = 649; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_removeEventListener = 650; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_willTrigger = 651; // abc
const uint32_t flash_events_Event_private_ctor = 655; // abc
const uint32_t flash_events_Event_type_get = 656; // abc
const uint32_t flash_events_Event_bubbles_get = 657; // abc
const uint32_t flash_events_Event_cancelable_get = 658; // abc
const uint32_t flash_events_Event_target_get = 659; // abc
const uint32_t flash_events_Event_currentTarget_get = 660; // abc
const uint32_t flash_events_Event_eventPhase_get = 661; // abc
const uint32_t flash_events_Event_formatToString = 662; // abc
const uint32_t flash_events_Event_clone = 663; // abc
const uint32_t flash_events_Event_isDefaultPrevented = 664; // abc
const uint32_t flash_events_Event_preventDefault = 665; // abc
const uint32_t flash_events_Event_stopImmediatePropagation = 666; // abc
const uint32_t flash_events_Event_stopPropagation = 667; // abc
const uint32_t flash_events_Event_toString = 668; // abc
const uint32_t flash_geom_Point_interpolate = 672; // abc
const uint32_t flash_geom_Point_distance = 673; // abc
const uint32_t flash_geom_Point_polar = 674; // abc
const uint32_t flash_geom_Point_length_get = 676; // abc
const uint32_t flash_geom_Point_clone = 677; // abc
const uint32_t flash_geom_Point_offset = 678; // abc
const uint32_t flash_geom_Point_equals = 679; // abc
const uint32_t flash_geom_Point_subtract = 680; // abc
const uint32_t flash_geom_Point_add = 681; // abc
const uint32_t flash_geom_Point_normalize = 682; // abc
const uint32_t flash_geom_Point_toString = 683; // abc
const uint32_t flash_geom_Rectangle_left_get = 686; // abc
const uint32_t flash_geom_Rectangle_left_set = 687; // abc
const uint32_t flash_geom_Rectangle_right_get = 688; // abc
const uint32_t flash_geom_Rectangle_right_set = 689; // abc
const uint32_t flash_geom_Rectangle_top_get = 690; // abc
const uint32_t flash_geom_Rectangle_top_set = 691; // abc
const uint32_t flash_geom_Rectangle_bottom_get = 692; // abc
const uint32_t flash_geom_Rectangle_bottom_set = 693; // abc
const uint32_t flash_geom_Rectangle_topLeft_get = 694; // abc
const uint32_t flash_geom_Rectangle_topLeft_set = 695; // abc
const uint32_t flash_geom_Rectangle_bottomRight_get = 696; // abc
const uint32_t flash_geom_Rectangle_bottomRight_set = 697; // abc
const uint32_t flash_geom_Rectangle_size_get = 698; // abc
const uint32_t flash_geom_Rectangle_size_set = 699; // abc
const uint32_t flash_geom_Rectangle_clone = 700; // abc
const uint32_t flash_geom_Rectangle_isEmpty = 701; // abc
const uint32_t flash_geom_Rectangle_setEmpty = 702; // abc
const uint32_t flash_geom_Rectangle_inflate = 703; // abc
const uint32_t flash_geom_Rectangle_inflatePoint = 704; // abc
const uint32_t flash_geom_Rectangle_offset = 705; // abc
const uint32_t flash_geom_Rectangle_offsetPoint = 706; // abc
const uint32_t flash_geom_Rectangle_contains = 707; // abc
const uint32_t flash_geom_Rectangle_containsPoint = 708; // abc
const uint32_t flash_geom_Rectangle_containsRect = 709; // abc
const uint32_t flash_geom_Rectangle_intersection = 710; // abc
const uint32_t flash_geom_Rectangle_intersects = 711; // abc
const uint32_t flash_geom_Rectangle_union = 712; // abc
const uint32_t flash_geom_Rectangle_equals = 713; // abc
const uint32_t flash_geom_Rectangle_toString = 714; // abc
const uint32_t flash_sampler_StackFrame_toString = 718; // abc
const uint32_t flash_system_Capabilities_playerType_get = 725; // abc
const uint32_t flash_system_Capabilities_isDebugger_get = 726; // abc
const uint32_t flash_system_System_setClipboard = 729; // abc
const uint32_t flash_system_System_totalMemory_get = 730; // abc
const uint32_t flash_system_System_totalMemoryNumber_get = 731; // abc
const uint32_t flash_system_System_freeMemory_get = 732; // native
const uint32_t flash_system_System_privateMemory_get = 733; // abc
const uint32_t flash_system_System_useCodePage_get = 734; // abc
const uint32_t flash_system_System_useCodePage_set = 735; // abc
const uint32_t flash_system_System_vmVersion_get = 736; // abc
const uint32_t flash_system_System_pause = 737; // abc
const uint32_t flash_system_System_resume = 738; // abc
const uint32_t flash_system_System_exit = 739; // abc
const uint32_t flash_system_System_gc = 740; // abc
const uint32_t flash_system_System_disposeXML = 741; // abc
const uint32_t flash_system_WorkerState_code = 744; // abc
const uint32_t flash_system_Worker_current_get = 747; // abc
const uint32_t flash_system_Worker_pr = 748; // native
const uint32_t flash_system_Worker_state_get = 750; // native
const uint32_t flash_system_Worker_start = 751; // native
const uint32_t flash_system_Worker_isParentOf = 752; // native
const uint32_t flash_system_Worker_isPrimordial_get = 753; // native
const uint32_t flash_system_Worker_setSharedProperty = 754; // native
const uint32_t flash_system_Worker_getSharedProperty = 755; // native
const uint32_t flash_system_Worker_terminate = 756; // native
const uint32_t flash_system_WorkerEvent_currentState_get = 759; // abc
const uint32_t flash_system_WorkerEvent_previousState_get = 760; // abc
const uint32_t flash_system_WorkerEvent_target_get = 761; // abc
const uint32_t flash_system_WorkerDomain_current_get = 763; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromByteArray = 765; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromPrimordial = 766; // abc
const uint32_t flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal = 767; // native
const uint32_t flash_system_WorkerDomain_listWorkers = 768; // native
const uint32_t flash_trace_Trace_setLevel = 770; // native
const uint32_t flash_trace_Trace_getLevel = 771; // native
const uint32_t flash_trace_Trace_setListener = 772; // native
const uint32_t flash_trace_Trace_getListener = 773; // native
const uint32_t shell_async_CoreEventLoop_running_get = 779; // abc
const uint32_t shell_async_CoreEventLoop_running_set = 780; // abc
const uint32_t shell_async_CoreEventLoop_frequency_get = 781; // abc
const uint32_t shell_async_CoreEventLoop_frequency_set = 782; // abc
const uint32_t shell_async_CoreEventLoop_timers_get = 783; // abc
const uint32_t shell_async_CoreEventLoop_timers_set = 784; // abc
const uint32_t shell_async_CoreEventLoop_frame_get = 785; // abc
const uint32_t shell_async_CoreEventLoop_started_get = 786; // abc
const uint32_t shell_async_CoreEventLoop_elapsed_get = 787; // abc
const uint32_t shell_async_CoreEventLoop_private_tick = 788; // abc
const uint32_t shell_async_CoreEventLoop_setCallback = 789; // abc
const uint32_t shell_async_CoreEventLoop_private__loop = 790; // abc
const uint32_t shell_async_CoreEventLoop_timerPending_get = 791; // abc
const uint32_t shell_async_CoreEventLoop_handleTimers = 792; // abc
const uint32_t shell_async_CoreEventLoop_start = 793; // abc
const uint32_t shell_async_CoreEventLoop_stop = 794; // abc
const uint32_t flash_events_EventDispatcher_private_trimHeaderValue = 796; // abc
const uint32_t flash_events_EventDispatcher_private_ctor = 798; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchEventFunction = 799; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchHttpStatusEvent = 801; // abc
const uint32_t flash_events_EventDispatcher_addEventListener = 802; // abc
const uint32_t flash_events_EventDispatcher_dispatchEvent = 803; // abc
const uint32_t flash_events_EventDispatcher_hasEventListener = 804; // abc
const uint32_t flash_events_EventDispatcher_removeEventListener = 805; // abc
const uint32_t flash_events_EventDispatcher_willTrigger = 806; // abc
const uint32_t flash_events_EventDispatcher_toString = 807; // abc
const uint32_t flash_events_HTTPStatusEvent_status_get = 810; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_get = 811; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_set = 812; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_get = 813; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_set = 814; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_get = 815; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_set = 816; // abc
const uint32_t flash_events_HTTPStatusEvent_clone = 817; // abc
const uint32_t flash_events_HTTPStatusEvent_toString = 818; // abc
const uint32_t flash_events_TimerEvent_clone = 821; // abc
const uint32_t flash_events_TimerEvent_toString = 822; // abc
const uint32_t flash_events_TimerEvent_updateAfterEvent = 823; // abc
const uint32_t flash_sampler_NewObjectSample_object_get = 825; // native
const uint32_t flash_sampler_NewObjectSample_size_get = 826; // native
const uint32_t flash_utils_Timer_private__timerDispatch = 832; // abc
const uint32_t flash_utils_Timer_private__start = 833; // abc
const uint32_t flash_utils_Timer_tick = 834; // abc
const uint32_t flash_utils_Timer_delay_get = 835; // abc
const uint32_t flash_utils_Timer_delay_set = 836; // abc
const uint32_t flash_utils_Timer_repeatCount_get = 837; // abc
const uint32_t flash_utils_Timer_repeatCount_set = 838; // abc
const uint32_t flash_utils_Timer_currentCount_get = 839; // abc
const uint32_t flash_utils_Timer_running_get = 840; // abc
const uint32_t flash_utils_Timer_reset = 841; // abc
const uint32_t flash_utils_Timer_start = 842; // abc
const uint32_t flash_utils_Timer_stop = 843; // abc

extern avmplus::Atom native_script_function_C_assert__debugBreak_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_assert__debugBreak_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isalnum_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isalnum_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isalpha_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isalpha_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isblank_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isblank_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_iscntrl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_iscntrl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isgraph_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isgraph_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_islower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_islower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isprint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isprint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_ispunct_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_ispunct_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isspace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isspace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isxdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_isxdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_toascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_toascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_tolower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_tolower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_toupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_ctype_toupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_errno__GetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_errno__GetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_errno__SetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_errno__SetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_NONBLOCKING_DISABLE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_NONBLOCKING_DISABLE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_NONBLOCKING_ENABLE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_NONBLOCKING_ENABLE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_remove_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_remove_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_con_stream_mode_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_con_stream_mode_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_con_trans_mode_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_con_trans_mode_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_ANY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_ANY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_BROADCAST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INADDR_BROADCAST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat__mkdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat__mkdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_exists_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_exists_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_read_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_read_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_write_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_write_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_readByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_readByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_writeByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileIO_writeByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
class SlotOffsetsAndAsserts;
//-----------------------------------------------------------
// C.errno::ErrorNumber$
//-----------------------------------------------------------
class avmplus_ErrorNumberClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberClass;
#define GC_TRIVIAL_TRACER_ErrorNumberClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::ErrorNumber
//-----------------------------------------------------------
class avmplus_ErrorNumberObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberObject;
private:
    uint32_t m_private__value;
#define GC_TRIVIAL_TRACER_ErrorNumberObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError$
//-----------------------------------------------------------
class avmplus_CErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CErrorClass;
#define GC_TRIVIAL_TRACER_CErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError
//-----------------------------------------------------------
class avmplus_CErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CErrorObject;
#define GC_TRIVIAL_TRACER_CErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits$
//-----------------------------------------------------------
class avmshell_CLimitsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLimitsClass;
};
#define DECLARE_SLOTS_CLimitsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits
//-----------------------------------------------------------
class avmplus___limitsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__limitsObject;
#define GC_TRIVIAL_TRACER___limitsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale$
//-----------------------------------------------------------
class avmshell_CLocaleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLocaleClass;
};
#define DECLARE_SLOTS_CLocaleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale
//-----------------------------------------------------------
class avmplus___localeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__localeObject;
#define GC_TRIVIAL_TRACER___localeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal$
//-----------------------------------------------------------
class avmshell_CSignalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSignalClass;
};
#define DECLARE_SLOTS_CSignalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal
//-----------------------------------------------------------
class avmplus___signalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__signalObject;
#define GC_TRIVIAL_TRACER___signalObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval$
//-----------------------------------------------------------
class avmshell_CsigvalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalClass;
};
#define DECLARE_SLOTS_CsigvalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CsigvalObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval
//-----------------------------------------------------------
class avmshell_CsigvalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalObject;
private:
    int32_t m_sival_int;
};
#define DECLARE_SLOTS_CsigvalObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_sival_int() const { return m_slots_CsigvalObject.m_sival_int; } \
        REALLY_INLINE void set_sival_int(int32_t newVal) { m_slots_CsigvalObject.m_sival_int = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CsigvalObjectSlots m_slots_CsigvalObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t$
//-----------------------------------------------------------
class avmshell_Csiginfo_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tClass;
};
#define DECLARE_SLOTS_Csiginfo_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Csiginfo_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t
//-----------------------------------------------------------
class avmshell_Csiginfo_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tObject;
private:
    int32_t m_si_signo;
    int32_t m_si_code;
    int32_t m_si_errno;
    int32_t m_si_pid;
    int32_t m_si_uid;
    int32_t m_si_status;
    double m_si_band;
};
#define DECLARE_SLOTS_Csiginfo_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_si_signo() const { return m_slots_Csiginfo_tObject.m_si_signo; } \
        REALLY_INLINE void set_si_signo(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_signo = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_code() const { return m_slots_Csiginfo_tObject.m_si_code; } \
        REALLY_INLINE void set_si_code(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_code = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_errno() const { return m_slots_Csiginfo_tObject.m_si_errno; } \
        REALLY_INLINE void set_si_errno(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_errno = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_pid() const { return m_slots_Csiginfo_tObject.m_si_pid; } \
        REALLY_INLINE void set_si_pid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_pid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_uid() const { return m_slots_Csiginfo_tObject.m_si_uid; } \
        REALLY_INLINE void set_si_uid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_status() const { return m_slots_Csiginfo_tObject.m_si_status; } \
        REALLY_INLINE void set_si_status(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_status = newVal; } \
    public: \
        REALLY_INLINE double get_si_band() const { return m_slots_Csiginfo_tObject.m_si_band; } \
        REALLY_INLINE void set_si_band(double newVal) { m_slots_Csiginfo_tObject.m_si_band = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Csiginfo_tObjectSlots m_slots_Csiginfo_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio$
//-----------------------------------------------------------
class avmshell_CStdioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdioClass;
};
#define DECLARE_SLOTS_CStdioClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio
//-----------------------------------------------------------
class avmplus___stdioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdioObject;
#define GC_TRIVIAL_TRACER___stdioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE$
//-----------------------------------------------------------
class avmshell_CFILEClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEClass;
};
#define DECLARE_SLOTS_CFILEClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CFILEObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE
//-----------------------------------------------------------
class avmshell_CFILEObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEObject;
};
#define DECLARE_SLOTS_CFILEObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t$
//-----------------------------------------------------------
class avmshell_Cfpos_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tClass;
};
#define DECLARE_SLOTS_Cfpos_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cfpos_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t
//-----------------------------------------------------------
class avmshell_Cfpos_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tObject;
};
#define DECLARE_SLOTS_Cfpos_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib$
//-----------------------------------------------------------
class avmshell_CStdlibClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdlibClass;
};
#define DECLARE_SLOTS_CStdlibClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib
//-----------------------------------------------------------
class avmplus___stdlibObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdlibObject;
#define GC_TRIVIAL_TRACER___stdlibObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t$
//-----------------------------------------------------------
class avmshell_Cdiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tClass;
};
#define DECLARE_SLOTS_Cdiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cdiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t
//-----------------------------------------------------------
class avmshell_Cdiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tObject;
private:
    int32_t m_quot;
    int32_t m_rem;
};
#define DECLARE_SLOTS_Cdiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_quot() const { return m_slots_Cdiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(int32_t newVal) { m_slots_Cdiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE int32_t get_rem() const { return m_slots_Cdiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(int32_t newVal) { m_slots_Cdiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cdiv_tObjectSlots m_slots_Cdiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t$
//-----------------------------------------------------------
class avmshell_Cldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tClass;
};
#define DECLARE_SLOTS_Cldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t
//-----------------------------------------------------------
class avmshell_Cldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Cldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Cldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Cldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Cldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Cldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cldiv_tObjectSlots m_slots_Cldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t$
//-----------------------------------------------------------
class avmshell_Clldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tClass;
};
#define DECLARE_SLOTS_Clldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Clldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t
//-----------------------------------------------------------
class avmshell_Clldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Clldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Clldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Clldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Clldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Clldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Clldiv_tObjectSlots m_slots_Clldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time$
//-----------------------------------------------------------
class avmshell_CTimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CTimeClass;
};
#define DECLARE_SLOTS_CTimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time
//-----------------------------------------------------------
class avmplus___timeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__timeObject;
#define GC_TRIVIAL_TRACER___timeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl$
//-----------------------------------------------------------
class avmshell_CFcntlClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFcntlClass;
};
#define DECLARE_SLOTS_CFcntlClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl
//-----------------------------------------------------------
class avmplus___fcntlObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__fcntlObject;
#define GC_TRIVIAL_TRACER___fcntlObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb$
//-----------------------------------------------------------
class avmshell_CNetdbClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetdbClass;
};
#define DECLARE_SLOTS_CNetdbClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb
//-----------------------------------------------------------
class avmplus___netdbObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netdbObject;
#define GC_TRIVIAL_TRACER___netdbObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent$
//-----------------------------------------------------------
class avmshell_ChostentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentClass;
};
#define DECLARE_SLOTS_ChostentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ChostentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent
//-----------------------------------------------------------
class avmshell_ChostentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentObject;
private:
    int32_t m_h_addrtype;
    int32_t m_h_length;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_h_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_aliases;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_addr_list;
};
#define DECLARE_SLOTS_ChostentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_h_addrtype() const { return m_slots_ChostentObject.m_h_addrtype; } \
        REALLY_INLINE void set_h_addrtype(int32_t newVal) { m_slots_ChostentObject.m_h_addrtype = newVal; } \
    public: \
        REALLY_INLINE int32_t get_h_length() const { return m_slots_ChostentObject.m_h_length; } \
        REALLY_INLINE void set_h_length(int32_t newVal) { m_slots_ChostentObject.m_h_length = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_h_name() const { return m_slots_ChostentObject.m_h_name; } \
        REALLY_INLINE void set_h_name(avmplus::String* newVal) { m_slots_ChostentObject.m_h_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_aliases() const { return m_slots_ChostentObject.m_h_aliases; } \
        REALLY_INLINE void set_h_aliases(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_aliases = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_addr_list() const { return m_slots_ChostentObject.m_h_addr_list; } \
        REALLY_INLINE void set_h_addr_list(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_addr_list = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ChostentObjectSlots m_slots_ChostentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent$
//-----------------------------------------------------------
class avmplus_netentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentClass;
#define GC_TRIVIAL_TRACER_netentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent
//-----------------------------------------------------------
class avmplus_netentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentObject;
#define GC_TRIVIAL_TRACER_netentObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent$
//-----------------------------------------------------------
class avmshell_CprotoentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentClass;
};
#define DECLARE_SLOTS_CprotoentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CprotoentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent
//-----------------------------------------------------------
class avmshell_CprotoentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentObject;
private:
    int32_t m_p_proto;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_p_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_p_aliases;
};
#define DECLARE_SLOTS_CprotoentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_p_proto() const { return m_slots_CprotoentObject.m_p_proto; } \
        REALLY_INLINE void set_p_proto(int32_t newVal) { m_slots_CprotoentObject.m_p_proto = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_p_name() const { return m_slots_CprotoentObject.m_p_name; } \
        REALLY_INLINE void set_p_name(avmplus::String* newVal) { m_slots_CprotoentObject.m_p_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_p_aliases() const { return m_slots_CprotoentObject.m_p_aliases; } \
        REALLY_INLINE void set_p_aliases(avmplus::ArrayObject* newVal) { m_slots_CprotoentObject.m_p_aliases = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CprotoentObjectSlots m_slots_CprotoentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent$
//-----------------------------------------------------------
class avmplus_serventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventClass;
#define GC_TRIVIAL_TRACER_serventClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent
//-----------------------------------------------------------
class avmplus_serventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventObject;
#define GC_TRIVIAL_TRACER_serventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo$
//-----------------------------------------------------------
class avmplus_addrinfoClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::addrinfoClass;
#define GC_TRIVIAL_TRACER_addrinfoClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo
//-----------------------------------------------------------
class avmplus_addrinfoObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::addrinfoObject;
#define GC_TRIVIAL_TRACER_addrinfoObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet$
//-----------------------------------------------------------
class avmshell_CNetinetInClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetinetInClass;
};
#define DECLARE_SLOTS_CNetinetInClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet
//-----------------------------------------------------------
class avmplus___netinetObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netinetObject;
#define GC_TRIVIAL_TRACER___netinetObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr$
//-----------------------------------------------------------
class avmplus_in_addrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in_addrClass;
#define GC_TRIVIAL_TRACER_in_addrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr
//-----------------------------------------------------------
class avmplus_in_addrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in_addrObject;
private:
    uint32_t m_s_addr;
#define GC_TRIVIAL_TRACER_in_addrObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in$
//-----------------------------------------------------------
class avmplus_sockaddr_inClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_inClass;
#define GC_TRIVIAL_TRACER_sockaddr_inClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in
//-----------------------------------------------------------
class avmplus_sockaddr_inObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_inObject;
private:
    uint32_t m_sin_family;
    uint32_t m_sin_port;
    MMgc::GCTraceableObject::GCMember<avmplus::in_addrObject> m_sin_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sin_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr$
//-----------------------------------------------------------
class avmplus_in6_addrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in6_addrClass;
#define GC_TRIVIAL_TRACER_in6_addrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr
//-----------------------------------------------------------
class avmplus_in6_addrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::in6_addrObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::UIntVectorObject> m_s6_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_s6_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6$
//-----------------------------------------------------------
class avmplus_sockaddr_in6ClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_in6Class;
#define GC_TRIVIAL_TRACER_sockaddr_in6Class
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6
//-----------------------------------------------------------
class avmplus_sockaddr_in6ObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_in6Object;
private:
    uint32_t m_sin6_family;
    uint32_t m_sin6_port;
    uint32_t m_sin6_flowinfo;
    uint32_t m_sin6_scope_id;
    MMgc::GCTraceableObject::GCMember<avmplus::in6_addrObject> m_sin6_addr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sin6_addr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq$
//-----------------------------------------------------------
class avmplus_ipv6_mreqClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqClass;
#define GC_TRIVIAL_TRACER_ipv6_mreqClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq
//-----------------------------------------------------------
class avmplus_ipv6_mreqObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqObject;
private:
    uint32_t m_ipv6mr_interface;
    MMgc::GCTraceableObject::GCMember<avmplus::in6_addrObject> m_ipv6mr_multiaddr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ipv6mr_multiaddr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t$
//-----------------------------------------------------------
class avmshell_Cpid_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tClass;
};
#define DECLARE_SLOTS_Cpid_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cpid_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t
//-----------------------------------------------------------
class avmshell_Cpid_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tObject;
private:
    int32_t m_value;
};
#define DECLARE_SLOTS_Cpid_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_value() const { return m_slots_Cpid_tObject.m_value; } \
        REALLY_INLINE void set_value(int32_t newVal) { m_slots_Cpid_tObject.m_value = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cpid_tObjectSlots m_slots_Cpid_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket$
//-----------------------------------------------------------
class avmshell_CSysSocketClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysSocketClass;
};
#define DECLARE_SLOTS_CSysSocketClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket
//-----------------------------------------------------------
class avmplus___socketObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__socketObject;
#define GC_TRIVIAL_TRACER___socketObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockd$
//-----------------------------------------------------------
class avmplus_sockdClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockdClass;
#define GC_TRIVIAL_TRACER_sockdClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockd
//-----------------------------------------------------------
class avmplus_sockdObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockdObject;
#define GC_TRIVIAL_TRACER_sockdObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr$
//-----------------------------------------------------------
class avmplus_sockaddrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddrClass;
#define GC_TRIVIAL_TRACER_sockaddrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr
//-----------------------------------------------------------
class avmplus_sockaddrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddrObject;
private:
    uint32_t m_sa_family;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_sa_data;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sa_data);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage$
//-----------------------------------------------------------
class avmplus_sockaddr_storageClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageClass;
#define GC_TRIVIAL_TRACER_sockaddr_storageClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage
//-----------------------------------------------------------
class avmplus_sockaddr_storageObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageObject;
private:
    uint32_t m_ss_family;
#define GC_TRIVIAL_TRACER_sockaddr_storageObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr$
//-----------------------------------------------------------
class avmplus_msghdrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrClass;
#define GC_TRIVIAL_TRACER_msghdrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr
//-----------------------------------------------------------
class avmplus_msghdrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrObject;
private:
    int32_t m_msg_namelen;
    int32_t m_msg_iovlen;
    int32_t m_msg_controllen;
    int32_t m_msg_flags;
    avmplus::AtomWB m_msg_name;
    avmplus::AtomWB m_msg_iov;
    avmplus::AtomWB m_msg_control;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceAtom(&m_msg_name);
        gc->TraceAtom(&m_msg_iov);
        gc->TraceAtom(&m_msg_control);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat$
//-----------------------------------------------------------
class avmshell_CSysStatClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysStatClass;
};
#define DECLARE_SLOTS_CSysStatClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat
//-----------------------------------------------------------
class avmplus___statObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__statObject;
#define GC_TRIVIAL_TRACER___statObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status$
//-----------------------------------------------------------
class avmshell_CStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusClass;
};
#define DECLARE_SLOTS_CStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status
//-----------------------------------------------------------
class avmshell_CStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusObject;
private:
    int32_t m_st_dev;
    uint32_t m_st_ino;
    int32_t m_st_mode;
    int32_t m_st_nlink;
    int32_t m_st_uid;
    int32_t m_st_gid;
    int32_t m_st_rdev;
    int32_t m_st_atime;
    int32_t m_st_mtime;
    int32_t m_st_ctime;
    double m_st_size;
};
#define DECLARE_SLOTS_CStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_st_dev() const { return m_slots_CStatusObject.m_st_dev; } \
        REALLY_INLINE void set_st_dev(int32_t newVal) { m_slots_CStatusObject.m_st_dev = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_st_ino() const { return m_slots_CStatusObject.m_st_ino; } \
        REALLY_INLINE void set_st_ino(uint32_t newVal) { m_slots_CStatusObject.m_st_ino = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_mode() const { return m_slots_CStatusObject.m_st_mode; } \
        REALLY_INLINE void set_st_mode(int32_t newVal) { m_slots_CStatusObject.m_st_mode = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_nlink() const { return m_slots_CStatusObject.m_st_nlink; } \
        REALLY_INLINE void set_st_nlink(int32_t newVal) { m_slots_CStatusObject.m_st_nlink = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_uid() const { return m_slots_CStatusObject.m_st_uid; } \
        REALLY_INLINE void set_st_uid(int32_t newVal) { m_slots_CStatusObject.m_st_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_gid() const { return m_slots_CStatusObject.m_st_gid; } \
        REALLY_INLINE void set_st_gid(int32_t newVal) { m_slots_CStatusObject.m_st_gid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_rdev() const { return m_slots_CStatusObject.m_st_rdev; } \
        REALLY_INLINE void set_st_rdev(int32_t newVal) { m_slots_CStatusObject.m_st_rdev = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_atime() const { return m_slots_CStatusObject.m_st_atime; } \
        REALLY_INLINE void set_st_atime(int32_t newVal) { m_slots_CStatusObject.m_st_atime = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_mtime() const { return m_slots_CStatusObject.m_st_mtime; } \
        REALLY_INLINE void set_st_mtime(int32_t newVal) { m_slots_CStatusObject.m_st_mtime = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_ctime() const { return m_slots_CStatusObject.m_st_ctime; } \
        REALLY_INLINE void set_st_ctime(int32_t newVal) { m_slots_CStatusObject.m_st_ctime = newVal; } \
    public: \
        REALLY_INLINE double get_st_size() const { return m_slots_CStatusObject.m_st_size; } \
        REALLY_INLINE void set_st_size(double newVal) { m_slots_CStatusObject.m_st_size = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CStatusObjectSlots m_slots_CStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait$
//-----------------------------------------------------------
class avmshell_CSysWaitClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysWaitClass;
};
#define DECLARE_SLOTS_CSysWaitClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait
//-----------------------------------------------------------
class avmplus___waitObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__waitObject;
#define GC_TRIVIAL_TRACER___waitObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status$
//-----------------------------------------------------------
class avmshell_CWaitStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusClass;
};
#define DECLARE_SLOTS_CWaitStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CWaitStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status
//-----------------------------------------------------------
class avmshell_CWaitStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusObject;
private:
    int32_t m_stat_loc;
};
#define DECLARE_SLOTS_CWaitStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_stat_loc() const { return m_slots_CWaitStatusObject.m_stat_loc; } \
        REALLY_INLINE void set_stat_loc(int32_t newVal) { m_slots_CWaitStatusObject.m_stat_loc = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CWaitStatusObjectSlots m_slots_CWaitStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd$
//-----------------------------------------------------------
class avmshell_CUnistdClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CUnistdClass;
};
#define DECLARE_SLOTS_CUnistdClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd
//-----------------------------------------------------------
class avmplus___unistdObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__unistdObject;
#define GC_TRIVIAL_TRACER___unistdObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program$
//-----------------------------------------------------------
class avmshell_ProgramClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ProgramClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_http___code_google_com_p_redtamarin_AVM2__shell;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_http___code_google_com_p_redtamarin_AVM2__exitcall;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_argv;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_filename;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_startupDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_onExit;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_findShell;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__shell);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__exitcall);
        gc->TraceLocation(&m_argv);
        gc->TraceLocation(&m_filename);
        gc->TraceLocation(&m_startupDirectory);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_onExit);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_findShell);
    }
};
#define DECLARE_SLOTS_ProgramClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::String* get__shell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell; } \
        REALLY_INLINE void set__shell(avmplus::String* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__exitcall() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall; } \
        REALLY_INLINE void set__exitcall(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_argv() const { return m_slots_ProgramClass.m_argv; } \
        REALLY_INLINE void setconst_argv(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_argv = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_filename() const { return m_slots_ProgramClass.m_filename; } \
        REALLY_INLINE void setconst_filename(avmplus::String* newVal) { m_slots_ProgramClass.m_filename = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_startupDirectory() const { return m_slots_ProgramClass.m_startupDirectory; } \
        REALLY_INLINE void setconst_startupDirectory(avmplus::String* newVal) { m_slots_ProgramClass.m_startupDirectory = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_onExit() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit; } \
        REALLY_INLINE void set_onExit(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_findShell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell; } \
        REALLY_INLINE void set_findShell(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ProgramClassSlots m_slots_ProgramClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program
//-----------------------------------------------------------
class avmplus_ProgramObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ProgramObject;
#define GC_TRIVIAL_TRACER_ProgramObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime$
//-----------------------------------------------------------
class avmshell_RuntimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::RuntimeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__API;
    MMgc::GCTraceableObject::GCMember<avmplus::EventLoopInterface> m_private__loop;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_goAsync;
};
#define DECLARE_SLOTS_RuntimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__API() const { return m_slots_RuntimeClass.m_private__API; } \
        REALLY_INLINE void set__API(avmplus::ArrayObject* newVal) { m_slots_RuntimeClass.m_private__API = newVal; } \
    protected: \
        REALLY_INLINE avmplus::EventLoopInterface* get__loop() const { return m_slots_RuntimeClass.m_private__loop; } \
        REALLY_INLINE void set__loop(avmplus::EventLoopInterface* newVal) { m_slots_RuntimeClass.m_private__loop = newVal; } \
    public: \
        REALLY_INLINE avmplus::FunctionObject* get_goAsync() const { return m_slots_RuntimeClass.m_goAsync; } \
        REALLY_INLINE void set_goAsync(avmplus::FunctionObject* newVal) { m_slots_RuntimeClass.m_goAsync = newVal; } \
    private: \
        avmplus::NativeID::avmshell_RuntimeClassSlots m_slots_RuntimeClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime
//-----------------------------------------------------------
class avmplus_RuntimeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RuntimeObject;
#define GC_TRIVIAL_TRACER_RuntimeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics$
//-----------------------------------------------------------
class avmshell_DiagnosticsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::DiagnosticsClass;
};
#define DECLARE_SLOTS_DiagnosticsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics
//-----------------------------------------------------------
class avmplus_DiagnosticsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DiagnosticsObject;
#define GC_TRIVIAL_TRACER_DiagnosticsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation$
//-----------------------------------------------------------
class avmshell_HardwareInformationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::HardwareInformationClass;
};
#define DECLARE_SLOTS_HardwareInformationClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation
//-----------------------------------------------------------
class avmplus_HardwareInformationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HardwareInformationObject;
#define GC_TRIVIAL_TRACER_HardwareInformationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem$
//-----------------------------------------------------------
class avmshell_OperatingSystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::OperatingSystemClass;
};
#define DECLARE_SLOTS_OperatingSystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem
//-----------------------------------------------------------
class avmplus_OperatingSystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::OperatingSystemObject;
#define GC_TRIVIAL_TRACER_OperatingSystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode$
//-----------------------------------------------------------
class avmplus_RunModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MIXED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JITORDIE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INTERP;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_MIXED);
        gc->TraceLocation(&m_JITORDIE);
        gc->TraceLocation(&m_JIT);
        gc->TraceLocation(&m_INTERP);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode
//-----------------------------------------------------------
class avmplus_RunModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeObject;
#define GC_TRIVIAL_TRACER_RunModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain$
//-----------------------------------------------------------
class avmplus_DomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainClass;
#define GC_TRIVIAL_TRACER_DomainClass
};
#define DECLARE_SLOTS_DomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::DomainObject> constructObject(GCRef<avmplus::DomainObject> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain
//-----------------------------------------------------------
class avmplus_DomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainObject;
#define GC_TRIVIAL_TRACER_DomainObject
};
#define DECLARE_SLOTS_DomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileIO$
//-----------------------------------------------------------
class avmshell_FileClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileClass;
};
#define DECLARE_SLOTS_FileClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileIOObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::FileIOObject>((avmplus::FileIOObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileIO
//-----------------------------------------------------------
class avmplus_FileIOObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileIOObject;
#define GC_TRIVIAL_TRACER_FileIOObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment$
//-----------------------------------------------------------
class avmplus_EnvironmentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentClass;
#define GC_TRIVIAL_TRACER_EnvironmentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment
//-----------------------------------------------------------
class avmplus_EnvironmentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__vars;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__idx;
    avmplus::AtomWB m_private__env;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__vars);
        gc->TraceLocation(&m_private__idx);
        gc->TraceAtom(&m_private__env);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData$
//-----------------------------------------------------------
class avmplus_BinaryDataClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataClass;
#define GC_TRIVIAL_TRACER_BinaryDataClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData
//-----------------------------------------------------------
class avmplus_BinaryDataObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataObject;
#define GC_TRIVIAL_TRACER_BinaryDataObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility$
//-----------------------------------------------------------
class avmplus_AccessibilityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityClass;
#define GC_TRIVIAL_TRACER_AccessibilityClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility
//-----------------------------------------------------------
class avmplus_AccessibilityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityObject;
#define GC_TRIVIAL_TRACER_AccessibilityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation$
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationClass;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationObject;
private:
    uint32_t m_errno;
    avmplus::bool32 m_stub;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties$
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesClass;
#define GC_TRIVIAL_TRACER_AccessibilityPropertiesClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesObject;
private:
    avmplus::bool32 m_silent;
    avmplus::bool32 m_forceSimple;
    avmplus::bool32 m_noAutoLabeling;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_description;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_shortcut;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_description);
        gc->TraceLocation(&m_shortcut);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore$
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreClass;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreObject;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType$
//-----------------------------------------------------------
class avmplus_SQLCollationTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeClass;
#define GC_TRIVIAL_TRACER_SQLCollationTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType
//-----------------------------------------------------------
class avmplus_SQLCollationTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeObject;
#define GC_TRIVIAL_TRACER_SQLCollationTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle$
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleClass;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleObject;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema$
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaClass;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaObject;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection$
//-----------------------------------------------------------
class avmplus_SQLConnectionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionClass;
#define GC_TRIVIAL_TRACER_SQLConnectionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection
//-----------------------------------------------------------
class avmplus_SQLConnectionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionObject;
#define GC_TRIVIAL_TRACER_SQLConnectionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema$
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaClass;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaObject;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode$
//-----------------------------------------------------------
class avmplus_SQLModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeClass;
#define GC_TRIVIAL_TRACER_SQLModeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode
//-----------------------------------------------------------
class avmplus_SQLModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeObject;
#define GC_TRIVIAL_TRACER_SQLModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult$
//-----------------------------------------------------------
class avmplus_SQLResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultClass;
#define GC_TRIVIAL_TRACER_SQLResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult
//-----------------------------------------------------------
class avmplus_SQLResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultObject;
#define GC_TRIVIAL_TRACER_SQLResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema$
//-----------------------------------------------------------
class avmplus_SQLSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaClass;
#define GC_TRIVIAL_TRACER_SQLSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema
//-----------------------------------------------------------
class avmplus_SQLSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaObject;
#define GC_TRIVIAL_TRACER_SQLSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult$
//-----------------------------------------------------------
class avmplus_SQLSchemaResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultClass;
#define GC_TRIVIAL_TRACER_SQLSchemaResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult
//-----------------------------------------------------------
class avmplus_SQLSchemaResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultObject;
#define GC_TRIVIAL_TRACER_SQLSchemaResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement$
//-----------------------------------------------------------
class avmplus_SQLStatementClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementClass;
#define GC_TRIVIAL_TRACER_SQLStatementClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement
//-----------------------------------------------------------
class avmplus_SQLStatementObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementObject;
#define GC_TRIVIAL_TRACER_SQLStatementObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema$
//-----------------------------------------------------------
class avmplus_SQLTableSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTableSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema
//-----------------------------------------------------------
class avmplus_SQLTableSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTableSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType$
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeClass;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeObject;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema$
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema$
//-----------------------------------------------------------
class avmplus_SQLViewSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaClass;
#define GC_TRIVIAL_TRACER_SQLViewSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema
//-----------------------------------------------------------
class avmplus_SQLViewSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaObject;
#define GC_TRIVIAL_TRACER_SQLViewSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion$
//-----------------------------------------------------------
class avmplus_ActionScriptVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionClass;
private:
    uint32_t m_ACTIONSCRIPT2;
    uint32_t m_ACTIONSCRIPT3;
#define GC_TRIVIAL_TRACER_ActionScriptVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion
//-----------------------------------------------------------
class avmplus_ActionScriptVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionObject;
#define GC_TRIVIAL_TRACER_ActionScriptVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping$
//-----------------------------------------------------------
class avmplus_PixelSnappingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEVER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ALWAYS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AUTO;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEVER);
        gc->TraceLocation(&m_ALWAYS);
        gc->TraceLocation(&m_AUTO);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping
//-----------------------------------------------------------
class avmplus_PixelSnappingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingObject;
#define GC_TRIVIAL_TRACER_PixelSnappingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions$
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsClass;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsObject;
private:
    avmplus::bool32 m_fastCompression;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene$
//-----------------------------------------------------------
class avmplus_SceneClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneClass;
#define GC_TRIVIAL_TRACER_SceneClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene
//-----------------------------------------------------------
class avmplus_SceneObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneObject;
private:
    int32_t m_private__numFrames;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__labels;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__name);
        gc->TraceLocation(&m_private__labels);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign$
//-----------------------------------------------------------
class avmplus_StageAlignClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_RIGHT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TOP);
        gc->TraceLocation(&m_LEFT);
        gc->TraceLocation(&m_BOTTOM);
        gc->TraceLocation(&m_RIGHT);
        gc->TraceLocation(&m_TOP_LEFT);
        gc->TraceLocation(&m_TOP_RIGHT);
        gc->TraceLocation(&m_BOTTOM_LEFT);
        gc->TraceLocation(&m_BOTTOM_RIGHT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign
//-----------------------------------------------------------
class avmplus_StageAlignObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignObject;
#define GC_TRIVIAL_TRACER_StageAlignObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio$
//-----------------------------------------------------------
class avmplus_StageAspectRatioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LANDSCAPE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PORTRAIT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANY);
        gc->TraceLocation(&m_LANDSCAPE);
        gc->TraceLocation(&m_PORTRAIT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio
//-----------------------------------------------------------
class avmplus_StageAspectRatioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioObject;
#define GC_TRIVIAL_TRACER_StageAspectRatioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState$
//-----------------------------------------------------------
class avmplus_StageDisplayStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN_INTERACTIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NORMAL;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_FULL_SCREEN);
        gc->TraceLocation(&m_FULL_SCREEN_INTERACTIVE);
        gc->TraceLocation(&m_NORMAL);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState
//-----------------------------------------------------------
class avmplus_StageDisplayStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateObject;
#define GC_TRIVIAL_TRACER_StageDisplayStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation$
//-----------------------------------------------------------
class avmplus_StageOrientationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEFAULT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UPSIDE_DOWN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_DEFAULT);
        gc->TraceLocation(&m_ROTATED_LEFT);
        gc->TraceLocation(&m_ROTATED_RIGHT);
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_UPSIDE_DOWN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation
//-----------------------------------------------------------
class avmplus_StageOrientationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationObject;
#define GC_TRIVIAL_TRACER_StageOrientationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality$
//-----------------------------------------------------------
class avmplus_StageQualityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MEDIUM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEST;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8_LINEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16_LINEAR;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_LOW);
        gc->TraceLocation(&m_MEDIUM);
        gc->TraceLocation(&m_HIGH);
        gc->TraceLocation(&m_BEST);
        gc->TraceLocation(&m_HIGH_8X8);
        gc->TraceLocation(&m_HIGH_8X8_LINEAR);
        gc->TraceLocation(&m_HIGH_16X16);
        gc->TraceLocation(&m_HIGH_16X16_LINEAR);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality
//-----------------------------------------------------------
class avmplus_StageQualityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityObject;
#define GC_TRIVIAL_TRACER_StageQualityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode$
//-----------------------------------------------------------
class avmplus_StageScaleModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SHOW_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXACT_FIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_BORDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_SCALE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_SHOW_ALL);
        gc->TraceLocation(&m_EXACT_FIT);
        gc->TraceLocation(&m_NO_BORDER);
        gc->TraceLocation(&m_NO_SCALE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode
//-----------------------------------------------------------
class avmplus_StageScaleModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeObject;
#define GC_TRIVIAL_TRACER_StageScaleModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion$
//-----------------------------------------------------------
class avmplus_SWFVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionClass;
private:
    uint32_t m_FLASH1;
    uint32_t m_FLASH2;
    uint32_t m_FLASH3;
    uint32_t m_FLASH4;
    uint32_t m_FLASH5;
    uint32_t m_FLASH6;
    uint32_t m_FLASH7;
    uint32_t m_FLASH8;
    uint32_t m_FLASH9;
    uint32_t m_FLASH10;
    uint32_t m_FLASH11;
    uint32_t m_FLASH12;
    uint32_t m_FLASH13;
    uint32_t m_FLASH14;
    uint32_t m_FLASH15;
    uint32_t m_FLASH16;
    uint32_t m_FLASH17;
    uint32_t m_FLASH18;
    uint32_t m_FLASH19;
#define GC_TRIVIAL_TRACER_SWFVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion
//-----------------------------------------------------------
class avmplus_SWFVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionObject;
#define GC_TRIVIAL_TRACER_SWFVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling$
//-----------------------------------------------------------
class avmplus_TriangleCullingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NONE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_POSITIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEGATIVE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NONE);
        gc->TraceLocation(&m_POSITIVE);
        gc->TraceLocation(&m_NEGATIVE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling
//-----------------------------------------------------------
class avmplus_TriangleCullingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingObject;
#define GC_TRIVIAL_TRACER_TriangleCullingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError$
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorClass;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorObject;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError$
//-----------------------------------------------------------
class avmplus_StackOverflowErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorClass;
#define GC_TRIVIAL_TRACER_StackOverflowErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError
//-----------------------------------------------------------
class avmplus_StackOverflowErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorObject;
#define GC_TRIVIAL_TRACER_StackOverflowErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError$
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorClass;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorObject;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation$
//-----------------------------------------------------------
class avmplus_SQLErrorOperationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ATTACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEGIN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMMIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPACT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DETACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXECUTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REENCRYPT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RELEASE_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK_TO_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCHEMA;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SET_SAVEPOINT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANALYZE);
        gc->TraceLocation(&m_ATTACH);
        gc->TraceLocation(&m_BEGIN);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMMIT);
        gc->TraceLocation(&m_COMPACT);
        gc->TraceLocation(&m_DEANALYZE);
        gc->TraceLocation(&m_DETACH);
        gc->TraceLocation(&m_EXECUTE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_REENCRYPT);
        gc->TraceLocation(&m_RELEASE_SAVEPOINT);
        gc->TraceLocation(&m_ROLLBACK);
        gc->TraceLocation(&m_ROLLBACK_TO_SAVEPOINT);
        gc->TraceLocation(&m_SCHEMA);
        gc->TraceLocation(&m_SET_SAVEPOINT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation
//-----------------------------------------------------------
class avmplus_SQLErrorOperationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationObject;
#define GC_TRIVIAL_TRACER_SQLErrorOperationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError$
//-----------------------------------------------------------
class avmplus_SQLErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorClass;
#define GC_TRIVIAL_TRACER_SQLErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError
//-----------------------------------------------------------
class avmplus_SQLErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorObject;
private:
    int32_t m_private__detailID;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__operation;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__details;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__detailArguments;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__operation);
        gc->TraceLocation(&m_private__details);
        gc->TraceLocation(&m_private__detailArguments);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError$
//-----------------------------------------------------------
class avmplus_DRMManagerErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorClass;
#define GC_TRIVIAL_TRACER_DRMManagerErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError
//-----------------------------------------------------------
class avmplus_DRMManagerErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorObject;
private:
    int32_t m_private__subErrorID;
#define GC_TRIVIAL_TRACER_DRMManagerErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event$
//-----------------------------------------------------------
class avmplus_EventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED_TO_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CANCEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONNECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COPY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CUT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ENTER_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_CONSTRUCTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXIT_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_LABEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ID3;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MOUSE_LEAVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PASTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED_FROM_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RESIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCROLL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXT_INTERACTION_MODE_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SOUND_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_CHILDREN_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_ENABLED_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_INDEX_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNLOAD;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULLSCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONTEXT3D_CREATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXTURE_READY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_VIDEO_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SUSPEND;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_MESSAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXITING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DISPLAYING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PREPARING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NETWORK_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_IDLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_PRESENT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_OUTPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_ERROR_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_INPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_BOUNDS_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_DOM_INITIALIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCATION_CHANGE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ACTIVATE);
        gc->TraceLocation(&m_ADDED);
        gc->TraceLocation(&m_ADDED_TO_STAGE);
        gc->TraceLocation(&m_CANCEL);
        gc->TraceLocation(&m_CHANGE);
        gc->TraceLocation(&m_CLEAR);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMPLETE);
        gc->TraceLocation(&m_CONNECT);
        gc->TraceLocation(&m_COPY);
        gc->TraceLocation(&m_CUT);
        gc->TraceLocation(&m_DEACTIVATE);
        gc->TraceLocation(&m_ENTER_FRAME);
        gc->TraceLocation(&m_FRAME_CONSTRUCTED);
        gc->TraceLocation(&m_EXIT_FRAME);
        gc->TraceLocation(&m_FRAME_LABEL);
        gc->TraceLocation(&m_ID3);
        gc->TraceLocation(&m_INIT);
        gc->TraceLocation(&m_MOUSE_LEAVE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_PASTE);
        gc->TraceLocation(&m_REMOVED);
        gc->TraceLocation(&m_REMOVED_FROM_STAGE);
        gc->TraceLocation(&m_RENDER);
        gc->TraceLocation(&m_RESIZE);
        gc->TraceLocation(&m_SCROLL);
        gc->TraceLocation(&m_TEXT_INTERACTION_MODE_CHANGE);
        gc->TraceLocation(&m_SELECT);
        gc->TraceLocation(&m_SELECT_ALL);
        gc->TraceLocation(&m_SOUND_COMPLETE);
        gc->TraceLocation(&m_TAB_CHILDREN_CHANGE);
        gc->TraceLocation(&m_TAB_ENABLED_CHANGE);
        gc->TraceLocation(&m_TAB_INDEX_CHANGE);
        gc->TraceLocation(&m_UNLOAD);
        gc->TraceLocation(&m_FULLSCREEN);
        gc->TraceLocation(&m_CONTEXT3D_CREATE);
        gc->TraceLocation(&m_TEXTURE_READY);
        gc->TraceLocation(&m_VIDEO_FRAME);
        gc->TraceLocation(&m_SUSPEND);
        gc->TraceLocation(&m_CHANNEL_MESSAGE);
        gc->TraceLocation(&m_CHANNEL_STATE);
        gc->TraceLocation(&m_WORKER_STATE);
        gc->TraceLocation(&m_CLOSING);
        gc->TraceLocation(&m_EXITING);
        gc->TraceLocation(&m_DISPLAYING);
        gc->TraceLocation(&m_PREPARING);
        gc->TraceLocation(&m_NETWORK_CHANGE);
        gc->TraceLocation(&m_USER_IDLE);
        gc->TraceLocation(&m_USER_PRESENT);
        gc->TraceLocation(&m_STANDARD_OUTPUT_CLOSE);
        gc->TraceLocation(&m_STANDARD_ERROR_CLOSE);
        gc->TraceLocation(&m_STANDARD_INPUT_CLOSE);
        gc->TraceLocation(&m_HTML_BOUNDS_CHANGE);
        gc->TraceLocation(&m_HTML_RENDER);
        gc->TraceLocation(&m_HTML_DOM_INITIALIZE);
        gc->TraceLocation(&m_LOCATION_CHANGE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event
//-----------------------------------------------------------
class avmplus_EventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventObject;
private:
    avmplus::bool32 m_private__bubbles;
    avmplus::bool32 m_private__cancelable;
    uint32_t m_private__currentphase;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__type;
    avmplus::AtomWB m_private__target;
    avmplus::AtomWB m_private__currenttarget;
    avmplus::AtomWB m_private__preventdefault;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__type);
        gc->TraceAtom(&m_private__target);
        gc->TraceAtom(&m_private__currenttarget);
        gc->TraceAtom(&m_private__preventdefault);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D$
//-----------------------------------------------------------
class avmplus_Orientation3DClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EULER_ANGLES;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AXIS_ANGLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_QUATERNION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_EULER_ANGLES);
        gc->TraceLocation(&m_AXIS_ANGLE);
        gc->TraceLocation(&m_QUATERNION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D
//-----------------------------------------------------------
class avmplus_Orientation3DObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DObject;
#define GC_TRIVIAL_TRACER_Orientation3DObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point$
//-----------------------------------------------------------
class avmplus_PointClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointClass;
#define GC_TRIVIAL_TRACER_PointClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point
//-----------------------------------------------------------
class avmplus_PointObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointObject;
private:
    double m_x;
    double m_y;
#define GC_TRIVIAL_TRACER_PointObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle$
//-----------------------------------------------------------
class avmplus_RectangleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleClass;
#define GC_TRIVIAL_TRACER_RectangleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle
//-----------------------------------------------------------
class avmplus_RectangleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleObject;
private:
    double m_x;
    double m_y;
    double m_width;
    double m_height;
#define GC_TRIVIAL_TRACER_RectangleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader$
//-----------------------------------------------------------
class avmplus_URLRequestHeaderClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderClass;
#define GC_TRIVIAL_TRACER_URLRequestHeaderClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader
//-----------------------------------------------------------
class avmplus_URLRequestHeaderObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_value;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_value);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame$
//-----------------------------------------------------------
class avmplus_StackFrameClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameClass;
#define GC_TRIVIAL_TRACER_StackFrameClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame
//-----------------------------------------------------------
class avmplus_StackFrameObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameObject;
private:
    uint32_t m_line;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_file;
    double m_scriptID;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_file);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample$
//-----------------------------------------------------------
class avmplus_SampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleClass;
#define GC_TRIVIAL_TRACER_SampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample
//-----------------------------------------------------------
class avmplus_SampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_stack;
    double m_time;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_stack);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory$
//-----------------------------------------------------------
class avmplus_ClassFactoryClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_StackFrameClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_SampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_DeleteObjectSampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_NewObjectSampleClass;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_StackFrameClass);
        gc->TraceLocation(&m_SampleClass);
        gc->TraceLocation(&m_DeleteObjectSampleClass);
        gc->TraceLocation(&m_NewObjectSampleClass);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory
//-----------------------------------------------------------
class avmplus_ClassFactoryObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryObject;
#define GC_TRIVIAL_TRACER_ClassFactoryObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities$
//-----------------------------------------------------------
class avmplus_CapabilitiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesClass;
#define GC_TRIVIAL_TRACER_CapabilitiesClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities
//-----------------------------------------------------------
class avmplus_CapabilitiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesObject;
#define GC_TRIVIAL_TRACER_CapabilitiesObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System$
//-----------------------------------------------------------
class avmshell_SystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::SystemClass;
private:
    avmplus::bool32 m_private__useCodePage;
};
#define DECLARE_SLOTS_SystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE bool get__useCodePage() const { return m_slots_SystemClass.m_private__useCodePage != 0; } \
        REALLY_INLINE void set__useCodePage(avmplus::bool32 newVal) { m_slots_SystemClass.m_private__useCodePage = newVal; } \
    private: \
        avmplus::NativeID::avmshell_SystemClassSlots m_slots_SystemClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System
//-----------------------------------------------------------
class avmplus_SystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SystemObject;
#define GC_TRIVIAL_TRACER_SystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState$
//-----------------------------------------------------------
class avmplus_WorkerStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RUNNING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TERMINATED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FAILED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ABORTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXCEPTION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEW);
        gc->TraceLocation(&m_RUNNING);
        gc->TraceLocation(&m_TERMINATED);
        gc->TraceLocation(&m_FAILED);
        gc->TraceLocation(&m_ABORTED);
        gc->TraceLocation(&m_EXCEPTION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState
//-----------------------------------------------------------
class avmplus_WorkerStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateObject;
#define GC_TRIVIAL_TRACER_WorkerStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker$
//-----------------------------------------------------------
class avmshell_ShellWorkerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct_native(avmshell::ShellWorkerClass::createInstanceProc, 0, args); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerObject* get_m_current() const { return m_slots_ShellWorkerClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerObject* newVal) { m_slots_ShellWorkerClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerClassSlots m_slots_ShellWorkerClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker
//-----------------------------------------------------------
class avmshell_ShellWorkerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ByteArrayObject> m_private_m_byteCode;
};
#define DECLARE_SLOTS_ShellWorkerObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::ByteArrayObject* get_m_byteCode() const { return m_slots_ShellWorkerObject.m_private_m_byteCode; } \
        REALLY_INLINE void set_m_byteCode(avmplus::ByteArrayObject* newVal) { m_slots_ShellWorkerObject.m_private_m_byteCode = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerObjectSlots m_slots_ShellWorkerObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent$
//-----------------------------------------------------------
class avmplus_WorkerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_WORKER_STATE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent
//-----------------------------------------------------------
class avmplus_WorkerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_previousState;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_currentState;
    avmplus::AtomWB m_flash_system_m_target;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private_m_previousState);
        gc->TraceLocation(&m_private_m_currentState);
        gc->TraceAtom(&m_flash_system_m_target);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain$
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerDomainObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerDomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerDomainObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerDomainObject* get_m_current() const { return m_slots_ShellWorkerDomainClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerDomainObject* newVal) { m_slots_ShellWorkerDomainClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerDomainClassSlots m_slots_ShellWorkerDomainClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainObject;
};
#define DECLARE_SLOTS_ShellWorkerDomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace$
//-----------------------------------------------------------
class avmplus_TraceClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceClass;
private:
    int32_t m_OFF;
    int32_t m_METHODS;
    int32_t m_METHODS_WITH_ARGS;
    int32_t m_METHODS_AND_LINES;
    int32_t m_METHODS_AND_LINES_WITH_ARGS;
    avmplus::AtomWB m_FILE;
    avmplus::AtomWB m_LISTENER;
};
#define DECLARE_SLOTS_TraceClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_OFF() const { return m_slots_TraceClass.m_OFF; } \
        REALLY_INLINE void setconst_OFF(int32_t newVal) { m_slots_TraceClass.m_OFF = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS() const { return m_slots_TraceClass.m_METHODS; } \
        REALLY_INLINE void setconst_METHODS(int32_t newVal) { m_slots_TraceClass.m_METHODS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES() const { return m_slots_TraceClass.m_METHODS_AND_LINES; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_FILE() const { return m_slots_TraceClass.m_FILE; } \
        REALLY_INLINE void setconst_FILE(avmplus::Atom newVal) { m_slots_TraceClass.m_FILE = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_LISTENER() const { return m_slots_TraceClass.m_LISTENER; } \
        REALLY_INLINE void setconst_LISTENER(avmplus::Atom newVal) { m_slots_TraceClass.m_LISTENER = newVal; } \
    private: \
        avmplus::NativeID::avmplus_TraceClassSlots m_slots_TraceClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace
//-----------------------------------------------------------
class avmplus_TraceObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceObject;
#define GC_TRIVIAL_TRACER_TraceObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian$
//-----------------------------------------------------------
class avmplus_EndianClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BIG_ENDIAN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LITTLE_ENDIAN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_BIG_ENDIAN);
        gc->TraceLocation(&m_LITTLE_ENDIAN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian
//-----------------------------------------------------------
class avmplus_EndianObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianObject;
#define GC_TRIVIAL_TRACER_EndianObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop$
//-----------------------------------------------------------
class avmplus_CoreEventLoopClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopClass;
#define GC_TRIVIAL_TRACER_CoreEventLoopClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop
//-----------------------------------------------------------
class avmplus_CoreEventLoopObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopObject;
private:
    avmplus::bool32 m_private__running;
    uint32_t m_private__frequency;
    uint32_t m_private__started;
    uint32_t m_private__elapsed;
    uint32_t m_private__frame;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__timers;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__callback;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__timers);
        gc->TraceLocation(&m_private__callback);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher$
//-----------------------------------------------------------
class avmplus_EventDispatcherClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectlist;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectmap;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m__objectlist);
        gc->TraceLocation(&m__objectmap);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher
//-----------------------------------------------------------
class avmplus_EventDispatcherObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::IEventDispatcherInterface> m_private__target;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listeners;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersNames;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersCalls;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__target);
        gc->TraceLocation(&m__listeners);
        gc->TraceLocation(&m__listenersNames);
        gc->TraceLocation(&m__listenersCalls);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent$
//-----------------------------------------------------------
class avmplus_HTTPStatusEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_STATUS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_RESPONSE_STATUS;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_HTTP_STATUS);
        gc->TraceLocation(&m_HTTP_RESPONSE_STATUS);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent
//-----------------------------------------------------------
class avmplus_HTTPStatusEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventObject;
private:
    int32_t m_private__status;
    avmplus::bool32 m_private__redirected;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__responseHeaders;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__responseUrl;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__responseHeaders);
        gc->TraceLocation(&m_private__responseUrl);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent$
//-----------------------------------------------------------
class avmplus_TimerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER_COMPLETE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TIMER);
        gc->TraceLocation(&m_TIMER_COMPLETE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent
//-----------------------------------------------------------
class avmplus_TimerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventObject;
#define GC_TRIVIAL_TRACER_TimerEventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample$
//-----------------------------------------------------------
class avmplus_NewObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleClass;
};
#define DECLARE_SLOTS_NewObjectSampleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::NewObjectSampleObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample
//-----------------------------------------------------------
class avmplus_NewObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_type;
    double m_id;
};
#define DECLARE_SLOTS_NewObjectSampleObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE avmplus::ClassClosure* get_type() const { return m_slots_NewObjectSampleObject.m_type; } \
        REALLY_INLINE void setconst_type(avmplus::ClassClosure* newVal) { m_slots_NewObjectSampleObject.m_type = newVal; } \
    public: \
        REALLY_INLINE double get_id() const { return m_slots_NewObjectSampleObject.m_id; } \
        REALLY_INLINE void setconst_id(double newVal) { m_slots_NewObjectSampleObject.m_id = newVal; } \
    private: \
        avmplus::NativeID::avmplus_NewObjectSampleObjectSlots m_slots_NewObjectSampleObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample$
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleClass;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleObject;
private:
    double m_id;
    double m_size;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer$
//-----------------------------------------------------------
class avmplus_TimerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerClass;
#define GC_TRIVIAL_TRACER_TimerClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer
//-----------------------------------------------------------
class avmplus_TimerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerObject;
private:
    int32_t m_private__repeatCount;
    int32_t m_private__iteration;
    avmplus::bool32 m_private__running;
    uint32_t m__started;
    uint32_t m__elapsed;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__closure;
    double m_private__delay;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__closure);
    }
};
//-----------------------------------------------------------

} }
namespace avmplus {

class shell_toplevelClassManifest : public avmplus::ClassManifestBase
{
    friend class avmplus::AvmCore;
    friend class avmplus::IntVectorClass;
    friend class avmplus::UIntVectorClass;
    FLOAT_ONLY(friend class avmplus::FloatVectorClass;)
    FLOAT_ONLY(friend class avmplus::Float4VectorClass;)
    friend class avmplus::DoubleVectorClass;
    friend class avmplus::ObjectVectorClass;
private:
    REALLY_INLINE shell_toplevelClassManifest(avmplus::ScriptEnv* e) : ClassManifestBase(118, e) { }
    REALLY_INLINE static shell_toplevelClassManifest* create(avmplus::ScriptEnv* e) { return new (MMgc::GC::GetGC(e), MMgc::kExact, sizeof(ClassClosure*)*117) shell_toplevelClassManifest(e); }
public:
    REALLY_INLINE GCRef<avmplus::AccessibilityClass> get_AccessibilityClass() { return (avmplus::AccessibilityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_Accessibility)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityImplementationClass> get_AccessibilityImplementationClass() { return (avmplus::AccessibilityImplementationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityImplementation)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityPropertiesClass> get_AccessibilityPropertiesClass() { return (avmplus::AccessibilityPropertiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityProperties)); }
    REALLY_INLINE GCRef<avmplus::ActionScriptVersionClass> get_ActionScriptVersionClass() { return (avmplus::ActionScriptVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_ActionScriptVersion)); }
    REALLY_INLINE GCRef<avmplus::BinaryDataClass> get_BinaryDataClass() { return (avmplus::BinaryDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_BinaryData)); }
    REALLY_INLINE GCRef<avmplus::CErrorClass> get_CErrorClass() { return (avmplus::CErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_CError)); }
    REALLY_INLINE GCRef<avmplus::CapabilitiesClass> get_CapabilitiesClass() { return (avmplus::CapabilitiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Capabilities)); }
    REALLY_INLINE GCRef<avmplus::ClassFactoryClass> get_ClassFactoryClass() { return (avmplus::ClassFactoryClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_ClassFactory)); }
    REALLY_INLINE GCRef<avmplus::CoreEventLoopClass> get_CoreEventLoopClass() { return (avmplus::CoreEventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_CoreEventLoop)); }
    REALLY_INLINE GCRef<avmplus::DRMManagerErrorClass> get_DRMManagerErrorClass() { return (avmplus::DRMManagerErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_DRMManagerError)); }
    REALLY_INLINE GCRef<avmplus::DeleteObjectSampleClass> get_DeleteObjectSampleClass() { return (avmplus::DeleteObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_DeleteObjectSample)); }
    REALLY_INLINE GCRef<avmshell::DiagnosticsClass> get_DiagnosticsClass() { return (avmshell::DiagnosticsClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Diagnostics)); }
    REALLY_INLINE GCRef<avmplus::DomainClass> get_DomainClass() { return (avmplus::DomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Domain)); }
    REALLY_INLINE GCRef<avmplus::EncryptedLocalStoreClass> get_EncryptedLocalStoreClass() { return (avmplus::EncryptedLocalStoreClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_EncryptedLocalStore)); }
    REALLY_INLINE GCRef<avmplus::EndianClass> get_EndianClass() { return (avmplus::EndianClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Endian)); }
    REALLY_INLINE GCRef<avmplus::EnvironmentClass> get_EnvironmentClass() { return (avmplus::EnvironmentClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Environment)); }
    REALLY_INLINE GCRef<avmplus::ErrorNumberClass> get_ErrorNumberClass() { return (avmplus::ErrorNumberClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_ErrorNumber)); }
    REALLY_INLINE GCRef<avmplus::EventClass> get_EventClass() { return (avmplus::EventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_Event)); }
    REALLY_INLINE GCRef<avmplus::EventDispatcherClass> get_EventDispatcherClass() { return (avmplus::EventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_EventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::EventLoopClass> get_EventLoopClass() { return (avmplus::EventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_EventLoop)); }
    REALLY_INLINE GCRef<avmshell::CFILEClass> get_FILEClass() { return (avmshell::CFILEClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_FILE)); }
    REALLY_INLINE GCRef<avmshell::FileClass> get_FileIOClass() { return (avmshell::FileClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_FileIO)); }
    REALLY_INLINE GCRef<avmplus::HTTPStatusEventClass> get_HTTPStatusEventClass() { return (avmplus::HTTPStatusEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_HTTPStatusEvent)); }
    REALLY_INLINE GCRef<avmshell::HardwareInformationClass> get_HardwareInformationClass() { return (avmshell::HardwareInformationClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_HardwareInformation)); }
    REALLY_INLINE GCRef<avmplus::IBitmapDrawableClass> get_IBitmapDrawableClass() { return (avmplus::IBitmapDrawableClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IBitmapDrawable)); }
    REALLY_INLINE GCRef<avmplus::IDrawCommandClass> get_IDrawCommandClass() { return (avmplus::IDrawCommandClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IDrawCommand)); }
    REALLY_INLINE GCRef<avmplus::IEventDispatcherClass> get_IEventDispatcherClass() { return (avmplus::IEventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_IEventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsDataClass> get_IGraphicsDataClass() { return (avmplus::IGraphicsDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsData)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsFillClass> get_IGraphicsFillClass() { return (avmplus::IGraphicsFillClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsFill)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsPathClass> get_IGraphicsPathClass() { return (avmplus::IGraphicsPathClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsPath)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsStrokeClass> get_IGraphicsStrokeClass() { return (avmplus::IGraphicsStrokeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsStroke)); }
    REALLY_INLINE GCRef<avmplus::ISearchableTextClass> get_ISearchableTextClass() { return (avmplus::ISearchableTextClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISearchableText)); }
    REALLY_INLINE GCRef<avmplus::ISimpleTextSelectionClass> get_ISimpleTextSelectionClass() { return (avmplus::ISimpleTextSelectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISimpleTextSelection)); }
    REALLY_INLINE GCRef<avmplus::InvalidSWFErrorClass> get_InvalidSWFErrorClass() { return (avmplus::InvalidSWFErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_InvalidSWFError)); }
    REALLY_INLINE GCRef<avmplus::NewObjectSampleClass> get_NewObjectSampleClass() { return (avmplus::NewObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_NewObjectSample)); }
    REALLY_INLINE GCRef<avmshell::OperatingSystemClass> get_OperatingSystemClass() { return (avmshell::OperatingSystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_OperatingSystem)); }
    REALLY_INLINE GCRef<avmplus::Orientation3DClass> get_Orientation3DClass() { return (avmplus::Orientation3DClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Orientation3D)); }
    REALLY_INLINE GCRef<avmplus::PNGEncoderOptionsClass> get_PNGEncoderOptionsClass() { return (avmplus::PNGEncoderOptionsClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PNGEncoderOptions)); }
    REALLY_INLINE GCRef<avmplus::PixelSnappingClass> get_PixelSnappingClass() { return (avmplus::PixelSnappingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PixelSnapping)); }
    REALLY_INLINE GCRef<avmplus::PointClass> get_PointClass() { return (avmplus::PointClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Point)); }
    REALLY_INLINE GCRef<avmshell::ProgramClass> get_ProgramClass() { return (avmshell::ProgramClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Program)); }
    REALLY_INLINE GCRef<avmplus::RectangleClass> get_RectangleClass() { return (avmplus::RectangleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Rectangle)); }
    REALLY_INLINE GCRef<avmplus::RunModeClass> get_RunModeClass() { return (avmplus::RunModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_RunMode)); }
    REALLY_INLINE GCRef<avmshell::RuntimeClass> get_RuntimeClass() { return (avmshell::RuntimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Runtime)); }
    REALLY_INLINE GCRef<avmplus::SQLCollationTypeClass> get_SQLCollationTypeClass() { return (avmplus::SQLCollationTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLCollationType)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnNameStyleClass> get_SQLColumnNameStyleClass() { return (avmplus::SQLColumnNameStyleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnNameStyle)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnSchemaClass> get_SQLColumnSchemaClass() { return (avmplus::SQLColumnSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLConnectionClass> get_SQLConnectionClass() { return (avmplus::SQLConnectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLConnection)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorClass> get_SQLErrorClass() { return (avmplus::SQLErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLError)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorOperationClass> get_SQLErrorOperationClass() { return (avmplus::SQLErrorOperationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLErrorOperation)); }
    REALLY_INLINE GCRef<avmplus::SQLIndexSchemaClass> get_SQLIndexSchemaClass() { return (avmplus::SQLIndexSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLIndexSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLModeClass> get_SQLModeClass() { return (avmplus::SQLModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLMode)); }
    REALLY_INLINE GCRef<avmplus::SQLResultClass> get_SQLResultClass() { return (avmplus::SQLResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLResult)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaClass> get_SQLSchemaClass() { return (avmplus::SQLSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaResultClass> get_SQLSchemaResultClass() { return (avmplus::SQLSchemaResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchemaResult)); }
    REALLY_INLINE GCRef<avmplus::SQLStatementClass> get_SQLStatementClass() { return (avmplus::SQLStatementClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLStatement)); }
    REALLY_INLINE GCRef<avmplus::SQLTableSchemaClass> get_SQLTableSchemaClass() { return (avmplus::SQLTableSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTableSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLTransactionLockTypeClass> get_SQLTransactionLockTypeClass() { return (avmplus::SQLTransactionLockTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTransactionLockType)); }
    REALLY_INLINE GCRef<avmplus::SQLTriggerSchemaClass> get_SQLTriggerSchemaClass() { return (avmplus::SQLTriggerSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTriggerSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLViewSchemaClass> get_SQLViewSchemaClass() { return (avmplus::SQLViewSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLViewSchema)); }
    REALLY_INLINE GCRef<avmplus::SWFVersionClass> get_SWFVersionClass() { return (avmplus::SWFVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_SWFVersion)); }
    REALLY_INLINE GCRef<avmplus::SampleClass> get_SampleClass() { return (avmplus::SampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_Sample)); }
    REALLY_INLINE GCRef<avmplus::SceneClass> get_SceneClass() { return (avmplus::SceneClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_Scene)); }
    REALLY_INLINE GCRef<avmplus::ScriptTimeoutErrorClass> get_ScriptTimeoutErrorClass() { return (avmplus::ScriptTimeoutErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_ScriptTimeoutError)); }
    REALLY_INLINE GCRef<avmplus::StackFrameClass> get_StackFrameClass() { return (avmplus::StackFrameClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_StackFrame)); }
    REALLY_INLINE GCRef<avmplus::StackOverflowErrorClass> get_StackOverflowErrorClass() { return (avmplus::StackOverflowErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_StackOverflowError)); }
    REALLY_INLINE GCRef<avmplus::StageAlignClass> get_StageAlignClass() { return (avmplus::StageAlignClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAlign)); }
    REALLY_INLINE GCRef<avmplus::StageAspectRatioClass> get_StageAspectRatioClass() { return (avmplus::StageAspectRatioClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAspectRatio)); }
    REALLY_INLINE GCRef<avmplus::StageDisplayStateClass> get_StageDisplayStateClass() { return (avmplus::StageDisplayStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageDisplayState)); }
    REALLY_INLINE GCRef<avmplus::StageOrientationClass> get_StageOrientationClass() { return (avmplus::StageOrientationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageOrientation)); }
    REALLY_INLINE GCRef<avmplus::StageQualityClass> get_StageQualityClass() { return (avmplus::StageQualityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageQuality)); }
    REALLY_INLINE GCRef<avmplus::StageScaleModeClass> get_StageScaleModeClass() { return (avmplus::StageScaleModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageScaleMode)); }
    REALLY_INLINE GCRef<avmshell::SystemClass> get_SystemClass() { return (avmshell::SystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_System)); }
    REALLY_INLINE GCRef<avmplus::TimerClass> get_TimerClass() { return (avmplus::TimerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Timer)); }
    REALLY_INLINE GCRef<avmplus::TimerEventClass> get_TimerEventClass() { return (avmplus::TimerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_TimerEvent)); }
    REALLY_INLINE GCRef<avmplus::TraceClass> get_TraceClass() { return (avmplus::TraceClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_trace_Trace)); }
    REALLY_INLINE GCRef<avmplus::TriangleCullingClass> get_TriangleCullingClass() { return (avmplus::TriangleCullingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_TriangleCulling)); }
    REALLY_INLINE GCRef<avmplus::URLRequestHeaderClass> get_URLRequestHeaderClass() { return (avmplus::URLRequestHeaderClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_URLRequestHeader)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerClass> get_WorkerClass() { return (avmshell::ShellWorkerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Worker)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerDomainClass> get_WorkerDomainClass() { return (avmshell::ShellWorkerDomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerDomain)); }
    REALLY_INLINE GCRef<avmplus::WorkerEventClass> get_WorkerEventClass() { return (avmplus::WorkerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerEvent)); }
    REALLY_INLINE GCRef<avmplus::WorkerStateClass> get_WorkerStateClass() { return (avmplus::WorkerStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerState)); }
    REALLY_INLINE GCRef<avmshell::CFcntlClass> get___fcntlClass() { return (avmshell::CFcntlClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_fcntl___fcntl)); }
    REALLY_INLINE GCRef<avmshell::CLimitsClass> get___limitsClass() { return (avmshell::CLimitsClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_limits___limits)); }
    REALLY_INLINE GCRef<avmshell::CLocaleClass> get___localeClass() { return (avmshell::CLocaleClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_locale___locale)); }
    REALLY_INLINE GCRef<avmshell::CNetdbClass> get___netdbClass() { return (avmshell::CNetdbClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb___netdb)); }
    REALLY_INLINE GCRef<avmshell::CNetinetInClass> get___netinetClass() { return (avmshell::CNetinetInClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet___netinet)); }
    REALLY_INLINE GCRef<avmshell::CSignalClass> get___signalClass() { return (avmshell::CSignalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal___signal)); }
    REALLY_INLINE GCRef<avmshell::CSysSocketClass> get___socketClass() { return (avmshell::CSysSocketClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket___socket)); }
    REALLY_INLINE GCRef<avmshell::CSysStatClass> get___statClass() { return (avmshell::CSysStatClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat___stat)); }
    REALLY_INLINE GCRef<avmshell::CStdioClass> get___stdioClass() { return (avmshell::CStdioClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio___stdio)); }
    REALLY_INLINE GCRef<avmshell::CStdlibClass> get___stdlibClass() { return (avmshell::CStdlibClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib___stdlib)); }
    REALLY_INLINE GCRef<avmshell::CTimeClass> get___timeClass() { return (avmshell::CTimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time___time)); }
    REALLY_INLINE GCRef<avmshell::CUnistdClass> get___unistdClass() { return (avmshell::CUnistdClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_unistd___unistd)); }
    REALLY_INLINE GCRef<avmshell::CSysWaitClass> get___waitClass() { return (avmshell::CSysWaitClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait___wait)); }
    REALLY_INLINE GCRef<avmplus::addrinfoClass> get_addrinfoClass() { return (avmplus::addrinfoClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_addrinfo)); }
    REALLY_INLINE GCRef<avmshell::Cdiv_tClass> get_div_tClass() { return (avmshell::Cdiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_div_t)); }
    REALLY_INLINE GCRef<avmshell::Cfpos_tClass> get_fpos_tClass() { return (avmshell::Cfpos_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_fpos_t)); }
    REALLY_INLINE GCRef<avmshell::ChostentClass> get_hostentClass() { return (avmshell::ChostentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_hostent)); }
    REALLY_INLINE GCRef<avmplus::in6_addrClass> get_in6_addrClass() { return (avmplus::in6_addrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in6_addr)); }
    REALLY_INLINE GCRef<avmplus::in_addrClass> get_in_addrClass() { return (avmplus::in_addrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in_addr)); }
    REALLY_INLINE GCRef<avmplus::ipv6_mreqClass> get_ipv6_mreqClass() { return (avmplus::ipv6_mreqClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_ipv6_mreq)); }
    REALLY_INLINE GCRef<avmshell::Cldiv_tClass> get_ldiv_tClass() { return (avmshell::Cldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_ldiv_t)); }
    REALLY_INLINE GCRef<avmshell::Clldiv_tClass> get_lldiv_tClass() { return (avmshell::Clldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_lldiv_t)); }
    REALLY_INLINE GCRef<avmplus::msghdrClass> get_msghdrClass() { return (avmplus::msghdrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_msghdr)); }
    REALLY_INLINE GCRef<avmplus::netentClass> get_netentClass() { return (avmplus::netentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_netent)); }
    REALLY_INLINE GCRef<avmshell::Cpid_tClass> get_pid_tClass() { return (avmshell::Cpid_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_spawn_pid_t)); }
    REALLY_INLINE GCRef<avmshell::CprotoentClass> get_protoentClass() { return (avmshell::CprotoentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_protoent)); }
    REALLY_INLINE GCRef<avmplus::serventClass> get_serventClass() { return (avmplus::serventClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_servent)); }
    REALLY_INLINE GCRef<avmshell::Csiginfo_tClass> get_siginfo_tClass() { return (avmshell::Csiginfo_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_siginfo_t)); }
    REALLY_INLINE GCRef<avmshell::CsigvalClass> get_sigvalClass() { return (avmshell::CsigvalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_sigval)); }
    REALLY_INLINE GCRef<avmplus::sockaddrClass> get_sockaddrClass() { return (avmplus::sockaddrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_in6Class> get_sockaddr_in6Class() { return (avmplus::sockaddr_in6Class*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in6)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_inClass> get_sockaddr_inClass() { return (avmplus::sockaddr_inClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_storageClass> get_sockaddr_storageClass() { return (avmplus::sockaddr_storageClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr_storage)); }
    REALLY_INLINE GCRef<avmplus::sockdClass> get_sockdClass() { return (avmplus::sockdClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockd)); }
    REALLY_INLINE GCRef<avmshell::CStatusClass> get_statusClass() { return (avmshell::CStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat_status)); }
    REALLY_INLINE GCRef<avmshell::CWaitStatusClass> get_wait_statusClass() { return (avmshell::CWaitStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait_wait_status)); }
};
}
#endif // _H_nativegen_header_shell_toplevel
