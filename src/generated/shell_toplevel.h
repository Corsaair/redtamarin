/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* machine generated file -- do not edit */

#ifndef _H_nativegen_header_shell_toplevel
#define _H_nativegen_header_shell_toplevel

namespace avmplus {
    class AccessibilityClass; // flash.accessibility::Accessibility$
    class AccessibilityImplementationClass; // flash.accessibility::AccessibilityImplementation$
    class AccessibilityImplementationObject; // flash.accessibility::AccessibilityImplementation
    class AccessibilityObject; // flash.accessibility::Accessibility
    class AccessibilityPropertiesClass; // flash.accessibility::AccessibilityProperties$
    class AccessibilityPropertiesObject; // flash.accessibility::AccessibilityProperties
    class ActionScriptVersionClass; // flash.display::ActionScriptVersion$
    class ActionScriptVersionObject; // flash.display::ActionScriptVersion
    class ArrayObject; // Array
    class BinaryDataClass; // shell::BinaryData$
    class BinaryDataObject; // shell::BinaryData
    class ByteArrayObject; // flash.utils::ByteArray
    class CapabilitiesClass; // flash.system::Capabilities$
    class CapabilitiesObject; // flash.system::Capabilities
    class ClassClosure; // Class
    class ClassFactoryClass; // flash.sampler::ClassFactory$
    class ClassFactoryObject; // flash.sampler::ClassFactory
    class CoreEventLoopClass; // shell.async::CoreEventLoop$
    class CoreEventLoopObject; // shell.async::CoreEventLoop
    class DRMManagerErrorClass; // flash.errors::DRMManagerError$
    class DRMManagerErrorObject; // flash.errors::DRMManagerError
    class DeleteObjectSampleClass; // flash.sampler::DeleteObjectSample$
    class DeleteObjectSampleObject; // flash.sampler::DeleteObjectSample
    class DiagnosticsObject; // shell::Diagnostics
    class DomainClass; // shell::Domain$
    class DomainObject; // shell::Domain
    class EncryptedLocalStoreClass; // flash.data::EncryptedLocalStore$
    class EncryptedLocalStoreObject; // flash.data::EncryptedLocalStore
    class EndianClass; // flash.utils::Endian$
    class EndianObject; // flash.utils::Endian
    class EnvironmentClass; // shell::Environment$
    class EnvironmentObject; // shell::Environment
    class ErrorNumberClass; // C.errno::ErrorNumber$
    class ErrorNumberObject; // C.errno::ErrorNumber
    class EventClass; // flash.events::Event$
    class EventDispatcherClass; // flash.events::EventDispatcher$
    class EventDispatcherObject; // flash.events::EventDispatcher
    class EventLoopClass; // shell.async::EventLoop$
    class EventLoopInterface; // shell.async::EventLoop
    class EventObject; // flash.events::Event
    class FileModeClass; // flash.filesystem::FileMode$
    class FileModeObject; // flash.filesystem::FileMode
    class FileStreamClass; // flash.filesystem::FileStream$
    class FileStreamObject; // flash.filesystem::FileStream
    class FileSystemObject; // shell::FileSystem
    class FunctionObject; // Function
    class HTTPStatusEventClass; // flash.events::HTTPStatusEvent$
    class HTTPStatusEventObject; // flash.events::HTTPStatusEvent
    class HardwareInformationObject; // shell::HardwareInformation
    class IBitmapDrawableClass; // flash.display::IBitmapDrawable$
    class IBitmapDrawableInterface; // flash.display::IBitmapDrawable
    class IDrawCommandClass; // flash.display::IDrawCommand$
    class IDrawCommandInterface; // flash.display::IDrawCommand
    class IEventDispatcherClass; // flash.events::IEventDispatcher$
    class IEventDispatcherInterface; // flash.events::IEventDispatcher
    class IGraphicsDataClass; // flash.display::IGraphicsData$
    class IGraphicsDataInterface; // flash.display::IGraphicsData
    class IGraphicsFillClass; // flash.display::IGraphicsFill$
    class IGraphicsFillInterface; // flash.display::IGraphicsFill
    class IGraphicsPathClass; // flash.display::IGraphicsPath$
    class IGraphicsPathInterface; // flash.display::IGraphicsPath
    class IGraphicsStrokeClass; // flash.display::IGraphicsStroke$
    class IGraphicsStrokeInterface; // flash.display::IGraphicsStroke
    class ISearchableTextClass; // flash.accessibility::ISearchableText$
    class ISearchableTextInterface; // flash.accessibility::ISearchableText
    class ISimpleTextSelectionClass; // flash.accessibility::ISimpleTextSelection$
    class ISimpleTextSelectionInterface; // flash.accessibility::ISimpleTextSelection
    class InvalidSWFErrorClass; // flash.errors::InvalidSWFError$
    class InvalidSWFErrorObject; // flash.errors::InvalidSWFError
    class NewObjectSampleClass; // flash.sampler::NewObjectSample$
    class NewObjectSampleObject; // flash.sampler::NewObjectSample
    class OperatingSystemObject; // shell::OperatingSystem
    class Orientation3DClass; // flash.geom::Orientation3D$
    class Orientation3DObject; // flash.geom::Orientation3D
    class PNGEncoderOptionsClass; // flash.display::PNGEncoderOptions$
    class PNGEncoderOptionsObject; // flash.display::PNGEncoderOptions
    class PixelSnappingClass; // flash.display::PixelSnapping$
    class PixelSnappingObject; // flash.display::PixelSnapping
    class PointClass; // flash.geom::Point$
    class PointObject; // flash.geom::Point
    class ProgramObject; // shell::Program
    class RectangleClass; // flash.geom::Rectangle$
    class RectangleObject; // flash.geom::Rectangle
    class RegExpObject; // RegExp
    class RunModeClass; // shell::RunMode$
    class RunModeObject; // shell::RunMode
    class RuntimeObject; // shell::Runtime
    class SQLCollationTypeClass; // flash.data::SQLCollationType$
    class SQLCollationTypeObject; // flash.data::SQLCollationType
    class SQLColumnNameStyleClass; // flash.data::SQLColumnNameStyle$
    class SQLColumnNameStyleObject; // flash.data::SQLColumnNameStyle
    class SQLColumnSchemaClass; // flash.data::SQLColumnSchema$
    class SQLColumnSchemaObject; // flash.data::SQLColumnSchema
    class SQLConnectionClass; // flash.data::SQLConnection$
    class SQLConnectionObject; // flash.data::SQLConnection
    class SQLErrorClass; // flash.errors::SQLError$
    class SQLErrorObject; // flash.errors::SQLError
    class SQLErrorOperationClass; // flash.errors::SQLErrorOperation$
    class SQLErrorOperationObject; // flash.errors::SQLErrorOperation
    class SQLIndexSchemaClass; // flash.data::SQLIndexSchema$
    class SQLIndexSchemaObject; // flash.data::SQLIndexSchema
    class SQLModeClass; // flash.data::SQLMode$
    class SQLModeObject; // flash.data::SQLMode
    class SQLResultClass; // flash.data::SQLResult$
    class SQLResultObject; // flash.data::SQLResult
    class SQLSchemaClass; // flash.data::SQLSchema$
    class SQLSchemaObject; // flash.data::SQLSchema
    class SQLSchemaResultClass; // flash.data::SQLSchemaResult$
    class SQLSchemaResultObject; // flash.data::SQLSchemaResult
    class SQLStatementClass; // flash.data::SQLStatement$
    class SQLStatementObject; // flash.data::SQLStatement
    class SQLTableSchemaClass; // flash.data::SQLTableSchema$
    class SQLTableSchemaObject; // flash.data::SQLTableSchema
    class SQLTransactionLockTypeClass; // flash.data::SQLTransactionLockType$
    class SQLTransactionLockTypeObject; // flash.data::SQLTransactionLockType
    class SQLTriggerSchemaClass; // flash.data::SQLTriggerSchema$
    class SQLTriggerSchemaObject; // flash.data::SQLTriggerSchema
    class SQLViewSchemaClass; // flash.data::SQLViewSchema$
    class SQLViewSchemaObject; // flash.data::SQLViewSchema
    class SWFVersionClass; // flash.display::SWFVersion$
    class SWFVersionObject; // flash.display::SWFVersion
    class SampleClass; // flash.sampler::Sample$
    class SampleObject; // flash.sampler::Sample
    class SceneClass; // flash.display::Scene$
    class SceneObject; // flash.display::Scene
    class ScriptTimeoutErrorClass; // flash.errors::ScriptTimeoutError$
    class ScriptTimeoutErrorObject; // flash.errors::ScriptTimeoutError
    class SecurityClass; // flash.system::Security$
    class SecurityObject; // flash.system::Security
    class SecurityPrivilegeClass; // flash.system::SecurityPrivilege$
    class SecurityPrivilegeObject; // flash.system::SecurityPrivilege
    class StackFrameClass; // flash.sampler::StackFrame$
    class StackFrameObject; // flash.sampler::StackFrame
    class StackOverflowErrorClass; // flash.errors::StackOverflowError$
    class StackOverflowErrorObject; // flash.errors::StackOverflowError
    class StageAlignClass; // flash.display::StageAlign$
    class StageAlignObject; // flash.display::StageAlign
    class StageAspectRatioClass; // flash.display::StageAspectRatio$
    class StageAspectRatioObject; // flash.display::StageAspectRatio
    class StageDisplayStateClass; // flash.display::StageDisplayState$
    class StageDisplayStateObject; // flash.display::StageDisplayState
    class StageOrientationClass; // flash.display::StageOrientation$
    class StageOrientationObject; // flash.display::StageOrientation
    class StageQualityClass; // flash.display::StageQuality$
    class StageQualityObject; // flash.display::StageQuality
    class StageScaleModeClass; // flash.display::StageScaleMode$
    class StageScaleModeObject; // flash.display::StageScaleMode
    class String; // String
    class SystemObject; // flash.system::System
    class TimerClass; // flash.utils::Timer$
    class TimerEventClass; // flash.events::TimerEvent$
    class TimerEventObject; // flash.events::TimerEvent
    class TimerObject; // flash.utils::Timer
    class TraceClass; // flash.trace::Trace$
    class TraceObject; // flash.trace::Trace
    class TriangleCullingClass; // flash.display::TriangleCulling$
    class TriangleCullingObject; // flash.display::TriangleCulling
    class UIntVectorObject; // __AS3__.vec::Vector$uint
    class URLRequestClass; // flash.net::URLRequest$
    class URLRequestDefaultsClass; // flash.net::URLRequestDefaults$
    class URLRequestDefaultsObject; // flash.net::URLRequestDefaults
    class URLRequestHeaderClass; // flash.net::URLRequestHeader$
    class URLRequestHeaderObject; // flash.net::URLRequestHeader
    class URLRequestObject; // flash.net::URLRequest
    class WorkerEventClass; // flash.system::WorkerEvent$
    class WorkerEventObject; // flash.system::WorkerEvent
    class WorkerStateClass; // flash.system::WorkerState$
    class WorkerStateObject; // flash.system::WorkerState
    class __ctypeObject; // C.ctype::__ctype
    class __errnoObject; // C.errno::__errno
    class __fcntlObject; // C.fcntl::__fcntl
    class __inetObject; // C.arpa.inet::__inet
    class __limitsObject; // C.limits::__limits
    class __localeObject; // C.locale::__locale
    class __netdbObject; // C.netdb::__netdb
    class __netinetObject; // C.netinet::__netinet
    class __selectObject; // C.sys.select::__select
    class __signalObject; // C.signal::__signal
    class __socketObject; // C.sys.socket::__socket
    class __statObject; // C.sys.stat::__stat
    class __stdioObject; // C.stdio::__stdio
    class __stdlibObject; // C.stdlib::__stdlib
    class __timeObject; // C.time::__time
    class __unistdObject; // C.unistd::__unistd
    class __waitObject; // C.sys.wait::__wait
    class ipv6_mreqClass; // C.netinet::ipv6_mreq$
    class ipv6_mreqObject; // C.netinet::ipv6_mreq
    class itimerspecClass; // C.time::itimerspec$
    class itimerspecObject; // C.time::itimerspec
    class msghdrClass; // C.sys.socket::msghdr$
    class msghdrObject; // C.sys.socket::msghdr
    class netentClass; // C.netdb::netent$
    class netentObject; // C.netdb::netent
    class serventClass; // C.netdb::servent$
    class serventObject; // C.netdb::servent
    class sockaddr_storageClass; // C.sys.socket::sockaddr_storage$
    class sockaddr_storageObject; // C.sys.socket::sockaddr_storage
    class timespecClass; // C.time::timespec$
    class timespecObject; // C.time::timespec
    class tmClass; // C.time::tm$
    class tmObject; // C.time::tm
    class utsnameClass; // C.sys.utsname::utsname$
    class utsnameObject; // C.sys.utsname::utsname
}

namespace avmshell {
    class CArpaInetClass; // C.arpa.inet::__inet$
    class CDIRClass; // C.dirent::DIR$
    class CDIRObject; // C.dirent::DIR
    class CEAIrrorClass; // C.netdb::CEAIrror$
    class CEAIrrorObject; // C.netdb::CEAIrror
    class CErrnoClass; // C.errno::__errno$
    class CErrorClass; // C.errno::CError$
    class CErrorObject; // C.errno::CError
    class CFILEClass; // C.stdio::FILE$
    class CFILEObject; // C.stdio::FILE
    class CFcntlClass; // C.fcntl::__fcntl$
    class CIn6_AddrClass; // C.netinet::in6_addr$
    class CIn6_AddrObject; // C.netinet::in6_addr
    class CIn_AddrClass; // C.netinet::in_addr$
    class CIn_AddrObject; // C.netinet::in_addr
    class CLimitsClass; // C.limits::__limits$
    class CLocaleClass; // C.locale::__locale$
    class CNetdbClass; // C.netdb::__netdb$
    class CNetinetInClass; // C.netinet::__netinet$
    class CSignalClass; // C.signal::__signal$
    class CSockaddr_in6Class; // C.netinet::sockaddr_in6$
    class CSockaddr_in6Object; // C.netinet::sockaddr_in6
    class CSockaddr_inClass; // C.netinet::sockaddr_in$
    class CSockaddr_inObject; // C.netinet::sockaddr_in
    class CStatusClass; // C.sys.stat::status$
    class CStatusObject; // C.sys.stat::status
    class CStdioClass; // C.stdio::__stdio$
    class CStdlibClass; // C.stdlib::__stdlib$
    class CSysSelectClass; // C.sys.select::__select$
    class CSysSocketClass; // C.sys.socket::__socket$
    class CSysStatClass; // C.sys.stat::__stat$
    class CSysWaitClass; // C.sys.wait::__wait$
    class CTimeClass; // C.time::__time$
    class CTypeClass; // C.ctype::__ctype$
    class CUnistdClass; // C.unistd::__unistd$
    class CWaitStatusClass; // C.sys.wait::wait_status$
    class CWaitStatusObject; // C.sys.wait::wait_status
    class CaddrinfoClass; // C.netdb::addrinfo$
    class CaddrinfoObject; // C.netdb::addrinfo
    class CdirentClass; // C.dirent::dirent$
    class CdirentObject; // C.dirent::dirent
    class Cdiv_tClass; // C.stdlib::div_t$
    class Cdiv_tObject; // C.stdlib::div_t
    class Cfd_setClass; // C.sys.select::fd_set$
    class Cfd_setObject; // C.sys.select::fd_set
    class Cfpos_tClass; // C.stdio::fpos_t$
    class Cfpos_tObject; // C.stdio::fpos_t
    class ChostentClass; // C.netdb::hostent$
    class ChostentObject; // C.netdb::hostent
    class Cldiv_tClass; // C.stdlib::ldiv_t$
    class Cldiv_tObject; // C.stdlib::ldiv_t
    class Clldiv_tClass; // C.stdlib::lldiv_t$
    class Clldiv_tObject; // C.stdlib::lldiv_t
    class Cpid_tClass; // C.spawn::pid_t$
    class Cpid_tObject; // C.spawn::pid_t
    class CprotoentClass; // C.netdb::protoent$
    class CprotoentObject; // C.netdb::protoent
    class Csiginfo_tClass; // C.signal::siginfo_t$
    class Csiginfo_tObject; // C.signal::siginfo_t
    class CsigvalClass; // C.signal::sigval$
    class CsigvalObject; // C.signal::sigval
    class CsockaddrClass; // C.sys.socket::sockaddr$
    class CsockaddrObject; // C.sys.socket::sockaddr
    class CtimevalClass; // C.sys.select::timeval$
    class CtimevalObject; // C.sys.select::timeval
    class DiagnosticsClass; // shell::Diagnostics$
    class FileGlueClass; // flash.filesystem::File$
    class FileGlueObject; // flash.filesystem::File
    class FileReferenceClass; // flash.net::FileReference$
    class FileReferenceObject; // flash.net::FileReference
    class FileSystemClass; // shell::FileSystem$
    class HardwareInformationClass; // shell::HardwareInformation$
    class OperatingSystemClass; // shell::OperatingSystem$
    class ProgramClass; // shell::Program$
    class RuntimeClass; // shell::Runtime$
    class ShellWorkerClass; // flash.system::Worker$
    class ShellWorkerDomainClass; // flash.system::WorkerDomain$
    class ShellWorkerDomainObject; // flash.system::WorkerDomain
    class ShellWorkerObject; // flash.system::Worker
    class SystemClass; // flash.system::System$
}

namespace avmplus { namespace NativeID {

extern const uint32_t shell_toplevel_abc_class_count;
extern const uint32_t shell_toplevel_abc_script_count;
extern const uint32_t shell_toplevel_abc_method_count;
extern const uint32_t shell_toplevel_abc_length;
extern const uint8_t shell_toplevel_abc_data[];
extern const char* const shell_toplevel_versioned_uris[];
AVMTHUNK_DECLARE_NATIVE_INITIALIZER(shell_toplevel)

/* classes */
const uint32_t abcclass_C_ctype___ctype = 0;
const uint32_t abcclass_C_errno___errno = 1;
const uint32_t abcclass_C_errno_ErrorNumber = 2;
const uint32_t abcclass_C_errno_CError = 3;
const uint32_t abcclass_C_limits___limits = 4;
const uint32_t abcclass_C_locale___locale = 5;
const uint32_t abcclass_C_signal___signal = 6;
const uint32_t abcclass_C_signal_sigval = 7;
const uint32_t abcclass_C_signal_siginfo_t = 8;
const uint32_t abcclass_C_stdio___stdio = 9;
const uint32_t abcclass_C_stdio_FILE = 10;
const uint32_t abcclass_C_stdio_fpos_t = 11;
const uint32_t abcclass_C_stdlib___stdlib = 12;
const uint32_t abcclass_C_stdlib_div_t = 13;
const uint32_t abcclass_C_stdlib_ldiv_t = 14;
const uint32_t abcclass_C_stdlib_lldiv_t = 15;
const uint32_t abcclass_C_time___time = 16;
const uint32_t abcclass_C_time_tm = 17;
const uint32_t abcclass_C_time_timespec = 18;
const uint32_t abcclass_C_time_itimerspec = 19;
const uint32_t abcclass_C_arpa_inet___inet = 20;
const uint32_t abcclass_C_dirent_DIR = 21;
const uint32_t abcclass_C_dirent_dirent = 22;
const uint32_t abcclass_C_fcntl___fcntl = 23;
const uint32_t abcclass_C_netdb___netdb = 24;
const uint32_t abcclass_C_netdb_hostent = 25;
const uint32_t abcclass_C_netdb_netent = 26;
const uint32_t abcclass_C_netdb_protoent = 27;
const uint32_t abcclass_C_netdb_servent = 28;
const uint32_t abcclass_C_netdb_addrinfo = 29;
const uint32_t abcclass_C_netdb_CEAIrror = 30;
const uint32_t abcclass_C_netinet___netinet = 31;
const uint32_t abcclass_C_netinet_in_addr = 32;
const uint32_t abcclass_C_netinet_sockaddr_in = 33;
const uint32_t abcclass_C_netinet_in6_addr = 34;
const uint32_t abcclass_C_netinet_sockaddr_in6 = 35;
const uint32_t abcclass_C_netinet_ipv6_mreq = 36;
const uint32_t abcclass_C_spawn_pid_t = 37;
const uint32_t abcclass_C_sys_select___select = 38;
const uint32_t abcclass_C_sys_select_timeval = 39;
const uint32_t abcclass_C_sys_select_fd_set = 40;
const uint32_t abcclass_C_sys_socket___socket = 41;
const uint32_t abcclass_C_sys_socket_sockaddr = 42;
const uint32_t abcclass_C_sys_socket_sockaddr_storage = 43;
const uint32_t abcclass_C_sys_socket_msghdr = 44;
const uint32_t abcclass_C_sys_stat___stat = 45;
const uint32_t abcclass_C_sys_stat_status = 46;
const uint32_t abcclass_C_sys_utsname_utsname = 47;
const uint32_t abcclass_C_sys_wait___wait = 48;
const uint32_t abcclass_C_sys_wait_wait_status = 49;
const uint32_t abcclass_C_unistd___unistd = 50;
const uint32_t abcclass_shell_Program = 51;
const uint32_t abcclass_shell_Runtime = 52;
const uint32_t abcclass_shell_Diagnostics = 53;
const uint32_t abcclass_shell_HardwareInformation = 54;
const uint32_t abcclass_shell_OperatingSystem = 55;
const uint32_t abcclass_shell_FileSystem = 56;
const uint32_t abcclass_shell_RunMode = 57;
const uint32_t abcclass_shell_Domain = 58;
const uint32_t abcclass_shell_Environment = 59;
const uint32_t abcclass_shell_BinaryData = 60;
const uint32_t abcclass_shell_async_EventLoop = 61;
const uint32_t abcclass_flash_accessibility_ISearchableText = 62;
const uint32_t abcclass_flash_accessibility_ISimpleTextSelection = 63;
const uint32_t abcclass_flash_accessibility_Accessibility = 64;
const uint32_t abcclass_flash_accessibility_AccessibilityImplementation = 65;
const uint32_t abcclass_flash_accessibility_AccessibilityProperties = 66;
const uint32_t abcclass_flash_data_EncryptedLocalStore = 67;
const uint32_t abcclass_flash_data_SQLCollationType = 68;
const uint32_t abcclass_flash_data_SQLColumnNameStyle = 69;
const uint32_t abcclass_flash_data_SQLColumnSchema = 70;
const uint32_t abcclass_flash_data_SQLConnection = 71;
const uint32_t abcclass_flash_data_SQLIndexSchema = 72;
const uint32_t abcclass_flash_data_SQLMode = 73;
const uint32_t abcclass_flash_data_SQLResult = 74;
const uint32_t abcclass_flash_data_SQLSchema = 75;
const uint32_t abcclass_flash_data_SQLSchemaResult = 76;
const uint32_t abcclass_flash_data_SQLStatement = 77;
const uint32_t abcclass_flash_data_SQLTableSchema = 78;
const uint32_t abcclass_flash_data_SQLTransactionLockType = 79;
const uint32_t abcclass_flash_data_SQLTriggerSchema = 80;
const uint32_t abcclass_flash_data_SQLViewSchema = 81;
const uint32_t abcclass_flash_display_IBitmapDrawable = 82;
const uint32_t abcclass_flash_display_IDrawCommand = 83;
const uint32_t abcclass_flash_display_IGraphicsData = 84;
const uint32_t abcclass_flash_display_IGraphicsFill = 85;
const uint32_t abcclass_flash_display_IGraphicsPath = 86;
const uint32_t abcclass_flash_display_IGraphicsStroke = 87;
const uint32_t abcclass_flash_display_ActionScriptVersion = 88;
const uint32_t abcclass_flash_display_PixelSnapping = 89;
const uint32_t abcclass_flash_display_PNGEncoderOptions = 90;
const uint32_t abcclass_flash_display_Scene = 91;
const uint32_t abcclass_flash_display_StageAlign = 92;
const uint32_t abcclass_flash_display_StageAspectRatio = 93;
const uint32_t abcclass_flash_display_StageDisplayState = 94;
const uint32_t abcclass_flash_display_StageOrientation = 95;
const uint32_t abcclass_flash_display_StageQuality = 96;
const uint32_t abcclass_flash_display_StageScaleMode = 97;
const uint32_t abcclass_flash_display_SWFVersion = 98;
const uint32_t abcclass_flash_display_TriangleCulling = 99;
const uint32_t abcclass_flash_errors_ScriptTimeoutError = 100;
const uint32_t abcclass_flash_errors_StackOverflowError = 101;
const uint32_t abcclass_flash_errors_InvalidSWFError = 102;
const uint32_t abcclass_flash_errors_SQLErrorOperation = 103;
const uint32_t abcclass_flash_errors_SQLError = 104;
const uint32_t abcclass_flash_errors_DRMManagerError = 105;
const uint32_t abcclass_flash_events_IEventDispatcher = 106;
const uint32_t abcclass_flash_events_Event = 107;
const uint32_t abcclass_flash_filesystem_File = 108;
const uint32_t abcclass_flash_filesystem_FileMode = 109;
const uint32_t abcclass_flash_filesystem_FileStream = 110;
const uint32_t abcclass_flash_geom_Orientation3D = 111;
const uint32_t abcclass_flash_geom_Point = 112;
const uint32_t abcclass_flash_geom_Rectangle = 113;
const uint32_t abcclass_flash_net_FileReference = 114;
const uint32_t abcclass_flash_net_URLRequest = 115;
const uint32_t abcclass_flash_net_URLRequestDefaults = 116;
const uint32_t abcclass_flash_net_URLRequestHeader = 117;
const uint32_t abcclass_flash_sampler_StackFrame = 118;
const uint32_t abcclass_flash_sampler_Sample = 119;
const uint32_t abcclass_flash_sampler_ClassFactory = 120;
const uint32_t abcclass_flash_system_Capabilities = 121;
const uint32_t abcclass_flash_system_Security = 122;
const uint32_t abcclass_flash_system_SecurityPrivilege = 123;
const uint32_t abcclass_flash_system_System = 124;
const uint32_t abcclass_flash_system_WorkerState = 125;
const uint32_t abcclass_flash_system_Worker = 126;
const uint32_t abcclass_flash_system_WorkerEvent = 127;
const uint32_t abcclass_flash_system_WorkerDomain = 128;
const uint32_t abcclass_flash_trace_Trace = 129;
const uint32_t abcclass_flash_utils_Endian = 130;
const uint32_t abcclass_shell_async_CoreEventLoop = 131;
const uint32_t abcclass_flash_events_EventDispatcher = 132;
const uint32_t abcclass_flash_events_HTTPStatusEvent = 133;
const uint32_t abcclass_flash_events_TimerEvent = 134;
const uint32_t abcclass_flash_sampler_NewObjectSample = 135;
const uint32_t abcclass_flash_sampler_DeleteObjectSample = 136;
const uint32_t abcclass_flash_utils_Timer = 137;

/* methods */
const uint32_t native_script_function_flash_sampler_getMasterString = 14; // native
const uint32_t native_script_function_flash_sampler_getSavedThis = 15; // native
const uint32_t native_script_function_flash_sampler_getLexicalScopes = 16; // native
const uint32_t native_script_function_flash_sampler_isGetterSetter = 17; // native
const uint32_t native_script_function_flash_sampler__getInvocationCount = 18; // native
const uint32_t native_script_function_flash_sampler_getSampleCount = 22; // native
const uint32_t native_script_function_flash_sampler__getSamples = 23; // native
const uint32_t native_script_function_flash_sampler_getMemberNames = 25; // native
const uint32_t native_script_function_flash_sampler_getSize = 26; // native
const uint32_t native_script_function_flash_sampler__setSamplerCallback = 27; // native
const uint32_t native_script_function_flash_sampler_sampleInternalAllocs = 30; // native
const uint32_t native_script_function_flash_sampler_pauseSampling = 31; // native
const uint32_t native_script_function_flash_sampler_stopSampling = 32; // native
const uint32_t native_script_function_flash_sampler_startSampling = 33; // native
const uint32_t native_script_function_flash_sampler_clearSamples = 34; // native
const uint32_t native_script_function_C_unistd_ftruncate = 48; // native
const uint32_t native_script_function_C_unistd_fsync = 49; // native
const uint32_t native_script_function_C_unistd_execvp = 50; // native
const uint32_t native_script_function_C_unistd_execve = 51; // native
const uint32_t native_script_function_C_unistd_execv = 52; // native
const uint32_t native_script_function_C_unistd_execlp = 53; // native
const uint32_t native_script_function_C_unistd_execle = 54; // native
const uint32_t native_script_function_C_unistd_execl = 55; // native
const uint32_t native_script_function_C_unistd_dup2 = 56; // native
const uint32_t native_script_function_C_unistd_dup = 57; // native
const uint32_t native_script_function_C_unistd_close = 58; // native
const uint32_t native_script_function_C_unistd_chdir = 59; // native
const uint32_t native_script_function_C_unistd_access = 60; // native
const uint32_t native_script_function_C_sys_wait_waitpid = 61; // native
const uint32_t native_script_function_C_sys_wait_waitid = 62; // native
const uint32_t native_script_function_C_sys_wait_wait = 63; // native
const uint32_t native_script_function_C_sys_utsname_uname = 72; // native
const uint32_t native_script_function_C_sys_stat_umask = 73; // native
const uint32_t native_script_function_C_sys_stat_stat = 74; // native
const uint32_t native_script_function_C_sys_stat_fstat = 77; // native
const uint32_t native_script_function_C_sys_stat_chmod = 78; // native
const uint32_t native_script_function_C_sys_socket_socketpair = 86; // native
const uint32_t native_script_function_C_sys_socket_socket = 87; // native
const uint32_t native_script_function_C_sys_socket_sockatmark = 88; // native
const uint32_t native_script_function_C_sys_socket_shutdown = 89; // native
const uint32_t native_script_function_C_sys_socket_send = 94; // native
const uint32_t native_script_function_C_sys_socket_recv = 97; // native
const uint32_t native_script_function_C_sys_socket_listen = 98; // native
const uint32_t native_script_function_C_sys_select_isExceptional = 106; // native
const uint32_t native_script_function_C_sys_select_isWritable = 107; // native
const uint32_t native_script_function_C_sys_select_isReadable = 108; // native
const uint32_t native_script_function_C_sys_select_select = 109; // native
const uint32_t native_script_function_C_sys_select_FD_ZERO = 110; // native
const uint32_t native_script_function_C_sys_select_FD_SET = 111; // native
const uint32_t native_script_function_C_sys_select_FD_ISSET = 112; // native
const uint32_t native_script_function_C_sys_select_FD_CLR = 113; // native
const uint32_t native_script_function_C_spawn_spawnp = 114; // native
const uint32_t native_script_function_C_spawn_spawn = 115; // native
const uint32_t native_script_function_C_netdb_getprotoent = 144; // native
const uint32_t native_script_function_C_netdb_getprotobynumber = 145; // native
const uint32_t native_script_function_C_netdb_gethostent = 146; // native
const uint32_t native_script_function_C_netdb_gethostbyname = 147; // native
const uint32_t native_script_function_C_netdb_getaddrinfo = 149; // native
const uint32_t native_script_function_C_netdb_gai_strerror = 150; // native
const uint32_t native_script_function_C_fcntl_openat = 151; // native
const uint32_t native_script_function_C_fcntl_open = 152; // native
const uint32_t native_script_function_C_fcntl_fcntl = 153; // native
const uint32_t native_script_function_C_fcntl_creat = 154; // native
const uint32_t native_script_function_C_dirent_telldir = 155; // native
const uint32_t native_script_function_C_dirent_seekdir = 156; // native
const uint32_t native_script_function_C_dirent_rewinddir = 157; // native
const uint32_t native_script_function_C_dirent_readdir = 158; // native
const uint32_t native_script_function_C_dirent_opendir = 159; // native
const uint32_t native_script_function_C_dirent_fdopendir = 161; // native
const uint32_t native_script_function_C_dirent_dirfd = 162; // native
const uint32_t native_script_function_C_dirent_closedir = 163; // native
const uint32_t native_script_function_C_conio_kbhit = 165; // native
const uint32_t native_script_function_C_conio_echo = 166; // native
const uint32_t native_script_function_C_conio_canonical = 167; // native
const uint32_t native_script_function_C_string_strspn = 182; // native
const uint32_t native_script_function_C_string_strerror = 191; // native
const uint32_t native_script_function_C_string_strcoll = 192; // native
const uint32_t native_script_function_C_string_strcmp = 193; // native
const uint32_t native_script_function_C_stdlib_unsetenv = 196; // native
const uint32_t native_script_function_C_stdlib_system = 197; // native
const uint32_t native_script_function_C_stdlib_srand = 205; // native
const uint32_t native_script_function_C_stdlib_setenv = 206; // native
const uint32_t native_script_function_C_stdlib_realpath = 207; // native
const uint32_t native_script_function_C_stdlib_rand = 208; // native
const uint32_t native_script_function_C_stdlib_putenv = 209; // native
const uint32_t native_script_function_C_stdlib_mkstemp = 210; // native
const uint32_t native_script_function_C_stdlib_mkdtemp = 211; // native
const uint32_t native_script_function_C_stdlib_mblen = 212; // native
const uint32_t native_script_function_C_stdlib_lldiv = 213; // native
const uint32_t native_script_function_C_stdlib_ldiv = 215; // native
const uint32_t native_script_function_C_stdlib_getenv = 217; // native
const uint32_t native_script_function_C_stdlib_div = 219; // native
const uint32_t native_script_function_C_stdlib_atol = 221; // native
const uint32_t native_script_function_C_stdlib_atoi = 222; // native
const uint32_t native_script_function_C_stdlib_atof = 223; // native
const uint32_t native_script_function_C_stdio_rewind = 227; // native
const uint32_t native_script_function_C_stdio_rename = 228; // native
const uint32_t native_script_function_C_stdio_remove = 229; // native
const uint32_t native_script_function_C_stdio_popen = 230; // native
const uint32_t native_script_function_C_stdio_perror = 231; // native
const uint32_t native_script_function_C_stdio_pclose = 232; // native
const uint32_t native_script_function_C_stdio_getchar = 235; // native
const uint32_t native_script_function_C_stdio_fwrite = 237; // native
const uint32_t native_script_function_C_stdio_funlockfile = 238; // native
const uint32_t native_script_function_C_stdio_ftrylockfile = 239; // native
const uint32_t native_script_function_C_stdio_ftell = 240; // native
const uint32_t native_script_function_C_stdio_fsetpos = 241; // native
const uint32_t native_script_function_C_stdio_fseek = 242; // native
const uint32_t native_script_function_C_stdio_freopen = 243; // native
const uint32_t native_script_function_C_stdio_fread = 244; // native
const uint32_t native_script_function_C_stdio_fputs = 245; // native
const uint32_t native_script_function_C_stdio_fputc = 246; // native
const uint32_t native_script_function_C_stdio_fopen = 247; // native
const uint32_t native_script_function_C_stdio_flockfile = 248; // native
const uint32_t native_script_function_C_stdio_fileno = 249; // native
const uint32_t native_script_function_C_stdio_fgets = 250; // native
const uint32_t native_script_function_C_stdio_fgetpos = 251; // native
const uint32_t native_script_function_C_stdio_fgetc = 252; // native
const uint32_t native_script_function_C_stdio_fflush = 253; // native
const uint32_t native_script_function_C_stdio_ferror = 254; // native
const uint32_t native_script_function_C_stdio_feof = 255; // native
const uint32_t native_script_function_C_stdio_fdopen = 256; // native
const uint32_t native_script_function_C_stdio_fclose = 257; // native
const uint32_t native_script_function_C_stdio_clearerr = 258; // native
const uint32_t native_script_function_C_signal_kill = 259; // native
const uint32_t native_script_function_C_assert__debugBreak = 282; // native
const uint32_t C_ctype___ctype__avm_isalnum = 287; // native
const uint32_t C_ctype___ctype__avm_isalpha = 288; // native
const uint32_t C_ctype___ctype__avm_isascii = 289; // native
const uint32_t C_ctype___ctype__avm_isblank = 290; // native
const uint32_t C_ctype___ctype__avm_iscntrl = 291; // native
const uint32_t C_ctype___ctype__avm_isdigit = 292; // native
const uint32_t C_ctype___ctype__avm_isgraph = 293; // native
const uint32_t C_ctype___ctype__avm_islower = 294; // native
const uint32_t C_ctype___ctype__avm_isprint = 295; // native
const uint32_t C_ctype___ctype__avm_ispunct = 296; // native
const uint32_t C_ctype___ctype__avm_isspace = 297; // native
const uint32_t C_ctype___ctype__avm_isupper = 298; // native
const uint32_t C_ctype___ctype__avm_isxdigit = 299; // native
const uint32_t C_ctype___ctype__avm_toascii = 300; // native
const uint32_t C_ctype___ctype__avm_tolower = 301; // native
const uint32_t C_ctype___ctype__avm_toupper = 302; // native
const uint32_t C_errno___errno_EPERM_get = 305; // native
const uint32_t C_errno___errno_ENOENT_get = 306; // native
const uint32_t C_errno___errno_ESRCH_get = 307; // native
const uint32_t C_errno___errno_EINTR_get = 308; // native
const uint32_t C_errno___errno_EIO_get = 309; // native
const uint32_t C_errno___errno_ENXIO_get = 310; // native
const uint32_t C_errno___errno_E2BIG_get = 311; // native
const uint32_t C_errno___errno_ENOEXEC_get = 312; // native
const uint32_t C_errno___errno_EBADF_get = 313; // native
const uint32_t C_errno___errno_ECHILD_get = 314; // native
const uint32_t C_errno___errno_EAGAIN_get = 315; // native
const uint32_t C_errno___errno_ENOMEM_get = 316; // native
const uint32_t C_errno___errno_EACCES_get = 317; // native
const uint32_t C_errno___errno_EFAULT_get = 318; // native
const uint32_t C_errno___errno_ENOTBLK_get = 319; // native
const uint32_t C_errno___errno_EBUSY_get = 320; // native
const uint32_t C_errno___errno_EEXIST_get = 321; // native
const uint32_t C_errno___errno_EXDEV_get = 322; // native
const uint32_t C_errno___errno_ENODEV_get = 323; // native
const uint32_t C_errno___errno_ENOTDIR_get = 324; // native
const uint32_t C_errno___errno_EISDIR_get = 325; // native
const uint32_t C_errno___errno_EINVAL_get = 326; // native
const uint32_t C_errno___errno_ENFILE_get = 327; // native
const uint32_t C_errno___errno_EMFILE_get = 328; // native
const uint32_t C_errno___errno_ENOTTY_get = 329; // native
const uint32_t C_errno___errno_ETXTBSY_get = 330; // native
const uint32_t C_errno___errno_EFBIG_get = 331; // native
const uint32_t C_errno___errno_ENOSPC_get = 332; // native
const uint32_t C_errno___errno_ESPIPE_get = 333; // native
const uint32_t C_errno___errno_EROFS_get = 334; // native
const uint32_t C_errno___errno_EMLINK_get = 335; // native
const uint32_t C_errno___errno_EPIPE_get = 336; // native
const uint32_t C_errno___errno_EDOM_get = 337; // native
const uint32_t C_errno___errno_ERANGE_get = 338; // native
const uint32_t C_errno___errno_EDEADLK_get = 339; // native
const uint32_t C_errno___errno_ENAMETOOLONG_get = 340; // native
const uint32_t C_errno___errno_ENOLCK_get = 341; // native
const uint32_t C_errno___errno_ENOSYS_get = 342; // native
const uint32_t C_errno___errno_ENOTEMPTY_get = 343; // native
const uint32_t C_errno___errno_ELOOP_get = 344; // native
const uint32_t C_errno___errno_EWOULDBLOCK_get = 345; // native
const uint32_t C_errno___errno_ENOMSG_get = 346; // native
const uint32_t C_errno___errno_EIDRM_get = 347; // native
const uint32_t C_errno___errno_EDEADLOCK_get = 348; // native
const uint32_t C_errno___errno_ENOSTR_get = 349; // native
const uint32_t C_errno___errno_ENODATA_get = 350; // native
const uint32_t C_errno___errno_ETIME_get = 351; // native
const uint32_t C_errno___errno_ENOSR_get = 352; // native
const uint32_t C_errno___errno_ENOLINK_get = 353; // native
const uint32_t C_errno___errno_EBADMSG_get = 354; // native
const uint32_t C_errno___errno_EOVERFLOW_get = 355; // native
const uint32_t C_errno___errno_EILSEQ_get = 356; // native
const uint32_t C_errno___errno_ENOTSOCK_get = 357; // native
const uint32_t C_errno___errno_EDESTADDRREQ_get = 358; // native
const uint32_t C_errno___errno_EMSGSIZE_get = 359; // native
const uint32_t C_errno___errno_EPROTO_get = 360; // native
const uint32_t C_errno___errno_EPROTOTYPE_get = 361; // native
const uint32_t C_errno___errno_ENOPROTOOPT_get = 362; // native
const uint32_t C_errno___errno_EPROTONOSUPPORT_get = 363; // native
const uint32_t C_errno___errno_EOPNOTSUPP_get = 364; // native
const uint32_t C_errno___errno_EAFNOSUPPORT_get = 365; // native
const uint32_t C_errno___errno_EADDRINUSE_get = 366; // native
const uint32_t C_errno___errno_EADDRNOTAVAIL_get = 367; // native
const uint32_t C_errno___errno_ENETDOWN_get = 368; // native
const uint32_t C_errno___errno_ENETUNREACH_get = 369; // native
const uint32_t C_errno___errno_ENETRESET_get = 370; // native
const uint32_t C_errno___errno_ECONNABORTED_get = 371; // native
const uint32_t C_errno___errno_ECONNRESET_get = 372; // native
const uint32_t C_errno___errno_ENOBUFS_get = 373; // native
const uint32_t C_errno___errno_EISCONN_get = 374; // native
const uint32_t C_errno___errno_ENOTCONN_get = 375; // native
const uint32_t C_errno___errno_ETIMEDOUT_get = 376; // native
const uint32_t C_errno___errno_ECONNREFUSED_get = 377; // native
const uint32_t C_errno___errno_EHOSTUNREACH_get = 378; // native
const uint32_t C_errno___errno_EALREADY_get = 379; // native
const uint32_t C_errno___errno_EINPROGRESS_get = 380; // native
const uint32_t C_errno___errno_ECANCELED_get = 381; // native
const uint32_t C_errno___errno_EOWNERDEAD_get = 382; // native
const uint32_t C_errno___errno_ENOTRECOVERABLE_get = 383; // native
const uint32_t C_errno___errno_EREMOTE_get = 384; // native
const uint32_t C_errno___errno_EUSERS_get = 385; // native
const uint32_t C_errno___errno_ESOCKTNOSUPPORT_get = 386; // native
const uint32_t C_errno___errno_EPFNOSUPPORT_get = 387; // native
const uint32_t C_errno___errno_ESHUTDOWN_get = 388; // native
const uint32_t C_errno___errno_ETOOMANYREFS_get = 389; // native
const uint32_t C_errno___errno_EHOSTDOWN_get = 390; // native
const uint32_t C_errno___errno_ESTALE_get = 391; // native
const uint32_t C_errno___errno_EDQUOT_get = 392; // native
const uint32_t C_errno___errno_EMULTIHOP_get = 393; // native
const uint32_t C_errno___errno_ECHRNG_get = 394; // native
const uint32_t C_errno___errno_EL2NSYNC_get = 395; // native
const uint32_t C_errno___errno_EL3HLT_get = 396; // native
const uint32_t C_errno___errno_EL3RST_get = 397; // native
const uint32_t C_errno___errno_ELNRNG_get = 398; // native
const uint32_t C_errno___errno_EUNATCH_get = 399; // native
const uint32_t C_errno___errno_ENOCSI_get = 400; // native
const uint32_t C_errno___errno_EL2HLT_get = 401; // native
const uint32_t C_errno___errno_EBADE_get = 402; // native
const uint32_t C_errno___errno_EBADR_get = 403; // native
const uint32_t C_errno___errno_EXFULL_get = 404; // native
const uint32_t C_errno___errno_ENOANO_get = 405; // native
const uint32_t C_errno___errno_EBADRQC_get = 406; // native
const uint32_t C_errno___errno_EBADSLT_get = 407; // native
const uint32_t C_errno___errno_EBFONT_get = 408; // native
const uint32_t C_errno___errno_ENONET_get = 409; // native
const uint32_t C_errno___errno_ENOPKG_get = 410; // native
const uint32_t C_errno___errno_EADV_get = 411; // native
const uint32_t C_errno___errno_ESRMNT_get = 412; // native
const uint32_t C_errno___errno_ECOMM_get = 413; // native
const uint32_t C_errno___errno_EDOTDOT_get = 414; // native
const uint32_t C_errno___errno_ENOTUNIQ_get = 415; // native
const uint32_t C_errno___errno_EBADFD_get = 416; // native
const uint32_t C_errno___errno_EREMCHG_get = 417; // native
const uint32_t C_errno___errno_ELIBACC_get = 418; // native
const uint32_t C_errno___errno_ELIBBAD_get = 419; // native
const uint32_t C_errno___errno_ELIBSCN_get = 420; // native
const uint32_t C_errno___errno_ELIBMAX_get = 421; // native
const uint32_t C_errno___errno_ELIBEXEC_get = 422; // native
const uint32_t C_errno___errno_ERESTART_get = 423; // native
const uint32_t C_errno___errno_ESTRPIPE_get = 424; // native
const uint32_t C_errno___errno_EUCLEAN_get = 425; // native
const uint32_t C_errno___errno_ENOTNAM_get = 426; // native
const uint32_t C_errno___errno_ENAVAIL_get = 427; // native
const uint32_t C_errno___errno_EISNAM_get = 428; // native
const uint32_t C_errno___errno_EREMOTEIO_get = 429; // native
const uint32_t C_errno___errno_ENOMEDIUM_get = 430; // native
const uint32_t C_errno___errno_EMEDIUMTYPE_get = 431; // native
const uint32_t C_errno___errno_ENOKEY_get = 432; // native
const uint32_t C_errno___errno_EKEYEXPIRED_get = 433; // native
const uint32_t C_errno___errno_EKEYREVOKED_get = 434; // native
const uint32_t C_errno___errno_EKEYREJECTED_get = 435; // native
const uint32_t C_errno___errno_ERFKILL_get = 436; // native
const uint32_t C_errno___errno_EHWPOISON_get = 437; // native
const uint32_t C_errno___errno__GetErrno = 438; // native
const uint32_t C_errno___errno__SetErrno = 439; // native
const uint32_t C_errno_ErrorNumber_value_get = 443; // abc
const uint32_t C_errno_ErrorNumber_value_set = 444; // abc
const uint32_t C_errno_ErrorNumber_valueOf = 445; // abc
const uint32_t C_errno_ErrorNumber_toString = 446; // abc
const uint32_t C_errno_ErrorNumber_toErrnoString = 447; // abc
const uint32_t C_errno_CError_errorID_get = 450; // abc
const uint32_t C_errno_CError_apply = 451; // abc
const uint32_t C_errno_CError_toString = 452; // abc
const uint32_t C_limits___limits_CHAR_BIT_get = 454; // native
const uint32_t C_limits___limits_CHAR_MAX_get = 455; // native
const uint32_t C_limits___limits_CHAR_MIN_get = 456; // native
const uint32_t C_limits___limits_INT_MAX_get = 457; // native
const uint32_t C_limits___limits_INT_MIN_get = 458; // native
const uint32_t C_limits___limits_LLONG_MAX_get = 459; // native
const uint32_t C_limits___limits_LLONG_MIN_get = 460; // native
const uint32_t C_limits___limits_LONG_BIT_get = 461; // native
const uint32_t C_limits___limits_LONG_MAX_get = 462; // native
const uint32_t C_limits___limits_LONG_MIN_get = 463; // native
const uint32_t C_limits___limits_SCHAR_MAX_get = 464; // native
const uint32_t C_limits___limits_SCHAR_MIN_get = 465; // native
const uint32_t C_limits___limits_SHRT_MAX_get = 466; // native
const uint32_t C_limits___limits_SHRT_MIN_get = 467; // native
const uint32_t C_limits___limits_UCHAR_MAX_get = 468; // native
const uint32_t C_limits___limits_UINT_MAX_get = 469; // native
const uint32_t C_limits___limits_ULLONG_MAX_get = 470; // native
const uint32_t C_limits___limits_ULONG_MAX_get = 471; // native
const uint32_t C_limits___limits_USHRT_MAX_get = 472; // native
const uint32_t C_limits___limits_WORD_BIT_get = 473; // native
const uint32_t C_limits___limits_ARG_MAX_get = 474; // native
const uint32_t C_limits___limits_ATEXIT_MAX_get = 475; // native
const uint32_t C_limits___limits_CHILD_MAX_get = 476; // native
const uint32_t C_limits___limits_LINK_MAX_get = 477; // native
const uint32_t C_limits___limits_MAX_CANON_get = 478; // native
const uint32_t C_limits___limits_MAX_INPUT_get = 479; // native
const uint32_t C_limits___limits_NAME_MAX_get = 480; // native
const uint32_t C_limits___limits_NGROUPS_MAX_get = 481; // native
const uint32_t C_limits___limits_OPEN_MAX_get = 482; // native
const uint32_t C_limits___limits_PATH_MAX_get = 483; // native
const uint32_t C_limits___limits_PIPE_BUF_get = 484; // native
const uint32_t C_limits___limits_SSIZE_MAX_get = 485; // native
const uint32_t C_limits___limits_STREAM_MAX_get = 486; // native
const uint32_t C_limits___limits_TZNAME_MAX_get = 487; // native
const uint32_t C_limits___limits_MB_LEN_MAX_get = 488; // native
const uint32_t C_limits___limits_SIZE_MAX_get = 489; // native
const uint32_t C_limits___limits_SYMLINK_MAX_get = 490; // native
const uint32_t C_limits___limits_AIO_LISTIO_MAX_get = 491; // native
const uint32_t C_limits___limits_AIO_MAX_get = 492; // native
const uint32_t C_limits___limits_AIO_PRIO_DELTA_MAX_get = 493; // native
const uint32_t C_limits___limits_DELAYTIMER_MAX_get = 494; // native
const uint32_t C_limits___limits_HOST_NAME_MAX_get = 495; // native
const uint32_t C_limits___limits_LOGIN_NAME_MAX_get = 496; // native
const uint32_t C_limits___limits_MQ_OPEN_MAX_get = 497; // native
const uint32_t C_limits___limits_MQ_PRIO_MAX_get = 498; // native
const uint32_t C_limits___limits_PAGESIZE_get = 499; // native
const uint32_t C_limits___limits_PAGE_SIZE_get = 500; // native
const uint32_t C_limits___limits_RE_DUP_MAX_get = 501; // native
const uint32_t C_limits___limits_RTSIG_MAX_get = 502; // native
const uint32_t C_limits___limits_SEM_NSEMS_MAX_get = 503; // native
const uint32_t C_limits___limits_SEM_VALUE_MAX_get = 504; // native
const uint32_t C_limits___limits_SIGQUEUE_MAX_get = 505; // native
const uint32_t C_limits___limits_SS_REPL_MAX_get = 506; // native
const uint32_t C_limits___limits_SYMLOOP_MAX_get = 507; // native
const uint32_t C_limits___limits_TIMER_MAX_get = 508; // native
const uint32_t C_limits___limits_TRACE_EVENT_NAME_MAX_get = 509; // native
const uint32_t C_limits___limits_TRACE_NAME_MAX_get = 510; // native
const uint32_t C_limits___limits_TRACE_SYS_MAX_get = 511; // native
const uint32_t C_limits___limits_TRACE_USER_EVENT_MAX_get = 512; // native
const uint32_t C_limits___limits_TTY_NAME_MAX_get = 513; // native
const uint32_t C_limits___limits__POSIX_ARG_MAX_get = 514; // native
const uint32_t C_limits___limits__POSIX_CHILD_MAX_get = 515; // native
const uint32_t C_limits___limits__POSIX_LINK_MAX_get = 516; // native
const uint32_t C_limits___limits__POSIX_MAX_CANON_get = 517; // native
const uint32_t C_limits___limits__POSIX_MAX_INPUT_get = 518; // native
const uint32_t C_limits___limits__POSIX_NAME_MAX_get = 519; // native
const uint32_t C_limits___limits__POSIX_NGROUPS_MAX_get = 520; // native
const uint32_t C_limits___limits__POSIX_OPEN_MAX_get = 521; // native
const uint32_t C_limits___limits__POSIX_PATH_MAX_get = 522; // native
const uint32_t C_limits___limits__POSIX_PIPE_BUF_get = 523; // native
const uint32_t C_limits___limits__POSIX_SSIZE_MAX_get = 524; // native
const uint32_t C_limits___limits__POSIX_STREAM_MAX_get = 525; // native
const uint32_t C_limits___limits__POSIX_TZNAME_MAX_get = 526; // native
const uint32_t C_limits___limits__POSIX_SYMLINK_MAX_get = 527; // native
const uint32_t C_limits___limits__POSIX_AIO_LISTIO_MAX_get = 528; // native
const uint32_t C_limits___limits__POSIX_AIO_MAX_get = 529; // native
const uint32_t C_limits___limits__POSIX_DELAYTIMER_MAX_get = 530; // native
const uint32_t C_limits___limits__POSIX_HOST_NAME_MAX_get = 531; // native
const uint32_t C_limits___limits__POSIX_LOGIN_NAME_MAX_get = 532; // native
const uint32_t C_limits___limits__POSIX_MQ_OPEN_MAX_get = 533; // native
const uint32_t C_limits___limits__POSIX_MQ_PRIO_MAX_get = 534; // native
const uint32_t C_limits___limits__POSIX_RE_DUP_MAX_get = 535; // native
const uint32_t C_limits___limits__POSIX_RTSIG_MAX_get = 536; // native
const uint32_t C_limits___limits__POSIX_SEM_NSEMS_MAX_get = 537; // native
const uint32_t C_limits___limits__POSIX_SEM_VALUE_MAX_get = 538; // native
const uint32_t C_limits___limits__POSIX_SIGQUEUE_MAX_get = 539; // native
const uint32_t C_limits___limits__POSIX_SS_REPL_MAX_get = 540; // native
const uint32_t C_limits___limits__POSIX_SYMLOOP_MAX_get = 541; // native
const uint32_t C_limits___limits__POSIX_TIMER_MAX_get = 542; // native
const uint32_t C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get = 543; // native
const uint32_t C_limits___limits__POSIX_TRACE_NAME_MAX_get = 544; // native
const uint32_t C_limits___limits__POSIX_TRACE_SYS_MAX_get = 545; // native
const uint32_t C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get = 546; // native
const uint32_t C_limits___limits__POSIX_TTY_NAME_MAX_get = 547; // native
const uint32_t C_locale___locale_LC_ALL_get = 550; // native
const uint32_t C_signal___signal_SIGEV_NONE_get = 553; // native
const uint32_t C_signal___signal_SIGEV_SIGNAL_get = 554; // native
const uint32_t C_signal___signal_SIGEV_THREAD_get = 555; // native
const uint32_t C_stdio___stdio_BUFSIZ_get = 562; // native
const uint32_t C_stdio___stdio__IOFBF_get = 563; // native
const uint32_t C_stdio___stdio__IOLBF_get = 564; // native
const uint32_t C_stdio___stdio__IONBF_get = 565; // native
const uint32_t C_stdio___stdio_SEEK_CUR_get = 566; // native
const uint32_t C_stdio___stdio_SEEK_END_get = 567; // native
const uint32_t C_stdio___stdio_SEEK_SET_get = 568; // native
const uint32_t C_stdio___stdio_FILENAME_MAX_get = 569; // native
const uint32_t C_stdio___stdio_FOPEN_MAX_get = 570; // native
const uint32_t C_stdio___stdio_TMP_MAX_get = 571; // native
const uint32_t C_stdio___stdio_EOF_get = 572; // native
const uint32_t C_stdio___stdio_stdin_get = 573; // native
const uint32_t C_stdio___stdio_stdout_get = 574; // native
const uint32_t C_stdio___stdio_stderr_get = 575; // native
const uint32_t C_stdio___stdio__getc = 576; // native
const uint32_t C_stdio___stdio__getc_unlocked = 577; // native
const uint32_t C_stdio___stdio__getchar_unlocked = 578; // native
const uint32_t C_stdlib___stdlib_EXIT_SUCCESS_get = 585; // native
const uint32_t C_stdlib___stdlib_EXIT_FAILURE_get = 586; // native
const uint32_t C_stdlib___stdlib_RAND_MAX_get = 587; // native
const uint32_t C_stdlib___stdlib_MB_CUR_MAX_get = 588; // native
const uint32_t C_stdlib___stdlib__str2num = 589; // abc
const uint32_t C_stdlib___stdlib__str2int = 590; // abc
const uint32_t C_stdlib___stdlib__str2uint = 591; // abc
const uint32_t C_stdlib_div_t_toString = 595; // abc
const uint32_t C_stdlib_ldiv_t_toString = 598; // abc
const uint32_t C_stdlib_lldiv_t_toString = 601; // abc
const uint32_t C_time___time_CLOCKS_PER_SEC_get = 603; // native
const uint32_t C_arpa_inet___inet__htonl = 612; // native
const uint32_t C_arpa_inet___inet__htons = 613; // native
const uint32_t C_arpa_inet___inet__ntohl = 614; // native
const uint32_t C_arpa_inet___inet__ntohs = 615; // native
const uint32_t C_arpa_inet___inet__inet_addr = 616; // native
const uint32_t C_arpa_inet___inet__inet_network = 617; // native
const uint32_t C_arpa_inet___inet__inet_ntoa = 618; // native
const uint32_t C_arpa_inet___inet__inet_aton = 619; // native
const uint32_t C_arpa_inet___inet__inet_ntop4 = 620; // native
const uint32_t C_arpa_inet___inet__inet_ntop6 = 621; // native
const uint32_t C_arpa_inet___inet__inet_pton4 = 622; // native
const uint32_t C_arpa_inet___inet__inet_pton6 = 623; // native
const uint32_t C_fcntl___fcntl_O_RDONLY_get = 630; // native
const uint32_t C_fcntl___fcntl_O_WRONLY_get = 631; // native
const uint32_t C_fcntl___fcntl_O_RDWR_get = 632; // native
const uint32_t C_fcntl___fcntl_O_ACCMODE_get = 633; // native
const uint32_t C_fcntl___fcntl_O_APPEND_get = 634; // native
const uint32_t C_fcntl___fcntl_O_CREAT_get = 635; // native
const uint32_t C_fcntl___fcntl_O_TRUNC_get = 636; // native
const uint32_t C_fcntl___fcntl_O_EXCL_get = 637; // native
const uint32_t C_fcntl___fcntl_O_EXEC_get = 638; // native
const uint32_t C_fcntl___fcntl_O_CLOEXEC_get = 639; // native
const uint32_t C_fcntl___fcntl_O_DIRECTORY_get = 640; // native
const uint32_t C_fcntl___fcntl_O_NOFOLLOW_get = 641; // native
const uint32_t C_fcntl___fcntl_O_NONBLOCK_get = 642; // native
const uint32_t C_fcntl___fcntl_O_NOCTTY_get = 643; // native
const uint32_t C_fcntl___fcntl_O_SEARCH_get = 644; // native
const uint32_t C_fcntl___fcntl_O_TTY_INIT_get = 645; // native
const uint32_t C_fcntl___fcntl_O_SYNC_get = 646; // native
const uint32_t C_fcntl___fcntl_O_DSYNC_get = 647; // native
const uint32_t C_fcntl___fcntl_O_RSYNC_get = 648; // native
const uint32_t C_fcntl___fcntl_O_ASYNC_get = 649; // native
const uint32_t C_fcntl___fcntl_O_FSYNC_get = 650; // native
const uint32_t C_fcntl___fcntl_O_SHLOCK_get = 651; // native
const uint32_t C_fcntl___fcntl_O_EXLOCK_get = 652; // native
const uint32_t C_fcntl___fcntl_O_TEXT_get = 653; // native
const uint32_t C_fcntl___fcntl_O_BINARY_get = 654; // native
const uint32_t C_fcntl___fcntl_O_WTEXT_get = 655; // native
const uint32_t C_fcntl___fcntl_O_U16TEXT_get = 656; // native
const uint32_t C_fcntl___fcntl_O_U8TEXT_get = 657; // native
const uint32_t C_fcntl___fcntl_O_RAW_get = 658; // native
const uint32_t C_fcntl___fcntl_O_NOINHERIT_get = 659; // native
const uint32_t C_fcntl___fcntl_O_TEMPORARY_get = 660; // native
const uint32_t C_fcntl___fcntl_O_SHORT_LIVED_get = 661; // native
const uint32_t C_fcntl___fcntl_O_SEQUENTIAL_get = 662; // native
const uint32_t C_fcntl___fcntl_O_RANDOM_get = 663; // native
const uint32_t C_fcntl___fcntl_F_DUPFD_get = 664; // native
const uint32_t C_fcntl___fcntl_F_DUPFD_CLOEXEC_get = 665; // native
const uint32_t C_fcntl___fcntl_F_GETFD_get = 666; // native
const uint32_t C_fcntl___fcntl_F_SETFD_get = 667; // native
const uint32_t C_fcntl___fcntl_F_GETFL_get = 668; // native
const uint32_t C_fcntl___fcntl_F_SETFL_get = 669; // native
const uint32_t C_fcntl___fcntl_F_GETOWN_get = 670; // native
const uint32_t C_fcntl___fcntl_F_SETOWN_get = 671; // native
const uint32_t C_netdb___netdb_AI_PASSIVE_get = 674; // native
const uint32_t C_netdb___netdb_AI_CANONNAME_get = 675; // native
const uint32_t C_netdb___netdb_AI_NUMERICHOST_get = 676; // native
const uint32_t C_netdb___netdb_AI_NUMERICSERV_get = 677; // native
const uint32_t C_netdb___netdb_AI_V4MAPPED_get = 678; // native
const uint32_t C_netdb___netdb_AI_ALL_get = 679; // native
const uint32_t C_netdb___netdb_AI_ADDRCONFIG_get = 680; // native
const uint32_t C_netdb___netdb_NI_NOFQDN_get = 681; // native
const uint32_t C_netdb___netdb_NI_NUMERICHOST_get = 682; // native
const uint32_t C_netdb___netdb_NI_NAMEREQD_get = 683; // native
const uint32_t C_netdb___netdb_NI_NUMERICSERV_get = 684; // native
const uint32_t C_netdb___netdb_NI_NUMERICSCOPE_get = 685; // native
const uint32_t C_netdb___netdb_NI_DGRAM_get = 686; // native
const uint32_t C_netdb___netdb_EAI_AGAIN_get = 687; // native
const uint32_t C_netdb___netdb_EAI_BADFLAGS_get = 688; // native
const uint32_t C_netdb___netdb_EAI_FAIL_get = 689; // native
const uint32_t C_netdb___netdb_EAI_FAMILY_get = 690; // native
const uint32_t C_netdb___netdb_EAI_MEMORY_get = 691; // native
const uint32_t C_netdb___netdb_EAI_NONAME_get = 692; // native
const uint32_t C_netdb___netdb_EAI_SERVICE_get = 693; // native
const uint32_t C_netdb___netdb_EAI_SOCKTYPE_get = 694; // native
const uint32_t C_netdb___netdb_EAI_SYSTEM_get = 695; // native
const uint32_t C_netdb___netdb_EAI_OVERFLOW_get = 696; // native
const uint32_t C_netdb___netdb_gethostbyaddr4 = 697; // native
const uint32_t C_netdb___netdb_gethostbyaddr6 = 698; // native
const uint32_t C_netdb_hostent_h_addr_get = 702; // abc
const uint32_t C_netdb_hostent_toString = 703; // abc
const uint32_t C_netdb_protoent_toString = 707; // abc
const uint32_t C_netdb_addrinfo_toString = 713; // abc
const uint32_t C_netdb_CEAIrror_errorID_get = 716; // abc
const uint32_t C_netdb_CEAIrror_apply = 717; // abc
const uint32_t C_netdb_CEAIrror_toString = 718; // abc
const uint32_t C_netinet___netinet_IPPROTO_IP_get = 720; // native
const uint32_t C_netinet___netinet_IPPROTO_IPV6_get = 721; // native
const uint32_t C_netinet___netinet_IPPROTO_ICMP_get = 722; // native
const uint32_t C_netinet___netinet_IPPROTO_RAW_get = 723; // native
const uint32_t C_netinet___netinet_IPPROTO_TCP_get = 724; // native
const uint32_t C_netinet___netinet_IPPROTO_UDP_get = 725; // native
const uint32_t C_netinet___netinet_INET_ADDRSTRLEN_get = 726; // native
const uint32_t C_netinet___netinet_INET6_ADDRSTRLEN_get = 727; // native
const uint32_t C_netinet___netinet_IPV6_JOIN_GROUP_get = 728; // native
const uint32_t C_netinet___netinet_IPV6_LEAVE_GROUP_get = 729; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_HOPS_get = 730; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_IF_get = 731; // native
const uint32_t C_netinet___netinet_IPV6_MULTICAST_LOOP_get = 732; // native
const uint32_t C_netinet___netinet_IPV6_UNICAST_HOPS_get = 733; // native
const uint32_t C_netinet___netinet_IPV6_V6ONLY_get = 734; // native
const uint32_t C_netinet_in_addr_private__tohex = 738; // abc
const uint32_t C_netinet_in_addr_isValid = 739; // abc
const uint32_t C_netinet_in_addr_toString = 740; // abc
const uint32_t C_netinet_sockaddr_in_toString = 743; // abc
const uint32_t C_netinet_in6_addr_fromArray = 745; // abc
const uint32_t C_netinet_in6_addr_fromVarArgs = 746; // abc
const uint32_t C_netinet_in6_addr_private__tohex = 748; // abc
const uint32_t C_netinet_in6_addr_isValid = 749; // abc
const uint32_t C_netinet_in6_addr_toString = 750; // abc
const uint32_t C_netinet_sockaddr_in6_toString = 753; // abc
const uint32_t C_spawn_pid_t_valueOf = 757; // abc
const uint32_t C_spawn_pid_t_toString = 758; // abc
const uint32_t C_sys_select___select_FD_SETSIZE_get = 761; // native
const uint32_t C_sys_select_timeval_toString = 765; // abc
const uint32_t C_sys_socket___socket_SOCK_DGRAM_get = 769; // native
const uint32_t C_sys_socket___socket_SOCK_RAW_get = 770; // native
const uint32_t C_sys_socket___socket_SOCK_SEQPACKET_get = 771; // native
const uint32_t C_sys_socket___socket_SOCK_STREAM_get = 772; // native
const uint32_t C_sys_socket___socket_SOL_SOCKET_get = 773; // native
const uint32_t C_sys_socket___socket_SO_ACCEPTCONN_get = 774; // native
const uint32_t C_sys_socket___socket_SO_BROADCAST_get = 775; // native
const uint32_t C_sys_socket___socket_SO_DEBUG_get = 776; // native
const uint32_t C_sys_socket___socket_SO_DONTROUTE_get = 777; // native
const uint32_t C_sys_socket___socket_SO_ERROR_get = 778; // native
const uint32_t C_sys_socket___socket_SO_KEEPALIVE_get = 779; // native
const uint32_t C_sys_socket___socket_SO_LINGER_get = 780; // native
const uint32_t C_sys_socket___socket_SO_OOBINLINE_get = 781; // native
const uint32_t C_sys_socket___socket_SO_RCVBUF_get = 782; // native
const uint32_t C_sys_socket___socket_SO_RCVLOWAT_get = 783; // native
const uint32_t C_sys_socket___socket_SO_RCVTIMEO_get = 784; // native
const uint32_t C_sys_socket___socket_SO_REUSEADDR_get = 785; // native
const uint32_t C_sys_socket___socket_SO_SNDBUF_get = 786; // native
const uint32_t C_sys_socket___socket_SO_SNDLOWAT_get = 787; // native
const uint32_t C_sys_socket___socket_SO_SNDTIMEO_get = 788; // native
const uint32_t C_sys_socket___socket_SO_TYPE_get = 789; // native
const uint32_t C_sys_socket___socket_SOMAXCONN_get = 790; // native
const uint32_t C_sys_socket___socket_MSG_CTRUNC_get = 791; // native
const uint32_t C_sys_socket___socket_MSG_DONTROUTE_get = 792; // native
const uint32_t C_sys_socket___socket_MSG_EOR_get = 793; // native
const uint32_t C_sys_socket___socket_MSG_OOB_get = 794; // native
const uint32_t C_sys_socket___socket_MSG_NOSIGNAL_get = 795; // native
const uint32_t C_sys_socket___socket_MSG_PEEK_get = 796; // native
const uint32_t C_sys_socket___socket_MSG_TRUNC_get = 797; // native
const uint32_t C_sys_socket___socket_MSG_WAITALL_get = 798; // native
const uint32_t C_sys_socket___socket_AF_INET_get = 799; // native
const uint32_t C_sys_socket___socket_AF_INET6_get = 800; // native
const uint32_t C_sys_socket___socket_AF_UNIX_get = 801; // native
const uint32_t C_sys_socket___socket_AF_UNSPEC_get = 802; // native
const uint32_t C_sys_socket___socket_SHUT_RD_get = 803; // native
const uint32_t C_sys_socket___socket_SHUT_RDWR_get = 804; // native
const uint32_t C_sys_socket___socket_SHUT_WR_get = 805; // native
const uint32_t C_sys_socket___socket_accept4 = 806; // native
const uint32_t C_sys_socket___socket_accept6 = 807; // native
const uint32_t C_sys_socket___socket_bind4 = 808; // native
const uint32_t C_sys_socket___socket_bind6 = 809; // native
const uint32_t C_sys_socket___socket_connect4 = 810; // native
const uint32_t C_sys_socket___socket_connect6 = 811; // native
const uint32_t C_sys_socket___socket_getpeername4 = 812; // native
const uint32_t C_sys_socket___socket_getpeername6 = 813; // native
const uint32_t C_sys_socket___socket_getsockname4 = 814; // native
const uint32_t C_sys_socket___socket_getsockname6 = 815; // native
const uint32_t C_sys_socket___socket_getsockoptint = 816; // native
const uint32_t C_sys_socket___socket_recvfrom4 = 817; // native
const uint32_t C_sys_socket___socket_recvfrom6 = 818; // native
const uint32_t C_sys_socket___socket_sendto4 = 819; // native
const uint32_t C_sys_socket___socket_sendto6 = 820; // native
const uint32_t C_sys_socket___socket_setsockoptint = 821; // native
const uint32_t C_sys_socket_sockaddr_private__load = 825; // abc
const uint32_t C_sys_socket_sockaddr_toSockaddr_storage = 826; // abc
const uint32_t C_sys_socket_sockaddr_toSockaddr_in = 827; // abc
const uint32_t C_sys_socket_sockaddr_toSockaddr_in6 = 828; // abc
const uint32_t C_sys_socket_sockaddr_toSockaddr = 829; // abc
const uint32_t C_sys_stat___stat_mkdir = 835; // native
const uint32_t C_sys_stat_status_toString = 838; // abc
const uint32_t C_sys_wait___wait_WCONTINUED_get = 843; // native
const uint32_t C_sys_wait___wait_WNOHANG_get = 844; // native
const uint32_t C_sys_wait___wait_WUNTRACED_get = 845; // native
const uint32_t C_sys_wait___wait_WEXITED_get = 846; // native
const uint32_t C_sys_wait___wait_WNOWAIT_get = 847; // native
const uint32_t C_sys_wait___wait_WSTOPPED_get = 848; // native
const uint32_t C_sys_wait___wait_P_ALL_get = 849; // native
const uint32_t C_sys_wait___wait_P_PGID_get = 850; // native
const uint32_t C_sys_wait___wait_P_PID_get = 851; // native
const uint32_t C_sys_wait___wait__WEXITSTATUS = 852; // native
const uint32_t C_sys_wait___wait__WIFCONTINUED = 853; // native
const uint32_t C_sys_wait___wait__WIFEXITED = 854; // native
const uint32_t C_sys_wait___wait__WIFSIGNALED = 855; // native
const uint32_t C_sys_wait___wait__WIFSTOPPED = 856; // native
const uint32_t C_sys_wait___wait__WSTOPSIG = 857; // native
const uint32_t C_sys_wait___wait__WTERMSIG = 858; // native
const uint32_t C_unistd___unistd_F_OK_get = 863; // native
const uint32_t C_unistd___unistd_X_OK_get = 864; // native
const uint32_t C_unistd___unistd_W_OK_get = 865; // native
const uint32_t C_unistd___unistd_R_OK_get = 866; // native
const uint32_t C_unistd___unistd_getcwd = 867; // native
const uint32_t C_unistd___unistd_gethostname = 868; // native
const uint32_t C_unistd___unistd_getlogin = 869; // native
const uint32_t C_unistd___unistd_getpid = 870; // native
const uint32_t C_unistd___unistd_rmdir = 871; // native
const uint32_t C_unistd___unistd_sleep = 872; // native
const uint32_t C_unistd___unistd_unlink = 873; // native
const uint32_t shell_Program_private__getArgv = 876; // native
const uint32_t shell_Program_private__getEnviron = 877; // native
const uint32_t shell_Program_private__getProgramFilename = 878; // native
const uint32_t shell_Program_private__setExitListener = 879; // native
const uint32_t shell_Program_private__popenRead = 880; // native
const uint32_t shell_Program_totalMemory_get = 881; // native
const uint32_t shell_Program_freeMemory_get = 882; // native
const uint32_t shell_Program_privateMemory_get = 883; // native
const uint32_t shell_Program_environ_get = 884; // abc
const uint32_t shell_Program_pid_get = 885; // abc
const uint32_t shell_Program_shell_get = 886; // abc
const uint32_t shell_Program_workingDirectory_get = 887; // abc
const uint32_t shell_Program_workingDirectory_set = 888; // abc
const uint32_t shell_Program_atExit = 889; // abc
const uint32_t shell_Program_AVM2_setExitListener = 890; // abc
const uint32_t shell_Program_AVM2_setShell = 891; // abc
const uint32_t shell_Program_AVM2_selfCheck = 892; // abc
const uint32_t shell_Program_abort = 893; // native
const uint32_t shell_Program_exec = 894; // native
const uint32_t shell_Program_exit = 895; // native
const uint32_t shell_Program_open = 896; // abc
const uint32_t shell_Program_sleep = 897; // native
const uint32_t shell_Program_getNanosecondTimer = 898; // native
const uint32_t shell_Program_getTimer = 899; // native
const uint32_t shell_Program_readLine = 900; // native
const uint32_t shell_Program_write = 901; // native
const uint32_t shell_Program_writeLine = 902; // abc
const uint32_t shell_Program_trace = 903; // native
const uint32_t shell_Program_forceFullCollection = 904; // native
const uint32_t shell_Program_queueCollection = 905; // native
const uint32_t shell_Program_pauseForGCIfCollectionImminent = 906; // native
const uint32_t shell_Program_disposeXML = 907; // native
const uint32_t shell_Runtime_private__getAvmplusPlatform = 910; // native
const uint32_t shell_Runtime_private__getAvmplusArchitecture = 911; // native
const uint32_t shell_Runtime_private__getAvmplusVersion = 912; // native
const uint32_t shell_Runtime_private__getAvmplusDescription = 913; // native
const uint32_t shell_Runtime_private__getFeatures = 914; // native
const uint32_t shell_Runtime_private__getRunmode = 915; // native
const uint32_t shell_Runtime_private__getEndian = 916; // native
const uint32_t shell_Runtime_apiVersion_get = 917; // native
const uint32_t shell_Runtime_api_get = 918; // abc
const uint32_t shell_Runtime_swfVersion_get = 919; // native
const uint32_t shell_Runtime_platform_get = 920; // abc
const uint32_t shell_Runtime_architecture_get = 921; // abc
const uint32_t shell_Runtime_version_get = 922; // abc
const uint32_t shell_Runtime_description_get = 923; // abc
const uint32_t shell_Runtime_features_get = 924; // abc
const uint32_t shell_Runtime_runmode_get = 925; // abc
const uint32_t shell_Runtime_endian_get = 926; // abc
const uint32_t shell_Runtime_redtamarin_get = 927; // abc
const uint32_t shell_Runtime_loop_get = 928; // abc
const uint32_t shell_Runtime_loop_set = 929; // abc
const uint32_t shell_Runtime_eval = 930; // native
const uint32_t shell_Runtime_returnEval = 931; // native
const uint32_t shell_Runtime_is64bit = 932; // native
const uint32_t shell_Diagnostics_private__isGlobal = 935; // native
const uint32_t shell_Diagnostics_private__isIntptr = 936; // native
const uint32_t shell_Diagnostics_private__canonicalizeNumber = 937; // native
const uint32_t shell_Diagnostics_private__deopt = 938; // native
const uint32_t shell_Diagnostics_private__runInSafepoint = 939; // native
const uint32_t shell_Diagnostics_private__log = 940; // native
const uint32_t shell_Diagnostics_private__initializeLogging = 941; // native
const uint32_t shell_Diagnostics_debugger = 942; // native
const uint32_t shell_Diagnostics_isDebugger = 943; // native
const uint32_t shell_Diagnostics_AVM2_log = 944; // abc
const uint32_t shell_Diagnostics_AVM2_initializeLogging = 945; // abc
const uint32_t shell_Diagnostics_AVM2_isGlobal = 946; // abc
const uint32_t shell_Diagnostics_AVM2_isIntptr = 947; // abc
const uint32_t shell_Diagnostics_AVM2_canonicalizeNumber = 948; // abc
const uint32_t shell_Diagnostics_AVM2_deopt = 949; // abc
const uint32_t shell_Diagnostics_AVM2_runInSafepoint = 950; // abc
const uint32_t shell_HardwareInformation_private__getProcessorCountAtBoot = 953; // native
const uint32_t shell_HardwareInformation_private__getMemorySize = 954; // native
const uint32_t shell_HardwareInformation_private__getMemoryUsage = 955; // native
const uint32_t shell_HardwareInformation_private__getMemoryPeakUsage = 956; // native
const uint32_t shell_HardwareInformation_processors_get = 957; // abc
const uint32_t shell_HardwareInformation_memory_get = 958; // abc
const uint32_t shell_HardwareInformation_memoryUsage_get = 959; // abc
const uint32_t shell_HardwareInformation_memoryPeakUsage_get = 960; // abc
const uint32_t shell_OperatingSystem_private_getVendorAll = 963; // abc
const uint32_t shell_OperatingSystem_isWindowsStore = 964; // native
const uint32_t shell_OperatingSystem_hostname_get = 965; // abc
const uint32_t shell_OperatingSystem_vendor_get = 966; // abc
const uint32_t shell_FileSystem_private__isAttributeHidden = 969; // native
const uint32_t shell_FileSystem_private__getLogicalDrives = 970; // native
const uint32_t shell_FileSystem_private__findLogicalDrives = 971; // abc
const uint32_t shell_FileSystem_private__findRootDirectory = 972; // abc
const uint32_t shell_FileSystem_private__findHomeDirectory = 973; // abc
const uint32_t shell_FileSystem_private__filterWithRegexp = 975; // abc
const uint32_t shell_FileSystem_drives_get = 976; // abc
const uint32_t shell_FileSystem_lineEnding_get = 977; // abc
const uint32_t shell_FileSystem_rootDirectory_get = 978; // abc
const uint32_t shell_FileSystem_homeDirectory_get = 979; // abc
const uint32_t shell_FileSystem_separators_get = 980; // abc
const uint32_t shell_FileSystem_pathSeparator_get = 981; // abc
const uint32_t shell_FileSystem_nativeRead = 982; // native
const uint32_t shell_FileSystem_nativeWrite = 983; // native
const uint32_t shell_FileSystem_nativeReadByteArray = 984; // native
const uint32_t shell_FileSystem_nativeWriteByteArray = 985; // native
const uint32_t shell_FileSystem_absolutePath = 986; // abc
const uint32_t shell_FileSystem_normalizePath = 987; // abc
const uint32_t shell_FileSystem_getBasenameFromPath = 988; // abc
const uint32_t shell_FileSystem_getDirectoryFromPath = 989; // abc
const uint32_t shell_FileSystem_getComponentsFromPath = 990; // abc
const uint32_t shell_FileSystem_containsPath = 991; // abc
const uint32_t shell_FileSystem_create = 992; // abc
const uint32_t shell_FileSystem_createByteArray = 993; // abc
const uint32_t shell_FileSystem_createDirectory = 994; // abc
const uint32_t shell_FileSystem_copyFile = 995; // abc
const uint32_t shell_FileSystem_copyFiles = 996; // abc
const uint32_t shell_FileSystem_bufferedCopyFile = 997; // abc
const uint32_t shell_FileSystem_bufferedFastCopyFile = 998; // abc
const uint32_t shell_FileSystem_copyDirectory = 999; // abc
const uint32_t shell_FileSystem_exists = 1000; // abc
const uint32_t shell_FileSystem_move = 1001; // abc
const uint32_t shell_FileSystem_remove = 1002; // abc
const uint32_t shell_FileSystem_removeFile = 1003; // abc
const uint32_t shell_FileSystem_removeDirectory = 1004; // abc
const uint32_t shell_FileSystem_read = 1005; // abc
const uint32_t shell_FileSystem_readByteArray = 1006; // abc
const uint32_t shell_FileSystem_bufferedReadByteArray = 1007; // abc
const uint32_t shell_FileSystem_write = 1008; // abc
const uint32_t shell_FileSystem_writeByteArray = 1009; // abc
const uint32_t shell_FileSystem_bufferedWriteByteArray = 1010; // abc
const uint32_t shell_FileSystem_canAccess = 1011; // abc
const uint32_t shell_FileSystem_canRead = 1012; // abc
const uint32_t shell_FileSystem_canWrite = 1013; // abc
const uint32_t shell_FileSystem_hasDriveLetter = 1014; // abc
const uint32_t shell_FileSystem_getFileMode = 1015; // abc
const uint32_t shell_FileSystem_getFileAccessTime = 1016; // abc
const uint32_t shell_FileSystem_getFileModifiedTime = 1017; // abc
const uint32_t shell_FileSystem_getFileChangedTime = 1018; // abc
const uint32_t shell_FileSystem_getFileSize = 1019; // abc
const uint32_t shell_FileSystem_getSize = 1020; // abc
const uint32_t shell_FileSystem_getDirectorySize = 1021; // abc
const uint32_t shell_FileSystem_getFreeDiskSpace = 1022; // native
const uint32_t shell_FileSystem_getTotalDiskSpace = 1023; // native
const uint32_t shell_FileSystem_getUsedDiskSpace = 1024; // abc
const uint32_t shell_FileSystem_isRegularFile = 1025; // abc
const uint32_t shell_FileSystem_isRegularFileMode = 1026; // abc
const uint32_t shell_FileSystem_isDirectory = 1027; // abc
const uint32_t shell_FileSystem_isDirectoryMode = 1028; // abc
const uint32_t shell_FileSystem_isHidden = 1029; // abc
const uint32_t shell_FileSystem_isDotOrDotdot = 1030; // abc
const uint32_t shell_FileSystem_isSeparator = 1031; // abc
const uint32_t shell_FileSystem_isEmptyDirectory = 1032; // abc
const uint32_t shell_FileSystem_isValidWindowsComponent = 1033; // abc
const uint32_t shell_FileSystem_isValidMacintoshComponent = 1034; // abc
const uint32_t shell_FileSystem_isValidLinuxComponent = 1035; // abc
const uint32_t shell_FileSystem_isValidComponent = 1036; // abc
const uint32_t shell_FileSystem_isValidEverywhereComponent = 1037; // abc
const uint32_t shell_FileSystem_isValid = 1038; // abc
const uint32_t shell_FileSystem_isValidEverywhere = 1039; // abc
const uint32_t shell_FileSystem_endsWithSeparator = 1040; // abc
const uint32_t shell_FileSystem_ensureEndsWithSeparator = 1041; // abc
const uint32_t shell_FileSystem_stripTrailingSeparators = 1042; // abc
const uint32_t shell_FileSystem_listFilesOrDirectories = 1043; // abc
const uint32_t shell_FileSystem_listFilesOrDirectoriesWithFilter = 1044; // abc
const uint32_t shell_FileSystem_listFilesOrDirectoriesWithRegexp = 1045; // abc
const uint32_t shell_FileSystem_listFiles = 1046; // abc
const uint32_t shell_FileSystem_listFilesWithFilter = 1047; // abc
const uint32_t shell_FileSystem_listFilesWithRegexp = 1048; // abc
const uint32_t shell_FileSystem_listDirectories = 1049; // abc
const uint32_t shell_FileSystem_listDirectoriesWithFilter = 1050; // abc
const uint32_t shell_FileSystem_listDirectoriesWithRegexp = 1051; // abc
const uint32_t shell_FileSystem_listByDepth = 1052; // abc
const uint32_t shell_FileSystem_listByBreadth = 1053; // abc
const uint32_t shell_Domain_currentDomain_get = 1058; // native
const uint32_t shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get = 1059; // native
const uint32_t shell_Domain_private_init = 1060; // native
const uint32_t shell_Domain_parentDomain_get = 1062; // abc
const uint32_t shell_Domain_loadBytes = 1063; // native
const uint32_t shell_Domain_getClass = 1064; // native
const uint32_t shell_Domain_getDefinition = 1065; // abc
const uint32_t shell_Domain_hasDefinition = 1066; // abc
const uint32_t shell_Domain_load = 1067; // abc
const uint32_t shell_Domain_domainMemory_get = 1068; // native
const uint32_t shell_Domain_domainMemory_set = 1069; // native
const uint32_t shell_Environment_private__parse = 1072; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_callProperty = 1073; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_deleteProperty = 1074; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_getProperty = 1075; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_setProperty = 1076; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_hasProperty = 1077; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextNameIndex = 1078; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextName = 1079; // abc
const uint32_t shell_Environment_http___www_adobe_com_2006_actionscript_flash_proxy_nextValue = 1080; // abc
const uint32_t shell_Environment_length_get = 1081; // abc
const uint32_t shell_Environment_refresh = 1082; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_get = 1086; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_running_set = 1087; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_get = 1088; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frequency_set = 1089; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_get = 1090; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timers_set = 1091; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_frame_get = 1092; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_started_get = 1093; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_elapsed_get = 1094; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_timerPending_get = 1095; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_setCallback = 1096; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_handleTimers = 1097; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_start = 1098; // abc
const uint32_t shell_async_EventLoop_shell_async_EventLoop_stop = 1099; // abc
const uint32_t flash_accessibility_ISearchableText_flash_accessibility_ISearchableText_searchText_get = 1102; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionAnchorIndex_get = 1105; // abc
const uint32_t flash_accessibility_ISimpleTextSelection_flash_accessibility_ISimpleTextSelection_selectionActiveIndex_get = 1106; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accRole = 1112; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accName = 1113; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accValue = 1114; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accState = 1115; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accDefaultAction = 1116; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accDoDefaultAction = 1117; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_isLabeledBy = 1118; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_getChildIDArray = 1119; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accLocation = 1120; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accSelection = 1121; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_accFocus = 1122; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_accSelect = 1123; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionAnchorIndex = 1124; // abc
const uint32_t flash_accessibility_AccessibilityImplementation_get_selectionActiveIndex = 1125; // abc
const uint32_t flash_data_EncryptedLocalStore_isSupported_get = 1129; // abc
const uint32_t flash_display_Scene_name_get = 1179; // abc
const uint32_t flash_display_Scene_labels_get = 1180; // abc
const uint32_t flash_display_Scene_numFrames_get = 1181; // abc
const uint32_t flash_errors_SQLError_operation_get = 1208; // abc
const uint32_t flash_errors_SQLError_details_get = 1209; // abc
const uint32_t flash_errors_SQLError_detailID_get = 1210; // abc
const uint32_t flash_errors_SQLError_detailArguments_get = 1211; // abc
const uint32_t flash_errors_DRMManagerError_subErrorID_get = 1214; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_addEventListener = 1216; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_dispatchEvent = 1217; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_hasEventListener = 1218; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_removeEventListener = 1219; // abc
const uint32_t flash_events_IEventDispatcher_flash_events_IEventDispatcher_willTrigger = 1220; // abc
const uint32_t flash_events_Event_private_ctor = 1224; // abc
const uint32_t flash_events_Event_type_get = 1225; // abc
const uint32_t flash_events_Event_bubbles_get = 1226; // abc
const uint32_t flash_events_Event_cancelable_get = 1227; // abc
const uint32_t flash_events_Event_target_get = 1228; // abc
const uint32_t flash_events_Event_currentTarget_get = 1229; // abc
const uint32_t flash_events_Event_eventPhase_get = 1230; // abc
const uint32_t flash_events_Event_formatToString = 1231; // abc
const uint32_t flash_events_Event_clone = 1232; // abc
const uint32_t flash_events_Event_isDefaultPrevented = 1233; // abc
const uint32_t flash_events_Event_preventDefault = 1234; // abc
const uint32_t flash_events_Event_stopImmediatePropagation = 1235; // abc
const uint32_t flash_events_Event_stopPropagation = 1236; // abc
const uint32_t flash_events_Event_toString = 1237; // abc
const uint32_t flash_filesystem_File_isDummy = 1239; // native
const uint32_t flash_filesystem_File_isLocalDummy = 1240; // native
const uint32_t flash_filesystem_File_url_get = 1242; // abc
const uint32_t flash_filesystem_File_url_set = 1243; // abc
const uint32_t flash_filesystem_File_nativePath_get = 1244; // abc
const uint32_t flash_filesystem_File_nativePath_set = 1245; // abc
const uint32_t flash_filesystem_FileStream_open = 1250; // abc
const uint32_t flash_filesystem_FileStream_openAsync = 1251; // abc
const uint32_t flash_filesystem_FileStream_truncate = 1252; // abc
const uint32_t flash_filesystem_FileStream_close = 1253; // abc
const uint32_t flash_geom_Point_interpolate = 1257; // abc
const uint32_t flash_geom_Point_distance = 1258; // abc
const uint32_t flash_geom_Point_polar = 1259; // abc
const uint32_t flash_geom_Point_length_get = 1261; // abc
const uint32_t flash_geom_Point_clone = 1262; // abc
const uint32_t flash_geom_Point_offset = 1263; // abc
const uint32_t flash_geom_Point_equals = 1264; // abc
const uint32_t flash_geom_Point_subtract = 1265; // abc
const uint32_t flash_geom_Point_add = 1266; // abc
const uint32_t flash_geom_Point_normalize = 1267; // abc
const uint32_t flash_geom_Point_toString = 1268; // abc
const uint32_t flash_geom_Rectangle_left_get = 1271; // abc
const uint32_t flash_geom_Rectangle_left_set = 1272; // abc
const uint32_t flash_geom_Rectangle_right_get = 1273; // abc
const uint32_t flash_geom_Rectangle_right_set = 1274; // abc
const uint32_t flash_geom_Rectangle_top_get = 1275; // abc
const uint32_t flash_geom_Rectangle_top_set = 1276; // abc
const uint32_t flash_geom_Rectangle_bottom_get = 1277; // abc
const uint32_t flash_geom_Rectangle_bottom_set = 1278; // abc
const uint32_t flash_geom_Rectangle_topLeft_get = 1279; // abc
const uint32_t flash_geom_Rectangle_topLeft_set = 1280; // abc
const uint32_t flash_geom_Rectangle_bottomRight_get = 1281; // abc
const uint32_t flash_geom_Rectangle_bottomRight_set = 1282; // abc
const uint32_t flash_geom_Rectangle_size_get = 1283; // abc
const uint32_t flash_geom_Rectangle_size_set = 1284; // abc
const uint32_t flash_geom_Rectangle_clone = 1285; // abc
const uint32_t flash_geom_Rectangle_isEmpty = 1286; // abc
const uint32_t flash_geom_Rectangle_setEmpty = 1287; // abc
const uint32_t flash_geom_Rectangle_inflate = 1288; // abc
const uint32_t flash_geom_Rectangle_inflatePoint = 1289; // abc
const uint32_t flash_geom_Rectangle_offset = 1290; // abc
const uint32_t flash_geom_Rectangle_offsetPoint = 1291; // abc
const uint32_t flash_geom_Rectangle_contains = 1292; // abc
const uint32_t flash_geom_Rectangle_containsPoint = 1293; // abc
const uint32_t flash_geom_Rectangle_containsRect = 1294; // abc
const uint32_t flash_geom_Rectangle_intersection = 1295; // abc
const uint32_t flash_geom_Rectangle_intersects = 1296; // abc
const uint32_t flash_geom_Rectangle_union = 1297; // abc
const uint32_t flash_geom_Rectangle_equals = 1298; // abc
const uint32_t flash_geom_Rectangle_toString = 1299; // abc
const uint32_t flash_net_FileReference_isDummy = 1301; // native
const uint32_t flash_net_FileReference_isLocalDummy = 1302; // native
const uint32_t flash_net_FileReference_private__reset = 1304; // abc
const uint32_t flash_net_FileReference_creationDate_get = 1305; // abc
const uint32_t flash_net_FileReference_creator_get = 1306; // abc
const uint32_t flash_net_FileReference_modificationDate_get = 1307; // abc
const uint32_t flash_net_FileReference_name_get = 1308; // abc
const uint32_t flash_net_FileReference_size_get = 1309; // abc
const uint32_t flash_net_FileReference_type_get = 1310; // abc
const uint32_t flash_net_FileReference_data_get = 1311; // abc
const uint32_t flash_net_FileReference_extension_get = 1312; // abc
const uint32_t flash_net_FileReference_browse = 1313; // abc
const uint32_t flash_net_FileReference_AVM2_browseOverride = 1314; // abc
const uint32_t flash_net_FileReference_private__load = 1315; // abc
const uint32_t flash_net_FileReference_load = 1316; // abc
const uint32_t flash_net_FileReference_private__save = 1317; // abc
const uint32_t flash_net_FileReference_save = 1318; // abc
const uint32_t flash_net_FileReference_AVM2_saveOverride = 1319; // abc
const uint32_t flash_net_FileReference_uploadUnencoded = 1320; // abc
const uint32_t flash_net_URLRequest_private_setRequestHeaders = 1323; // abc
const uint32_t flash_net_URLRequest_private_filterRequestHeaders = 1324; // abc
const uint32_t flash_net_URLRequest_requestHeaders_get = 1325; // abc
const uint32_t flash_net_URLRequest_requestHeaders_set = 1326; // abc
const uint32_t flash_net_URLRequest_userAgent_get = 1327; // abc
const uint32_t flash_net_URLRequest_userAgent_set = 1328; // abc
const uint32_t flash_net_URLRequestDefaults_private_initLoginCredentials = 1330; // abc
const uint32_t flash_net_URLRequestDefaults_private_initUA = 1331; // abc
const uint32_t flash_net_URLRequestDefaults_setLoginCredentialsForHost = 1332; // abc
const uint32_t flash_net_URLRequestDefaults_followRedirects_get = 1333; // abc
const uint32_t flash_net_URLRequestDefaults_followRedirects_set = 1334; // abc
const uint32_t flash_net_URLRequestDefaults_idleTimeout_get = 1335; // abc
const uint32_t flash_net_URLRequestDefaults_idleTimeout_set = 1336; // abc
const uint32_t flash_sampler_StackFrame_toString = 1341; // abc
const uint32_t flash_system_Capabilities_avHardwareDisable_get = 1348; // abc
const uint32_t flash_system_Capabilities_cpuArchitecture_get = 1349; // abc
const uint32_t flash_system_Capabilities_manufacturer_get = 1350; // abc
const uint32_t flash_system_Capabilities_playerType_get = 1351; // abc
const uint32_t flash_system_Capabilities_isDebugger_get = 1352; // abc
const uint32_t flash_system_Capabilities_supports32BitProcesses_get = 1353; // abc
const uint32_t flash_system_Capabilities_supports64BitProcesses_get = 1354; // abc
const uint32_t flash_system_Capabilities_hasMultiChannelAudio = 1355; // abc
const uint32_t flash_system_Security_sandboxType_get = 1358; // abc
const uint32_t flash_system_Security_AVM2_sandboxType_set = 1359; // abc
const uint32_t flash_system_System_setClipboard = 1364; // abc
const uint32_t flash_system_System_totalMemory_get = 1365; // abc
const uint32_t flash_system_System_totalMemoryNumber_get = 1366; // abc
const uint32_t flash_system_System_freeMemory_get = 1367; // native
const uint32_t flash_system_System_privateMemory_get = 1368; // abc
const uint32_t flash_system_System_useCodePage_get = 1369; // abc
const uint32_t flash_system_System_useCodePage_set = 1370; // abc
const uint32_t flash_system_System_vmVersion_get = 1371; // abc
const uint32_t flash_system_System_pause = 1372; // abc
const uint32_t flash_system_System_resume = 1373; // abc
const uint32_t flash_system_System_exit = 1374; // abc
const uint32_t flash_system_System_gc = 1375; // abc
const uint32_t flash_system_System_disposeXML = 1376; // abc
const uint32_t flash_system_WorkerState_code = 1379; // abc
const uint32_t flash_system_Worker_current_get = 1382; // abc
const uint32_t flash_system_Worker_pr = 1383; // native
const uint32_t flash_system_Worker_state_get = 1385; // native
const uint32_t flash_system_Worker_start = 1386; // native
const uint32_t flash_system_Worker_isParentOf = 1387; // native
const uint32_t flash_system_Worker_isPrimordial_get = 1388; // native
const uint32_t flash_system_Worker_setSharedProperty = 1389; // native
const uint32_t flash_system_Worker_getSharedProperty = 1390; // native
const uint32_t flash_system_Worker_terminate = 1391; // native
const uint32_t flash_system_WorkerEvent_currentState_get = 1394; // abc
const uint32_t flash_system_WorkerEvent_previousState_get = 1395; // abc
const uint32_t flash_system_WorkerEvent_target_get = 1396; // abc
const uint32_t flash_system_WorkerDomain_current_get = 1398; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromByteArray = 1400; // abc
const uint32_t flash_system_WorkerDomain_createWorkerFromPrimordial = 1401; // abc
const uint32_t flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal = 1402; // native
const uint32_t flash_system_WorkerDomain_listWorkers = 1403; // native
const uint32_t flash_trace_Trace_setLevel = 1405; // native
const uint32_t flash_trace_Trace_getLevel = 1406; // native
const uint32_t flash_trace_Trace_setListener = 1407; // native
const uint32_t flash_trace_Trace_getListener = 1408; // native
const uint32_t shell_async_CoreEventLoop_running_get = 1414; // abc
const uint32_t shell_async_CoreEventLoop_running_set = 1415; // abc
const uint32_t shell_async_CoreEventLoop_frequency_get = 1416; // abc
const uint32_t shell_async_CoreEventLoop_frequency_set = 1417; // abc
const uint32_t shell_async_CoreEventLoop_timers_get = 1418; // abc
const uint32_t shell_async_CoreEventLoop_timers_set = 1419; // abc
const uint32_t shell_async_CoreEventLoop_frame_get = 1420; // abc
const uint32_t shell_async_CoreEventLoop_started_get = 1421; // abc
const uint32_t shell_async_CoreEventLoop_elapsed_get = 1422; // abc
const uint32_t shell_async_CoreEventLoop_private_tick = 1423; // abc
const uint32_t shell_async_CoreEventLoop_setCallback = 1424; // abc
const uint32_t shell_async_CoreEventLoop_private__loop = 1425; // abc
const uint32_t shell_async_CoreEventLoop_timerPending_get = 1426; // abc
const uint32_t shell_async_CoreEventLoop_handleTimers = 1427; // abc
const uint32_t shell_async_CoreEventLoop_start = 1428; // abc
const uint32_t shell_async_CoreEventLoop_stop = 1429; // abc
const uint32_t flash_events_EventDispatcher_private_trimHeaderValue = 1431; // abc
const uint32_t flash_events_EventDispatcher_private_ctor = 1433; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchEventFunction = 1434; // abc
const uint32_t flash_events_EventDispatcher_private_dispatchHttpStatusEvent = 1436; // abc
const uint32_t flash_events_EventDispatcher_addEventListener = 1437; // abc
const uint32_t flash_events_EventDispatcher_dispatchEvent = 1438; // abc
const uint32_t flash_events_EventDispatcher_hasEventListener = 1439; // abc
const uint32_t flash_events_EventDispatcher_removeEventListener = 1440; // abc
const uint32_t flash_events_EventDispatcher_willTrigger = 1441; // abc
const uint32_t flash_events_EventDispatcher_toString = 1442; // abc
const uint32_t flash_events_HTTPStatusEvent_status_get = 1445; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_get = 1446; // abc
const uint32_t flash_events_HTTPStatusEvent_responseURL_set = 1447; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_get = 1448; // abc
const uint32_t flash_events_HTTPStatusEvent_responseHeaders_set = 1449; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_get = 1450; // abc
const uint32_t flash_events_HTTPStatusEvent_redirected_set = 1451; // abc
const uint32_t flash_events_HTTPStatusEvent_clone = 1452; // abc
const uint32_t flash_events_HTTPStatusEvent_toString = 1453; // abc
const uint32_t flash_events_TimerEvent_clone = 1456; // abc
const uint32_t flash_events_TimerEvent_toString = 1457; // abc
const uint32_t flash_events_TimerEvent_updateAfterEvent = 1458; // abc
const uint32_t flash_sampler_NewObjectSample_object_get = 1460; // native
const uint32_t flash_sampler_NewObjectSample_size_get = 1461; // native
const uint32_t flash_utils_Timer_private__timerDispatch = 1467; // abc
const uint32_t flash_utils_Timer_private__start = 1468; // abc
const uint32_t flash_utils_Timer_tick = 1469; // abc
const uint32_t flash_utils_Timer_delay_get = 1470; // abc
const uint32_t flash_utils_Timer_delay_set = 1471; // abc
const uint32_t flash_utils_Timer_repeatCount_get = 1472; // abc
const uint32_t flash_utils_Timer_repeatCount_set = 1473; // abc
const uint32_t flash_utils_Timer_currentCount_get = 1474; // abc
const uint32_t flash_utils_Timer_running_get = 1475; // abc
const uint32_t flash_utils_Timer_reset = 1476; // abc
const uint32_t flash_utils_Timer_start = 1477; // abc
const uint32_t flash_utils_Timer_stop = 1478; // abc

extern avmplus::Atom native_script_function_C_assert__debugBreak_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_assert__debugBreak_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalnum_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalnum_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalpha_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isalpha_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isblank_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isblank_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_iscntrl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_iscntrl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isgraph_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isgraph_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_islower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_islower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isprint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isprint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_ispunct_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_ispunct_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isspace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isspace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isxdigit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_isxdigit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toascii_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toascii_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_tolower_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_tolower_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toupper_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_ctype___ctype__avm_toupper_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPERM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPERM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOENT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOENT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINTR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINTR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENXIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENXIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_E2BIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_E2BIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHILD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHILD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAGAIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAGAIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EACCES_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EACCES_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFAULT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFAULT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTBLK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTBLK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBUSY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBUSY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EEXIST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EEXIST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXDEV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXDEV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODEV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODEV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTDIR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTDIR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISDIR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISDIR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINVAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINVAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENFILE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENFILE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMFILE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMFILE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETXTBSY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETXTBSY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFBIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EFBIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSPC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSPC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EROFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EROFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMLINK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMLINK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERANGE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERANGE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAMETOOLONG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAMETOOLONG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSYS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSYS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTEMPTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTEMPTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELOOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELOOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EWOULDBLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EWOULDBLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMSG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMSG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIDRM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EIDRM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDEADLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSTR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSTR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODATA_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENODATA_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOSR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLINK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOLINK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADMSG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADMSG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOVERFLOW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOVERFLOW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EILSEQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EILSEQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTSOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTSOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDESTADDRREQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDESTADDRREQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMSGSIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMSGSIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTOTYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTOTYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPROTOOPT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPROTOOPT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTONOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPROTONOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOPNOTSUPP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOPNOTSUPP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAFNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EAFNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRINUSE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRINUSE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRNOTAVAIL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADDRNOTAVAIL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETUNREACH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETUNREACH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETRESET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENETRESET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNABORTED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNABORTED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNRESET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNRESET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOBUFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOBUFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIMEDOUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETIMEDOUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNREFUSED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECONNREFUSED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTUNREACH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTUNREACH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EALREADY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EALREADY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINPROGRESS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EINPROGRESS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECANCELED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECANCELED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOWNERDEAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EOWNERDEAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTRECOVERABLE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTRECOVERABLE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUSERS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUSERS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESOCKTNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESOCKTNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPFNOSUPPORT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EPFNOSUPPORT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESHUTDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESHUTDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETOOMANYREFS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ETOOMANYREFS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTDOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHOSTDOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTALE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTALE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDQUOT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDQUOT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMULTIHOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMULTIHOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHRNG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECHRNG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2NSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2NSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3HLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3HLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3RST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL3RST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELNRNG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELNRNG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUNATCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUNATCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOCSI_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOCSI_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2HLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EL2HLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXFULL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EXFULL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOANO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOANO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADRQC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADRQC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADSLT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADSLT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBFONT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBFONT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENONET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENONET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPKG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOPKG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EADV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRMNT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESRMNT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECOMM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ECOMM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOTDOT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EDOTDOT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTUNIQ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTUNIQ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EBADFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMCHG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMCHG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBACC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBACC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBBAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBBAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBSCN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBSCN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBMAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBMAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ELIBEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERESTART_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERESTART_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTRPIPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ESTRPIPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUCLEAN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EUCLEAN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTNAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOTNAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAVAIL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENAVAIL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISNAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EISNAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTEIO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EREMOTEIO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEDIUM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOMEDIUM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMEDIUMTYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EMEDIUMTYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOKEY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ENOKEY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYEXPIRED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYEXPIRED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREVOKED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREVOKED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREJECTED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EKEYREJECTED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERFKILL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_ERFKILL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHWPOISON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno_EHWPOISON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__GetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__GetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__SetErrno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_errno___errno__SetErrno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHAR_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_INT_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LLONG_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LONG_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LONG_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_LONG_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SCHAR_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SHRT_MIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UCHAR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UCHAR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UINT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_UINT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_ULLONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_ULLONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ULONG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ULONG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_USHRT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_USHRT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_WORD_BIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_WORD_BIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ARG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ARG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ATEXIT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_ATEXIT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHILD_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_CHILD_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_CANON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_CANON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_INPUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MAX_INPUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NGROUPS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_NGROUPS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PIPE_BUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PIPE_BUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_SSIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_SSIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_STREAM_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_STREAM_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TZNAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TZNAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MB_LEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MB_LEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_SIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double C_limits___limits_SIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_LISTIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_LISTIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_PRIO_DELTA_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_AIO_PRIO_DELTA_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_DELAYTIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_DELAYTIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_HOST_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_HOST_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LOGIN_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_LOGIN_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_PRIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_MQ_PRIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGESIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGESIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGE_SIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_PAGE_SIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RE_DUP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RE_DUP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RTSIG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_RTSIG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_NSEMS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_NSEMS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_VALUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SEM_VALUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIGQUEUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SIGQUEUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SS_REPL_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SS_REPL_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLOOP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_SYMLOOP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_EVENT_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_EVENT_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_SYS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_SYS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_USER_EVENT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TRACE_USER_EVENT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TTY_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits_TTY_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_ARG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_ARG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_CHILD_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_CHILD_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_CANON_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_CANON_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_INPUT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MAX_INPUT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NGROUPS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_NGROUPS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PATH_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PATH_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PIPE_BUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_PIPE_BUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SSIZE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SSIZE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_STREAM_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_STREAM_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TZNAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TZNAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLINK_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLINK_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_LISTIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_LISTIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_AIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_DELAYTIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_DELAYTIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_HOST_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_HOST_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LOGIN_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_LOGIN_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_OPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_OPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_PRIO_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_MQ_PRIO_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RE_DUP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RE_DUP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RTSIG_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_RTSIG_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_NSEMS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_NSEMS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_VALUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SEM_VALUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SIGQUEUE_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SIGQUEUE_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SS_REPL_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SS_REPL_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLOOP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_SYMLOOP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TIMER_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TIMER_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_EVENT_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_SYS_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_SYS_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TRACE_USER_EVENT_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TTY_NAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_limits___limits__POSIX_TTY_NAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_locale___locale_LC_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_NONE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_SIGNAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_signal___signal_SIGEV_THREAD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_signal_kill_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_BUFSIZ_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOFBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IOLBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__IONBF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_CUR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_END_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_SEEK_SET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FILENAME_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_FOPEN_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_TMP_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_EOF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdin_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stdout_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio_stderr_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getc_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdio___stdio__getchar_unlocked_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_clearerr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fdopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_feof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ferror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fflush_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fgets_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fileno_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_flockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputc_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fputs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fread_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_freopen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fseek_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fsetpos_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdio_ftell_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_ftrylockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_funlockfile_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_fwrite_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_getchar_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_pclose_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_perror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_popen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_remove_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_remove_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdio_rewind_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_SUCCESS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_EXIT_FAILURE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_RAND_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_stdlib___stdlib_MB_CUR_MAX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atof_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_atoi_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_stdlib_atol_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_div_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_getenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_ldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_lldiv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mblen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkdtemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_mkstemp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_putenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_rand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_realpath_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_setenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_srand_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_system_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_stdlib_unsetenv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcmp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strcoll_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strerror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_string_strspn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_time___time_CLOCKS_PER_SEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__htonl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__htonl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__htons_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__htons_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__ntohl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__ntohl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__ntohs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__ntohs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_addr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_addr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_network_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_network_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntoa_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntoa_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_aton_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_aton_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntop4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntop4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntop6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_ntop6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_pton4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_pton4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_pton6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_arpa_inet___inet__inet_pton6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_canonical_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_echo_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_conio_kbhit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_closedir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_closedir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_dirfd_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_dirfd_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_fdopendir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_fdopendir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_opendir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_opendir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_readdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_readdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_rewinddir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_rewinddir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_seekdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_dirent_seekdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_dirent_telldir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_C_dirent_telldir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WRONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RDWR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ACCMODE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_APPEND_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CREAT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TRUNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXCL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CLOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_CLOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DIRECTORY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DIRECTORY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOFOLLOW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOFOLLOW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NONBLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NONBLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOCTTY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOCTTY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEARCH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEARCH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TTY_INIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TTY_INIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_DSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ASYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_ASYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_FSYNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_FSYNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXLOCK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_EXLOCK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_BINARY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WTEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_WTEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U16TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U16TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U8TEXT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_U8TEXT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOINHERIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_NOINHERIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEMPORARY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_TEMPORARY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHORT_LIVED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SHORT_LIVED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEQUENTIAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_SEQUENTIAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RANDOM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_O_RANDOM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_CLOEXEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_DUPFD_CLOEXEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETFL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETFL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_GETOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETOWN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_fcntl___fcntl_F_SETOWN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_creat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_creat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_fcntl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_fcntl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_open_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_open_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_openat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_fcntl_openat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_PASSIVE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_CANONNAME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICHOST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_NUMERICSERV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_V4MAPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_AI_ADDRCONFIG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NOFQDN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NOFQDN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICHOST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICHOST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NAMEREQD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NAMEREQD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICSERV_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICSERV_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICSCOPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_NUMERICSCOPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_DGRAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_NI_DGRAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_AGAIN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_AGAIN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_BADFLAGS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_BADFLAGS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_FAIL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_FAIL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_FAMILY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_FAMILY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_MEMORY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_MEMORY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_NONAME_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_NONAME_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SERVICE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SERVICE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SOCKTYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SOCKTYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SYSTEM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_SYSTEM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_OVERFLOW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_EAI_OVERFLOW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_gethostbyaddr4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_gethostbyaddr4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_gethostbyaddr6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netdb___netdb_gethostbyaddr6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gai_strerror_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gai_strerror_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getaddrinfo_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getaddrinfo_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostbyname_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostbyname_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_gethostent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotobynumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_netdb_getprotoent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_IPV6_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_ICMP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_TCP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPPROTO_UDP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_INET6_ADDRSTRLEN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_JOIN_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_LEAVE_GROUP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_IF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_MULTICAST_LOOP_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_UNICAST_HOPS_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_netinet___netinet_IPV6_V6ONLY_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawn_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_spawn_spawnp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_select___select_FD_SETSIZE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_select___select_FD_SETSIZE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_CLR_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_CLR_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_ISSET_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_ISSET_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_SET_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_SET_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_ZERO_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_FD_ZERO_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_select_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_select_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isReadable_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isReadable_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isWritable_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isWritable_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isExceptional_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_select_isExceptional_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_DGRAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_RAW_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_SEQPACKET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOCK_STREAM_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOL_SOCKET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOL_SOCKET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_ACCEPTCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_ACCEPTCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_BROADCAST_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_BROADCAST_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_DEBUG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_DEBUG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_DONTROUTE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_DONTROUTE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_ERROR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_ERROR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_KEEPALIVE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_KEEPALIVE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_LINGER_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_LINGER_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_OOBINLINE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_OOBINLINE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVBUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVBUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVLOWAT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVLOWAT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVTIMEO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_RCVTIMEO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_REUSEADDR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_REUSEADDR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDBUF_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDBUF_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDLOWAT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDLOWAT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDTIMEO_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_SNDTIMEO_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_TYPE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SO_TYPE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOMAXCONN_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SOMAXCONN_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_CTRUNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_CTRUNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_DONTROUTE_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_DONTROUTE_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_EOR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_EOR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_OOB_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_OOB_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_NOSIGNAL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_NOSIGNAL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_PEEK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_PEEK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_TRUNC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_TRUNC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_WAITALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_MSG_WAITALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_INET_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_INET_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_INET6_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_INET6_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_UNIX_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_UNIX_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_UNSPEC_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_AF_UNSPEC_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_RD_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_RD_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_RDWR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_RDWR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_WR_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_SHUT_WR_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_accept4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_accept4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_accept6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_accept6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_bind4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_bind4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_bind6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_bind6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_connect4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_connect4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_connect6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_connect6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getpeername4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getpeername4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getpeername6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getpeername6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockname4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockname4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockname6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockname6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockoptint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_getsockoptint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_recvfrom4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_recvfrom4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_recvfrom6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_recvfrom6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_sendto4_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_sendto4_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_sendto6_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_sendto6_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_setsockoptint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_socket___socket_setsockoptint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_listen_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_listen_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_recv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_recv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_send_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_send_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_shutdown_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_shutdown_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_sockatmark_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_sockatmark_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_socket_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_socket_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_socketpair_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_socket_socketpair_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat_mkdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_stat___stat_mkdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_chmod_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_fstat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_stat_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_stat_umask_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_utsname_uname_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_utsname_uname_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WCONTINUED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOHANG_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WUNTRACED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WEXITED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WNOWAIT_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_WSTOPPED_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_ALL_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PGID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait_P_PID_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WEXITSTATUS_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFCONTINUED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFEXITED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSIGNALED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WIFSTOPPED_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WSTOPSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_sys_wait___wait__WTERMSIG_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_wait_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_sys_wait_waitpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_F_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_X_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_W_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_R_OK_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getcwd_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_gethostname_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getlogin_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_getpid_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_rmdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom C_unistd___unistd_unlink_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_access_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_chdir_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_close_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_dup2_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execl_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execle_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execlp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execve_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_execvp_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_fsync_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_C_unistd_ftruncate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getArgv_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getEnviron_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__getProgramFilename_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__setExitListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_private__popenRead_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_totalMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_privateMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_abort_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exec_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_exit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_sleep_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_Program_getNanosecondTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_getTimer_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_readLine_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_write_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_trace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_forceFullCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_queueCollection_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_pauseForGCIfCollectionImminent_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Program_disposeXML_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusPlatform_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusArchitecture_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusVersion_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getAvmplusDescription_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getFeatures_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getRunmode_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_private__getEndian_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_apiVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_swfVersion_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_eval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_returnEval_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Runtime_is64bit_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isGlobal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__isIntptr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__canonicalizeNumber_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__deopt_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__runInSafepoint_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__log_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_private__initializeLogging_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_debugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Diagnostics_isDebugger_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_HardwareInformation_private__getProcessorCountAtBoot_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemorySize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_HardwareInformation_private__getMemoryPeakUsage_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_OperatingSystem_isWindowsStore_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_private__isAttributeHidden_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_private__isAttributeHidden_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_private__getLogicalDrives_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_private__getLogicalDrives_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeRead_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeRead_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeWrite_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeWrite_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeReadByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeReadByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeWriteByteArray_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_FileSystem_nativeWriteByteArray_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_FileSystem_getFreeDiskSpace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_FileSystem_getFreeDiskSpace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_FileSystem_getTotalDiskSpace_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double shell_FileSystem_getTotalDiskSpace_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_currentDomain_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_MIN_DOMAIN_MEMORY_LENGTH_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_private_init_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_loadBytes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_getClass_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom shell_Domain_domainMemory_set_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_filesystem_File_isDummy_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_filesystem_File_isDummy_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_filesystem_File_isLocalDummy_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_filesystem_File_isLocalDummy_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_net_FileReference_isDummy_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_net_FileReference_isDummy_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_net_FileReference_isLocalDummy_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_net_FileReference_isLocalDummy_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_sampler_NewObjectSample_object_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_sampler_NewObjectSample_size_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_clearSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_startSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_stopSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_pauseSampling_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_sampleInternalAllocs_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__setSamplerCallback_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSize_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMemberNames_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler__getSamples_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler_getSampleCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double native_script_function_flash_sampler__getInvocationCount_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_isGetterSetter_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getLexicalScopes_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getSavedThis_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom native_script_function_flash_sampler_getMasterString_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern double flash_system_System_freeMemory_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_pr_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_state_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_start_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isParentOf_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_isPrimordial_get_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_setSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_getSharedProperty_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_Worker_terminate_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_private_createWorkerFromByteArrayInternal_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_system_WorkerDomain_listWorkers_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getLevel_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_setListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
extern avmplus::Atom flash_trace_Trace_getListener_sampler_thunk(MethodEnv* env, uint32_t argc, Atom* argv);
class SlotOffsetsAndAsserts;
//-----------------------------------------------------------
// C.ctype::__ctype$
//-----------------------------------------------------------
class avmshell_CTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CTypeClass;
};
#define DECLARE_SLOTS_CTypeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__ctypeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__ctypeObject>((avmplus::__ctypeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.ctype::__ctype
//-----------------------------------------------------------
class avmplus___ctypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__ctypeObject;
#define GC_TRIVIAL_TRACER___ctypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::__errno$
//-----------------------------------------------------------
class avmshell_CErrnoClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CErrnoClass;
};
#define DECLARE_SLOTS_CErrnoClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__errnoObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__errnoObject>((avmplus::__errnoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::__errno
//-----------------------------------------------------------
class avmplus___errnoObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__errnoObject;
#define GC_TRIVIAL_TRACER___errnoObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::ErrorNumber$
//-----------------------------------------------------------
class avmplus_ErrorNumberClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberClass;
#define GC_TRIVIAL_TRACER_ErrorNumberClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::ErrorNumber
//-----------------------------------------------------------
class avmplus_ErrorNumberObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ErrorNumberObject;
private:
    uint32_t m_private__value;
#define GC_TRIVIAL_TRACER_ErrorNumberObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError$
//-----------------------------------------------------------
class avmshell_CErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CErrorClass;
private:
    int32_t m_length;
};
#define DECLARE_SLOTS_CErrorClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CErrorObject> constructObject(avmplus::Atom arg1, avmplus::Atom arg2) \
        { \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1, arg2 }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CErrorObject> constructObject(avmplus::Atom arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1 }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CErrorObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CErrorObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CErrorObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CErrorObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CErrorObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CErrorObject>((avmshell::CErrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_length() const { return m_slots_CErrorClass.m_length; } \
        REALLY_INLINE void setconst_length(int32_t newVal) { m_slots_CErrorClass.m_length = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CErrorClassSlots m_slots_CErrorClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.errno::CError
//-----------------------------------------------------------
class avmshell_CErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CErrorObject;
private:
    int32_t m_private__errorID;
};
#define DECLARE_SLOTS_CErrorObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline void call_apply(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::MethodEnv* const method = vtable->methods[6]; \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = method->coerceEnter(1, args); \
            AvmAssert(result == undefinedAtom); (void)result; \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE int32_t get__errorID() const { return m_slots_CErrorObject.m_private__errorID; } \
        REALLY_INLINE void set__errorID(int32_t newVal) { m_slots_CErrorObject.m_private__errorID = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CErrorObjectSlots m_slots_CErrorObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits$
//-----------------------------------------------------------
class avmshell_CLimitsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLimitsClass;
};
#define DECLARE_SLOTS_CLimitsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__limitsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__limitsObject>((avmplus::__limitsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.limits::__limits
//-----------------------------------------------------------
class avmplus___limitsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__limitsObject;
#define GC_TRIVIAL_TRACER___limitsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale$
//-----------------------------------------------------------
class avmshell_CLocaleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CLocaleClass;
};
#define DECLARE_SLOTS_CLocaleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__localeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__localeObject>((avmplus::__localeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.locale::__locale
//-----------------------------------------------------------
class avmplus___localeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__localeObject;
#define GC_TRIVIAL_TRACER___localeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal$
//-----------------------------------------------------------
class avmshell_CSignalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSignalClass;
};
#define DECLARE_SLOTS_CSignalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__signalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__signalObject>((avmplus::__signalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::__signal
//-----------------------------------------------------------
class avmplus___signalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__signalObject;
#define GC_TRIVIAL_TRACER___signalObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval$
//-----------------------------------------------------------
class avmshell_CsigvalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalClass;
};
#define DECLARE_SLOTS_CsigvalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CsigvalObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsigvalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CsigvalObject>((avmshell::CsigvalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::sigval
//-----------------------------------------------------------
class avmshell_CsigvalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsigvalObject;
private:
    int32_t m_sival_int;
};
#define DECLARE_SLOTS_CsigvalObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_sival_int() const { return m_slots_CsigvalObject.m_sival_int; } \
        REALLY_INLINE void set_sival_int(int32_t newVal) { m_slots_CsigvalObject.m_sival_int = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CsigvalObjectSlots m_slots_CsigvalObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t$
//-----------------------------------------------------------
class avmshell_Csiginfo_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tClass;
};
#define DECLARE_SLOTS_Csiginfo_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Csiginfo_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Csiginfo_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Csiginfo_tObject>((avmshell::Csiginfo_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.signal::siginfo_t
//-----------------------------------------------------------
class avmshell_Csiginfo_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Csiginfo_tObject;
private:
    int32_t m_si_signo;
    int32_t m_si_code;
    int32_t m_si_errno;
    int32_t m_si_pid;
    int32_t m_si_uid;
    int32_t m_si_status;
    double m_si_band;
};
#define DECLARE_SLOTS_Csiginfo_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_si_signo() const { return m_slots_Csiginfo_tObject.m_si_signo; } \
        REALLY_INLINE void set_si_signo(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_signo = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_code() const { return m_slots_Csiginfo_tObject.m_si_code; } \
        REALLY_INLINE void set_si_code(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_code = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_errno() const { return m_slots_Csiginfo_tObject.m_si_errno; } \
        REALLY_INLINE void set_si_errno(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_errno = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_pid() const { return m_slots_Csiginfo_tObject.m_si_pid; } \
        REALLY_INLINE void set_si_pid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_pid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_uid() const { return m_slots_Csiginfo_tObject.m_si_uid; } \
        REALLY_INLINE void set_si_uid(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_si_status() const { return m_slots_Csiginfo_tObject.m_si_status; } \
        REALLY_INLINE void set_si_status(int32_t newVal) { m_slots_Csiginfo_tObject.m_si_status = newVal; } \
    public: \
        REALLY_INLINE double get_si_band() const { return m_slots_Csiginfo_tObject.m_si_band; } \
        REALLY_INLINE void set_si_band(double newVal) { m_slots_Csiginfo_tObject.m_si_band = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Csiginfo_tObjectSlots m_slots_Csiginfo_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio$
//-----------------------------------------------------------
class avmshell_CStdioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdioClass;
};
#define DECLARE_SLOTS_CStdioClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdioObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdioObject>((avmplus::__stdioObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::__stdio
//-----------------------------------------------------------
class avmplus___stdioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdioObject;
#define GC_TRIVIAL_TRACER___stdioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE$
//-----------------------------------------------------------
class avmshell_CFILEClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEClass;
};
#define DECLARE_SLOTS_CFILEClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CFILEObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CFILEObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CFILEObject>((avmshell::CFILEObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::FILE
//-----------------------------------------------------------
class avmshell_CFILEObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFILEObject;
};
#define DECLARE_SLOTS_CFILEObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t$
//-----------------------------------------------------------
class avmshell_Cfpos_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tClass;
};
#define DECLARE_SLOTS_Cfpos_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cfpos_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfpos_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfpos_tObject>((avmshell::Cfpos_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdio::fpos_t
//-----------------------------------------------------------
class avmshell_Cfpos_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfpos_tObject;
};
#define DECLARE_SLOTS_Cfpos_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib$
//-----------------------------------------------------------
class avmshell_CStdlibClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStdlibClass;
};
#define DECLARE_SLOTS_CStdlibClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__stdlibObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__stdlibObject>((avmplus::__stdlibObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::__stdlib
//-----------------------------------------------------------
class avmplus___stdlibObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__stdlibObject;
#define GC_TRIVIAL_TRACER___stdlibObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t$
//-----------------------------------------------------------
class avmshell_Cdiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tClass;
};
#define DECLARE_SLOTS_Cdiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cdiv_tObject> constructObject(int32_t arg1, int32_t arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Cdiv_tObject> constructObject(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Cdiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cdiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cdiv_tObject>((avmshell::Cdiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::div_t
//-----------------------------------------------------------
class avmshell_Cdiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cdiv_tObject;
private:
    int32_t m_quot;
    int32_t m_rem;
};
#define DECLARE_SLOTS_Cdiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_quot() const { return m_slots_Cdiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(int32_t newVal) { m_slots_Cdiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE int32_t get_rem() const { return m_slots_Cdiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(int32_t newVal) { m_slots_Cdiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cdiv_tObjectSlots m_slots_Cdiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t$
//-----------------------------------------------------------
class avmshell_Cldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tClass;
};
#define DECLARE_SLOTS_Cldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cldiv_tObject> constructObject(double arg1, double arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->doubleToAtom(arg1), core->doubleToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Cldiv_tObject> constructObject(double arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->doubleToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Cldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cldiv_tObject>((avmshell::Cldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::ldiv_t
//-----------------------------------------------------------
class avmshell_Cldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Cldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Cldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Cldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Cldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Cldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cldiv_tObjectSlots m_slots_Cldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t$
//-----------------------------------------------------------
class avmshell_Clldiv_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tClass;
};
#define DECLARE_SLOTS_Clldiv_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Clldiv_tObject> constructObject(double arg1, double arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->doubleToAtom(arg1), core->doubleToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Clldiv_tObject> constructObject(double arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->doubleToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::Clldiv_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Clldiv_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Clldiv_tObject>((avmshell::Clldiv_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.stdlib::lldiv_t
//-----------------------------------------------------------
class avmshell_Clldiv_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Clldiv_tObject;
private:
    double m_quot;
    double m_rem;
};
#define DECLARE_SLOTS_Clldiv_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE double get_quot() const { return m_slots_Clldiv_tObject.m_quot; } \
        REALLY_INLINE void set_quot(double newVal) { m_slots_Clldiv_tObject.m_quot = newVal; } \
    public: \
        REALLY_INLINE double get_rem() const { return m_slots_Clldiv_tObject.m_rem; } \
        REALLY_INLINE void set_rem(double newVal) { m_slots_Clldiv_tObject.m_rem = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Clldiv_tObjectSlots m_slots_Clldiv_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time$
//-----------------------------------------------------------
class avmshell_CTimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CTimeClass;
};
#define DECLARE_SLOTS_CTimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__timeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__timeObject>((avmplus::__timeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::__time
//-----------------------------------------------------------
class avmplus___timeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__timeObject;
#define GC_TRIVIAL_TRACER___timeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::tm$
//-----------------------------------------------------------
class avmplus_tmClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::tmClass;
#define GC_TRIVIAL_TRACER_tmClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::tm
//-----------------------------------------------------------
class avmplus_tmObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::tmObject;
private:
    int32_t m_tm_sec;
    int32_t m_tm_min;
    int32_t m_tm_hour;
    int32_t m_tm_mday;
    int32_t m_tm_mon;
    int32_t m_tm_year;
    int32_t m_tm_wday;
    int32_t m_tm_yday;
    int32_t m_tm_isdst;
#define GC_TRIVIAL_TRACER_tmObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::timespec$
//-----------------------------------------------------------
class avmplus_timespecClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::timespecClass;
#define GC_TRIVIAL_TRACER_timespecClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::timespec
//-----------------------------------------------------------
class avmplus_timespecObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::timespecObject;
private:
    int32_t m_tv_sec;
    double m_tv_nsec;
#define GC_TRIVIAL_TRACER_timespecObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::itimerspec$
//-----------------------------------------------------------
class avmplus_itimerspecClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::itimerspecClass;
#define GC_TRIVIAL_TRACER_itimerspecClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.time::itimerspec
//-----------------------------------------------------------
class avmplus_itimerspecObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::itimerspecObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::timespecObject> m_it_interval;
    MMgc::GCTraceableObject::GCMember<avmplus::timespecObject> m_it_value;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_it_interval);
        gc->TraceLocation(&m_it_value);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.arpa.inet::__inet$
//-----------------------------------------------------------
class avmshell_CArpaInetClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CArpaInetClass;
};
#define DECLARE_SLOTS_CArpaInetClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__inetObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__inetObject>((avmplus::__inetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__inetObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__inetObject>((avmplus::__inetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__inetObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__inetObject>((avmplus::__inetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__inetObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__inetObject>((avmplus::__inetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.arpa.inet::__inet
//-----------------------------------------------------------
class avmplus___inetObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__inetObject;
#define GC_TRIVIAL_TRACER___inetObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::DIR$
//-----------------------------------------------------------
class avmshell_CDIRClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CDIRClass;
};
#define DECLARE_SLOTS_CDIRClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CDIRObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CDIRObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CDIRObject>((avmshell::CDIRObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::DIR
//-----------------------------------------------------------
class avmshell_CDIRObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CDIRObject;
};
#define DECLARE_SLOTS_CDIRObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::dirent$
//-----------------------------------------------------------
class avmshell_CdirentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CdirentClass;
};
#define DECLARE_SLOTS_CdirentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CdirentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CdirentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CdirentObject>((avmshell::CdirentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.dirent::dirent
//-----------------------------------------------------------
class avmshell_CdirentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CdirentObject;
private:
    uint32_t m_d_ino;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_d_name;
};
#define DECLARE_SLOTS_CdirentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE uint32_t get_d_ino() const { return m_slots_CdirentObject.m_d_ino; } \
        REALLY_INLINE void set_d_ino(uint32_t newVal) { m_slots_CdirentObject.m_d_ino = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_d_name() const { return m_slots_CdirentObject.m_d_name; } \
        REALLY_INLINE void set_d_name(avmplus::String* newVal) { m_slots_CdirentObject.m_d_name = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CdirentObjectSlots m_slots_CdirentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl$
//-----------------------------------------------------------
class avmshell_CFcntlClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CFcntlClass;
};
#define DECLARE_SLOTS_CFcntlClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__fcntlObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__fcntlObject>((avmplus::__fcntlObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.fcntl::__fcntl
//-----------------------------------------------------------
class avmplus___fcntlObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__fcntlObject;
#define GC_TRIVIAL_TRACER___fcntlObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb$
//-----------------------------------------------------------
class avmshell_CNetdbClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetdbClass;
};
#define DECLARE_SLOTS_CNetdbClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netdbObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netdbObject>((avmplus::__netdbObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::__netdb
//-----------------------------------------------------------
class avmplus___netdbObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netdbObject;
#define GC_TRIVIAL_TRACER___netdbObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent$
//-----------------------------------------------------------
class avmshell_ChostentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentClass;
};
#define DECLARE_SLOTS_ChostentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ChostentObject> constructObject(GCRef<avmplus::String> arg1, GCRef<avmplus::ArrayObject> arg2, int32_t arg3, int32_t arg4, GCRef<avmplus::ArrayObject> arg5) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[6] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom(), arg2.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg3), core->intToAtom(arg4), arg5.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(5, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::ChostentObject> constructObject(GCRef<avmplus::String> arg1, GCRef<avmplus::ArrayObject> arg2, int32_t arg3, int32_t arg4) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[5] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom(), arg2.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg3), core->intToAtom(arg4) }; \
            avmplus::Atom const result = this->construct(4, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::ChostentObject> constructObject(GCRef<avmplus::String> arg1, GCRef<avmplus::ArrayObject> arg2, int32_t arg3) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[4] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom(), arg2.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg3) }; \
            avmplus::Atom const result = this->construct(3, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::ChostentObject> constructObject(GCRef<avmplus::String> arg1, GCRef<avmplus::ArrayObject> arg2) \
        { \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom(), arg2.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::ChostentObject> constructObject(GCRef<avmplus::String> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::ChostentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ChostentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ChostentObject>((avmshell::ChostentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::hostent
//-----------------------------------------------------------
class avmshell_ChostentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ChostentObject;
private:
    int32_t m_h_addrtype;
    int32_t m_h_length;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_h_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_aliases;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_h_addr_list;
};
#define DECLARE_SLOTS_ChostentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_h_addrtype() const { return m_slots_ChostentObject.m_h_addrtype; } \
        REALLY_INLINE void set_h_addrtype(int32_t newVal) { m_slots_ChostentObject.m_h_addrtype = newVal; } \
    public: \
        REALLY_INLINE int32_t get_h_length() const { return m_slots_ChostentObject.m_h_length; } \
        REALLY_INLINE void set_h_length(int32_t newVal) { m_slots_ChostentObject.m_h_length = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_h_name() const { return m_slots_ChostentObject.m_h_name; } \
        REALLY_INLINE void set_h_name(avmplus::String* newVal) { m_slots_ChostentObject.m_h_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_aliases() const { return m_slots_ChostentObject.m_h_aliases; } \
        REALLY_INLINE void set_h_aliases(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_aliases = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_h_addr_list() const { return m_slots_ChostentObject.m_h_addr_list; } \
        REALLY_INLINE void set_h_addr_list(avmplus::ArrayObject* newVal) { m_slots_ChostentObject.m_h_addr_list = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ChostentObjectSlots m_slots_ChostentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent$
//-----------------------------------------------------------
class avmplus_netentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentClass;
#define GC_TRIVIAL_TRACER_netentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::netent
//-----------------------------------------------------------
class avmplus_netentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::netentObject;
#define GC_TRIVIAL_TRACER_netentObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent$
//-----------------------------------------------------------
class avmshell_CprotoentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentClass;
};
#define DECLARE_SLOTS_CprotoentClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CprotoentObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CprotoentObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CprotoentObject>((avmshell::CprotoentObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::protoent
//-----------------------------------------------------------
class avmshell_CprotoentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CprotoentObject;
private:
    int32_t m_p_proto;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_p_name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_p_aliases;
};
#define DECLARE_SLOTS_CprotoentObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_p_proto() const { return m_slots_CprotoentObject.m_p_proto; } \
        REALLY_INLINE void set_p_proto(int32_t newVal) { m_slots_CprotoentObject.m_p_proto = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_p_name() const { return m_slots_CprotoentObject.m_p_name; } \
        REALLY_INLINE void set_p_name(avmplus::String* newVal) { m_slots_CprotoentObject.m_p_name = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_p_aliases() const { return m_slots_CprotoentObject.m_p_aliases; } \
        REALLY_INLINE void set_p_aliases(avmplus::ArrayObject* newVal) { m_slots_CprotoentObject.m_p_aliases = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CprotoentObjectSlots m_slots_CprotoentObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent$
//-----------------------------------------------------------
class avmplus_serventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventClass;
#define GC_TRIVIAL_TRACER_serventClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::servent
//-----------------------------------------------------------
class avmplus_serventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::serventObject;
#define GC_TRIVIAL_TRACER_serventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo$
//-----------------------------------------------------------
class avmshell_CaddrinfoClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CaddrinfoClass;
};
#define DECLARE_SLOTS_CaddrinfoClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, uint32_t arg5, avmplus::Atom arg6, GCRef<avmplus::String> arg7) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[8] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2), core->intToAtom(arg3), core->intToAtom(arg4), core->uintToAtom(arg5), arg6, arg7->atom() }; \
            avmplus::Atom const result = this->construct(7, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, uint32_t arg5, avmplus::Atom arg6) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[7] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2), core->intToAtom(arg3), core->intToAtom(arg4), core->uintToAtom(arg5), arg6 }; \
            avmplus::Atom const result = this->construct(6, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, uint32_t arg5) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[6] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2), core->intToAtom(arg3), core->intToAtom(arg4), core->uintToAtom(arg5) }; \
            avmplus::Atom const result = this->construct(5, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[5] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2), core->intToAtom(arg3), core->intToAtom(arg4) }; \
            avmplus::Atom const result = this->construct(4, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2, int32_t arg3) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[4] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2), core->intToAtom(arg3) }; \
            avmplus::Atom const result = this->construct(3, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1, int32_t arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CaddrinfoObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CaddrinfoObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CaddrinfoObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CaddrinfoObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CaddrinfoObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CaddrinfoObject>((avmshell::CaddrinfoObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::addrinfo
//-----------------------------------------------------------
class avmshell_CaddrinfoObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CaddrinfoObject;
private:
    int32_t m_ai_flags;
    int32_t m_ai_family;
    int32_t m_ai_socktype;
    int32_t m_ai_protocol;
    uint32_t m_ai_addrlen;
    avmplus::AtomWB m_ai_addr;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ai_canonname;
};
#define DECLARE_SLOTS_CaddrinfoObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_ai_flags() const { return m_slots_CaddrinfoObject.m_ai_flags; } \
        REALLY_INLINE void set_ai_flags(int32_t newVal) { m_slots_CaddrinfoObject.m_ai_flags = newVal; } \
    public: \
        REALLY_INLINE int32_t get_ai_family() const { return m_slots_CaddrinfoObject.m_ai_family; } \
        REALLY_INLINE void set_ai_family(int32_t newVal) { m_slots_CaddrinfoObject.m_ai_family = newVal; } \
    public: \
        REALLY_INLINE int32_t get_ai_socktype() const { return m_slots_CaddrinfoObject.m_ai_socktype; } \
        REALLY_INLINE void set_ai_socktype(int32_t newVal) { m_slots_CaddrinfoObject.m_ai_socktype = newVal; } \
    public: \
        REALLY_INLINE int32_t get_ai_protocol() const { return m_slots_CaddrinfoObject.m_ai_protocol; } \
        REALLY_INLINE void set_ai_protocol(int32_t newVal) { m_slots_CaddrinfoObject.m_ai_protocol = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_ai_addrlen() const { return m_slots_CaddrinfoObject.m_ai_addrlen; } \
        REALLY_INLINE void set_ai_addrlen(uint32_t newVal) { m_slots_CaddrinfoObject.m_ai_addrlen = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_ai_addr() const { return m_slots_CaddrinfoObject.m_ai_addr; } \
        REALLY_INLINE void set_ai_addr(avmplus::Atom newVal) { m_slots_CaddrinfoObject.m_ai_addr = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_ai_canonname() const { return m_slots_CaddrinfoObject.m_ai_canonname; } \
        REALLY_INLINE void set_ai_canonname(avmplus::String* newVal) { m_slots_CaddrinfoObject.m_ai_canonname = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CaddrinfoObjectSlots m_slots_CaddrinfoObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::CEAIrror$
//-----------------------------------------------------------
class avmshell_CEAIrrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CEAIrrorClass;
private:
    int32_t m_length;
};
#define DECLARE_SLOTS_CEAIrrorClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CEAIrrorObject> constructObject(avmplus::Atom arg1, avmplus::Atom arg2) \
        { \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1, arg2 }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CEAIrrorObject> constructObject(avmplus::Atom arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1 }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CEAIrrorObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CEAIrrorObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CEAIrrorObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CEAIrrorObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CEAIrrorObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CEAIrrorObject>((avmshell::CEAIrrorObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_length() const { return m_slots_CEAIrrorClass.m_length; } \
        REALLY_INLINE void setconst_length(int32_t newVal) { m_slots_CEAIrrorClass.m_length = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CEAIrrorClassSlots m_slots_CEAIrrorClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netdb::CEAIrror
//-----------------------------------------------------------
class avmshell_CEAIrrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CEAIrrorObject;
private:
    int32_t m_private__errorID;
};
#define DECLARE_SLOTS_CEAIrrorObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline void call_apply(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::MethodEnv* const method = vtable->methods[6]; \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = method->coerceEnter(1, args); \
            AvmAssert(result == undefinedAtom); (void)result; \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE int32_t get__errorID() const { return m_slots_CEAIrrorObject.m_private__errorID; } \
        REALLY_INLINE void set__errorID(int32_t newVal) { m_slots_CEAIrrorObject.m_private__errorID = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CEAIrrorObjectSlots m_slots_CEAIrrorObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet$
//-----------------------------------------------------------
class avmshell_CNetinetInClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CNetinetInClass;
};
#define DECLARE_SLOTS_CNetinetInClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__netinetObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__netinetObject>((avmplus::__netinetObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::__netinet
//-----------------------------------------------------------
class avmplus___netinetObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__netinetObject;
#define GC_TRIVIAL_TRACER___netinetObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr$
//-----------------------------------------------------------
class avmshell_CIn_AddrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CIn_AddrClass;
};
#define DECLARE_SLOTS_CIn_AddrClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CIn_AddrObject> constructObject(uint32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CIn_AddrObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn_AddrObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn_AddrObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn_AddrObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn_AddrObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CIn_AddrObject>((avmshell::CIn_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in_addr
//-----------------------------------------------------------
class avmshell_CIn_AddrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CIn_AddrObject;
private:
    uint32_t m_s_addr;
};
#define DECLARE_SLOTS_CIn_AddrObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline bool call_isValid() \
        { \
            avmplus::MethodEnv* const method = vtable->methods[4]; \
            avmplus::Atom const result = method->coerceEnter(thisRef.reinterpretCast<avmplus::ScriptObject>()->atom()); \
            return ((result) != avmplus::falseAtom); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE uint32_t get_s_addr() const { return m_slots_CIn_AddrObject.m_s_addr; } \
        REALLY_INLINE void set_s_addr(uint32_t newVal) { m_slots_CIn_AddrObject.m_s_addr = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CIn_AddrObjectSlots m_slots_CIn_AddrObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in$
//-----------------------------------------------------------
class avmshell_CSockaddr_inClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSockaddr_inClass;
};
#define DECLARE_SLOTS_CSockaddr_inClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CSockaddr_inObject> constructObject(int32_t arg1, uint32_t arg2, GCRef<avmshell::CIn_AddrObject> arg3) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[4] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->uintToAtom(arg2), arg3.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(3, args); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_inObject> constructObject(int32_t arg1, uint32_t arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->uintToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_inObject> constructObject(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_inObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_inObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_inObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_inObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_inObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CSockaddr_inObject>((avmshell::CSockaddr_inObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in
//-----------------------------------------------------------
class avmshell_CSockaddr_inObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSockaddr_inObject;
private:
    int32_t m_sin_family;
    uint32_t m_sin_port;
    MMgc::GCTraceableObject::GCMember<avmshell::CIn_AddrObject> m_sin_addr;
};
#define DECLARE_SLOTS_CSockaddr_inObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_sin_family() const { return m_slots_CSockaddr_inObject.m_sin_family; } \
        REALLY_INLINE void set_sin_family(int32_t newVal) { m_slots_CSockaddr_inObject.m_sin_family = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_sin_port() const { return m_slots_CSockaddr_inObject.m_sin_port; } \
        REALLY_INLINE void set_sin_port(uint32_t newVal) { m_slots_CSockaddr_inObject.m_sin_port = newVal; } \
    public: \
        REALLY_INLINE avmshell::CIn_AddrObject* get_sin_addr() const { return m_slots_CSockaddr_inObject.m_sin_addr; } \
        REALLY_INLINE void set_sin_addr(avmshell::CIn_AddrObject* newVal) { m_slots_CSockaddr_inObject.m_sin_addr = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CSockaddr_inObjectSlots m_slots_CSockaddr_inObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr$
//-----------------------------------------------------------
class avmshell_CIn6_AddrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CIn6_AddrClass;
};
#define DECLARE_SLOTS_CIn6_AddrClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CIn6_AddrObject> constructObject(GCRef<avmplus::UIntVectorObject> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CIn6_AddrObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn6_AddrObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn6_AddrObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn6_AddrObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CIn6_AddrObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CIn6_AddrObject>((avmshell::CIn6_AddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::in6_addr
//-----------------------------------------------------------
class avmshell_CIn6_AddrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CIn6_AddrObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::UIntVectorObject> m_s6_addr;
};
#define DECLARE_SLOTS_CIn6_AddrObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline bool call_isValid() \
        { \
            avmplus::MethodEnv* const method = vtable->methods[4]; \
            avmplus::Atom const result = method->coerceEnter(thisRef.reinterpretCast<avmplus::ScriptObject>()->atom()); \
            return ((result) != avmplus::falseAtom); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE avmplus::UIntVectorObject* get_s6_addr() const { return m_slots_CIn6_AddrObject.m_s6_addr; } \
        REALLY_INLINE void set_s6_addr(avmplus::UIntVectorObject* newVal) { m_slots_CIn6_AddrObject.m_s6_addr = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CIn6_AddrObjectSlots m_slots_CIn6_AddrObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6$
//-----------------------------------------------------------
class avmshell_CSockaddr_in6ClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSockaddr_in6Class;
};
#define DECLARE_SLOTS_CSockaddr_in6Class \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject(uint32_t arg1, uint32_t arg2, uint32_t arg3, GCRef<avmshell::CIn6_AddrObject> arg4, uint32_t arg5) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[6] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1), core->uintToAtom(arg2), core->uintToAtom(arg3), arg4.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg5) }; \
            avmplus::Atom const result = this->construct(5, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject(uint32_t arg1, uint32_t arg2, uint32_t arg3, GCRef<avmshell::CIn6_AddrObject> arg4) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[5] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1), core->uintToAtom(arg2), core->uintToAtom(arg3), arg4.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(4, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject(uint32_t arg1, uint32_t arg2, uint32_t arg3) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[4] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1), core->uintToAtom(arg2), core->uintToAtom(arg3) }; \
            avmplus::Atom const result = this->construct(3, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject(uint32_t arg1, uint32_t arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1), core->uintToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject(uint32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CSockaddr_in6Object> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_in6Object> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_in6Object> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_in6Object> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CSockaddr_in6Object> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CSockaddr_in6Object>((avmshell::CSockaddr_in6Object*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::sockaddr_in6
//-----------------------------------------------------------
class avmshell_CSockaddr_in6ObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSockaddr_in6Object;
private:
    uint32_t m_sin6_family;
    uint32_t m_sin6_port;
    uint32_t m_sin6_flowinfo;
    uint32_t m_sin6_scope_id;
    MMgc::GCTraceableObject::GCMember<avmshell::CIn6_AddrObject> m_sin6_addr;
};
#define DECLARE_SLOTS_CSockaddr_in6Object \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE uint32_t get_sin6_family() const { return m_slots_CSockaddr_in6Object.m_sin6_family; } \
        REALLY_INLINE void set_sin6_family(uint32_t newVal) { m_slots_CSockaddr_in6Object.m_sin6_family = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_sin6_port() const { return m_slots_CSockaddr_in6Object.m_sin6_port; } \
        REALLY_INLINE void set_sin6_port(uint32_t newVal) { m_slots_CSockaddr_in6Object.m_sin6_port = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_sin6_flowinfo() const { return m_slots_CSockaddr_in6Object.m_sin6_flowinfo; } \
        REALLY_INLINE void set_sin6_flowinfo(uint32_t newVal) { m_slots_CSockaddr_in6Object.m_sin6_flowinfo = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_sin6_scope_id() const { return m_slots_CSockaddr_in6Object.m_sin6_scope_id; } \
        REALLY_INLINE void set_sin6_scope_id(uint32_t newVal) { m_slots_CSockaddr_in6Object.m_sin6_scope_id = newVal; } \
    public: \
        REALLY_INLINE avmshell::CIn6_AddrObject* get_sin6_addr() const { return m_slots_CSockaddr_in6Object.m_sin6_addr; } \
        REALLY_INLINE void set_sin6_addr(avmshell::CIn6_AddrObject* newVal) { m_slots_CSockaddr_in6Object.m_sin6_addr = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CSockaddr_in6ObjectSlots m_slots_CSockaddr_in6Object \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq$
//-----------------------------------------------------------
class avmplus_ipv6_mreqClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqClass;
#define GC_TRIVIAL_TRACER_ipv6_mreqClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.netinet::ipv6_mreq
//-----------------------------------------------------------
class avmplus_ipv6_mreqObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ipv6_mreqObject;
private:
    uint32_t m_ipv6mr_interface;
    MMgc::GCTraceableObject::GCMember<avmshell::CIn6_AddrObject> m_ipv6mr_multiaddr;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ipv6mr_multiaddr);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t$
//-----------------------------------------------------------
class avmshell_Cpid_tClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tClass;
};
#define DECLARE_SLOTS_Cpid_tClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cpid_tObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cpid_tObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cpid_tObject>((avmshell::Cpid_tObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.spawn::pid_t
//-----------------------------------------------------------
class avmshell_Cpid_tObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cpid_tObject;
private:
    int32_t m_value;
};
#define DECLARE_SLOTS_Cpid_tObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_value() const { return m_slots_Cpid_tObject.m_value; } \
        REALLY_INLINE void set_value(int32_t newVal) { m_slots_Cpid_tObject.m_value = newVal; } \
    private: \
        avmplus::NativeID::avmshell_Cpid_tObjectSlots m_slots_Cpid_tObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::__select$
//-----------------------------------------------------------
class avmshell_CSysSelectClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysSelectClass;
};
#define DECLARE_SLOTS_CSysSelectClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__selectObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__selectObject>((avmplus::__selectObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__selectObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__selectObject>((avmplus::__selectObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__selectObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__selectObject>((avmplus::__selectObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__selectObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__selectObject>((avmplus::__selectObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::__select
//-----------------------------------------------------------
class avmplus___selectObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__selectObject;
#define GC_TRIVIAL_TRACER___selectObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::timeval$
//-----------------------------------------------------------
class avmshell_CtimevalClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CtimevalClass;
};
#define DECLARE_SLOTS_CtimevalClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CtimevalObject> constructObject(int32_t arg1, int32_t arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1), core->intToAtom(arg2) }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CtimevalObject> constructObject(int32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->intToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CtimevalObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CtimevalObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CtimevalObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CtimevalObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CtimevalObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CtimevalObject>((avmshell::CtimevalObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::timeval
//-----------------------------------------------------------
class avmshell_CtimevalObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CtimevalObject;
private:
    int32_t m_tv_sec;
    int32_t m_tv_usec;
};
#define DECLARE_SLOTS_CtimevalObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_tv_sec() const { return m_slots_CtimevalObject.m_tv_sec; } \
        REALLY_INLINE void set_tv_sec(int32_t newVal) { m_slots_CtimevalObject.m_tv_sec = newVal; } \
    public: \
        REALLY_INLINE int32_t get_tv_usec() const { return m_slots_CtimevalObject.m_tv_usec; } \
        REALLY_INLINE void set_tv_usec(int32_t newVal) { m_slots_CtimevalObject.m_tv_usec = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CtimevalObjectSlots m_slots_CtimevalObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::fd_set$
//-----------------------------------------------------------
class avmshell_Cfd_setClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfd_setClass;
};
#define DECLARE_SLOTS_Cfd_setClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::Cfd_setObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::Cfd_setObject>((avmshell::Cfd_setObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfd_setObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::Cfd_setObject>((avmshell::Cfd_setObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfd_setObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfd_setObject>((avmshell::Cfd_setObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfd_setObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::Cfd_setObject>((avmshell::Cfd_setObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::Cfd_setObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::Cfd_setObject>((avmshell::Cfd_setObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.select::fd_set
//-----------------------------------------------------------
class avmshell_Cfd_setObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::Cfd_setObject;
};
#define DECLARE_SLOTS_Cfd_setObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket$
//-----------------------------------------------------------
class avmshell_CSysSocketClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysSocketClass;
};
#define DECLARE_SLOTS_CSysSocketClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__socketObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__socketObject>((avmplus::__socketObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::__socket
//-----------------------------------------------------------
class avmplus___socketObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__socketObject;
#define GC_TRIVIAL_TRACER___socketObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr$
//-----------------------------------------------------------
class avmshell_CsockaddrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsockaddrClass;
};
#define DECLARE_SLOTS_CsockaddrClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CsockaddrObject> constructObject(uint32_t arg1, avmplus::Atom arg2) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[3] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1), arg2 }; \
            avmplus::Atom const result = this->construct(2, args); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CsockaddrObject> constructObject(uint32_t arg1) \
        { \
            avmplus::AvmCore* const core = ((avmplus::AvmCore*)(this->core())); \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), core->uintToAtom(arg1) }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::CsockaddrObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CsockaddrObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsockaddrObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsockaddrObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CsockaddrObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CsockaddrObject>((avmshell::CsockaddrObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr
//-----------------------------------------------------------
class avmshell_CsockaddrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CsockaddrObject;
private:
    uint32_t m_sa_family;
    MMgc::GCTraceableObject::GCMember<avmplus::UIntVectorObject> m_sa_data;
};
#define DECLARE_SLOTS_CsockaddrObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE uint32_t get_sa_family() const { return m_slots_CsockaddrObject.m_sa_family; } \
        REALLY_INLINE void set_sa_family(uint32_t newVal) { m_slots_CsockaddrObject.m_sa_family = newVal; } \
    public: \
        REALLY_INLINE avmplus::UIntVectorObject* get_sa_data() const { return m_slots_CsockaddrObject.m_sa_data; } \
        REALLY_INLINE void set_sa_data(avmplus::UIntVectorObject* newVal) { m_slots_CsockaddrObject.m_sa_data = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CsockaddrObjectSlots m_slots_CsockaddrObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage$
//-----------------------------------------------------------
class avmplus_sockaddr_storageClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageClass;
#define GC_TRIVIAL_TRACER_sockaddr_storageClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::sockaddr_storage
//-----------------------------------------------------------
class avmplus_sockaddr_storageObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::sockaddr_storageObject;
private:
    uint32_t m_ss_family;
#define GC_TRIVIAL_TRACER_sockaddr_storageObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr$
//-----------------------------------------------------------
class avmplus_msghdrClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrClass;
#define GC_TRIVIAL_TRACER_msghdrClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.socket::msghdr
//-----------------------------------------------------------
class avmplus_msghdrObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::msghdrObject;
private:
    int32_t m_msg_namelen;
    int32_t m_msg_iovlen;
    int32_t m_msg_controllen;
    int32_t m_msg_flags;
    avmplus::AtomWB m_msg_name;
    avmplus::AtomWB m_msg_iov;
    avmplus::AtomWB m_msg_control;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceAtom(&m_msg_name);
        gc->TraceAtom(&m_msg_iov);
        gc->TraceAtom(&m_msg_control);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat$
//-----------------------------------------------------------
class avmshell_CSysStatClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysStatClass;
};
#define DECLARE_SLOTS_CSysStatClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__statObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__statObject>((avmplus::__statObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::__stat
//-----------------------------------------------------------
class avmplus___statObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__statObject;
#define GC_TRIVIAL_TRACER___statObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status$
//-----------------------------------------------------------
class avmshell_CStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusClass;
};
#define DECLARE_SLOTS_CStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CStatusObject>((avmshell::CStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.stat::status
//-----------------------------------------------------------
class avmshell_CStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CStatusObject;
private:
    int32_t m_st_dev;
    uint32_t m_st_ino;
    int32_t m_st_mode;
    int32_t m_st_nlink;
    int32_t m_st_uid;
    int32_t m_st_gid;
    int32_t m_st_rdev;
    double m_st_size;
    double m_st_atime;
    double m_st_mtime;
    double m_st_ctime;
};
#define DECLARE_SLOTS_CStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_st_dev() const { return m_slots_CStatusObject.m_st_dev; } \
        REALLY_INLINE void set_st_dev(int32_t newVal) { m_slots_CStatusObject.m_st_dev = newVal; } \
    public: \
        REALLY_INLINE uint32_t get_st_ino() const { return m_slots_CStatusObject.m_st_ino; } \
        REALLY_INLINE void set_st_ino(uint32_t newVal) { m_slots_CStatusObject.m_st_ino = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_mode() const { return m_slots_CStatusObject.m_st_mode; } \
        REALLY_INLINE void set_st_mode(int32_t newVal) { m_slots_CStatusObject.m_st_mode = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_nlink() const { return m_slots_CStatusObject.m_st_nlink; } \
        REALLY_INLINE void set_st_nlink(int32_t newVal) { m_slots_CStatusObject.m_st_nlink = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_uid() const { return m_slots_CStatusObject.m_st_uid; } \
        REALLY_INLINE void set_st_uid(int32_t newVal) { m_slots_CStatusObject.m_st_uid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_gid() const { return m_slots_CStatusObject.m_st_gid; } \
        REALLY_INLINE void set_st_gid(int32_t newVal) { m_slots_CStatusObject.m_st_gid = newVal; } \
    public: \
        REALLY_INLINE int32_t get_st_rdev() const { return m_slots_CStatusObject.m_st_rdev; } \
        REALLY_INLINE void set_st_rdev(int32_t newVal) { m_slots_CStatusObject.m_st_rdev = newVal; } \
    public: \
        REALLY_INLINE double get_st_size() const { return m_slots_CStatusObject.m_st_size; } \
        REALLY_INLINE void set_st_size(double newVal) { m_slots_CStatusObject.m_st_size = newVal; } \
    public: \
        REALLY_INLINE double get_st_atime() const { return m_slots_CStatusObject.m_st_atime; } \
        REALLY_INLINE void set_st_atime(double newVal) { m_slots_CStatusObject.m_st_atime = newVal; } \
    public: \
        REALLY_INLINE double get_st_mtime() const { return m_slots_CStatusObject.m_st_mtime; } \
        REALLY_INLINE void set_st_mtime(double newVal) { m_slots_CStatusObject.m_st_mtime = newVal; } \
    public: \
        REALLY_INLINE double get_st_ctime() const { return m_slots_CStatusObject.m_st_ctime; } \
        REALLY_INLINE void set_st_ctime(double newVal) { m_slots_CStatusObject.m_st_ctime = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CStatusObjectSlots m_slots_CStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.utsname::utsname$
//-----------------------------------------------------------
class avmplus_utsnameClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::utsnameClass;
#define GC_TRIVIAL_TRACER_utsnameClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.utsname::utsname
//-----------------------------------------------------------
class avmplus_utsnameObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::utsnameObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_sysname;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_nodename;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_release;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_version;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_machine;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_sysname);
        gc->TraceLocation(&m_nodename);
        gc->TraceLocation(&m_release);
        gc->TraceLocation(&m_version);
        gc->TraceLocation(&m_machine);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait$
//-----------------------------------------------------------
class avmshell_CSysWaitClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CSysWaitClass;
};
#define DECLARE_SLOTS_CSysWaitClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__waitObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__waitObject>((avmplus::__waitObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::__wait
//-----------------------------------------------------------
class avmplus___waitObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__waitObject;
#define GC_TRIVIAL_TRACER___waitObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status$
//-----------------------------------------------------------
class avmshell_CWaitStatusClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusClass;
};
#define DECLARE_SLOTS_CWaitStatusClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::CWaitStatusObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::CWaitStatusObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::CWaitStatusObject>((avmshell::CWaitStatusObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.sys.wait::wait_status
//-----------------------------------------------------------
class avmshell_CWaitStatusObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CWaitStatusObject;
private:
    int32_t m_stat_loc;
};
#define DECLARE_SLOTS_CWaitStatusObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_stat_loc() const { return m_slots_CWaitStatusObject.m_stat_loc; } \
        REALLY_INLINE void set_stat_loc(int32_t newVal) { m_slots_CWaitStatusObject.m_stat_loc = newVal; } \
    private: \
        avmplus::NativeID::avmshell_CWaitStatusObjectSlots m_slots_CWaitStatusObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd$
//-----------------------------------------------------------
class avmshell_CUnistdClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::CUnistdClass;
};
#define DECLARE_SLOTS_CUnistdClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::__unistdObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::__unistdObject>((avmplus::__unistdObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// C.unistd::__unistd
//-----------------------------------------------------------
class avmplus___unistdObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::__unistdObject;
#define GC_TRIVIAL_TRACER___unistdObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program$
//-----------------------------------------------------------
class avmshell_ProgramClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ProgramClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_http___code_google_com_p_redtamarin_AVM2__shell;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_http___code_google_com_p_redtamarin_AVM2__exitcall;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_argv;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_filename;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_startupDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_onExit;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_http___code_google_com_p_redtamarin_AVM2_findShell;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__shell);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2__exitcall);
        gc->TraceLocation(&m_argv);
        gc->TraceLocation(&m_filename);
        gc->TraceLocation(&m_startupDirectory);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_onExit);
        gc->TraceLocation(&m_http___code_google_com_p_redtamarin_AVM2_findShell);
    }
};
#define DECLARE_SLOTS_ProgramClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::ProgramObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::ProgramObject>((avmplus::ProgramObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::String* get__shell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell; } \
        REALLY_INLINE void set__shell(avmplus::String* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__shell = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__exitcall() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall; } \
        REALLY_INLINE void set__exitcall(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2__exitcall = newVal; } \
    public: \
        REALLY_INLINE avmplus::ArrayObject* get_argv() const { return m_slots_ProgramClass.m_argv; } \
        REALLY_INLINE void setconst_argv(avmplus::ArrayObject* newVal) { m_slots_ProgramClass.m_argv = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_filename() const { return m_slots_ProgramClass.m_filename; } \
        REALLY_INLINE void setconst_filename(avmplus::String* newVal) { m_slots_ProgramClass.m_filename = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_startupDirectory() const { return m_slots_ProgramClass.m_startupDirectory; } \
        REALLY_INLINE void setconst_startupDirectory(avmplus::String* newVal) { m_slots_ProgramClass.m_startupDirectory = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_onExit() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit; } \
        REALLY_INLINE void set_onExit(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_onExit = newVal; } \
    protected: \
        REALLY_INLINE avmplus::FunctionObject* get_findShell() const { return m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell; } \
        REALLY_INLINE void set_findShell(avmplus::FunctionObject* newVal) { m_slots_ProgramClass.m_http___code_google_com_p_redtamarin_AVM2_findShell = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ProgramClassSlots m_slots_ProgramClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Program
//-----------------------------------------------------------
class avmplus_ProgramObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ProgramObject;
#define GC_TRIVIAL_TRACER_ProgramObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime$
//-----------------------------------------------------------
class avmshell_RuntimeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::RuntimeClass;
private:
    avmplus::AtomWB m_private__localAvmplusDescription;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__API;
    MMgc::GCTraceableObject::GCMember<avmplus::EventLoopInterface> m_private__loop;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_goAsync;
};
#define DECLARE_SLOTS_RuntimeClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::RuntimeObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::RuntimeObject>((avmplus::RuntimeObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::Atom get__localAvmplusDescription() const { return m_slots_RuntimeClass.m_private__localAvmplusDescription; } \
        REALLY_INLINE void set__localAvmplusDescription(avmplus::Atom newVal) { m_slots_RuntimeClass.m_private__localAvmplusDescription = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__API() const { return m_slots_RuntimeClass.m_private__API; } \
        REALLY_INLINE void set__API(avmplus::ArrayObject* newVal) { m_slots_RuntimeClass.m_private__API = newVal; } \
    protected: \
        REALLY_INLINE avmplus::EventLoopInterface* get__loop() const { return m_slots_RuntimeClass.m_private__loop; } \
        REALLY_INLINE void set__loop(avmplus::EventLoopInterface* newVal) { m_slots_RuntimeClass.m_private__loop = newVal; } \
    public: \
        REALLY_INLINE avmplus::FunctionObject* get_goAsync() const { return m_slots_RuntimeClass.m_goAsync; } \
        REALLY_INLINE void set_goAsync(avmplus::FunctionObject* newVal) { m_slots_RuntimeClass.m_goAsync = newVal; } \
    private: \
        avmplus::NativeID::avmshell_RuntimeClassSlots m_slots_RuntimeClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Runtime
//-----------------------------------------------------------
class avmplus_RuntimeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RuntimeObject;
#define GC_TRIVIAL_TRACER_RuntimeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics$
//-----------------------------------------------------------
class avmshell_DiagnosticsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::DiagnosticsClass;
};
#define DECLARE_SLOTS_DiagnosticsClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DiagnosticsObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DiagnosticsObject>((avmplus::DiagnosticsObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Diagnostics
//-----------------------------------------------------------
class avmplus_DiagnosticsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DiagnosticsObject;
#define GC_TRIVIAL_TRACER_DiagnosticsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation$
//-----------------------------------------------------------
class avmshell_HardwareInformationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::HardwareInformationClass;
};
#define DECLARE_SLOTS_HardwareInformationClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::HardwareInformationObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::HardwareInformationObject>((avmplus::HardwareInformationObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::HardwareInformation
//-----------------------------------------------------------
class avmplus_HardwareInformationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HardwareInformationObject;
#define GC_TRIVIAL_TRACER_HardwareInformationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem$
//-----------------------------------------------------------
class avmshell_OperatingSystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::OperatingSystemClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__hostname;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__vendor;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__linuxDistros;
};
#define DECLARE_SLOTS_OperatingSystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::OperatingSystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::OperatingSystemObject>((avmplus::OperatingSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::String* get__hostname() const { return m_slots_OperatingSystemClass.m_private__hostname; } \
        REALLY_INLINE void set__hostname(avmplus::String* newVal) { m_slots_OperatingSystemClass.m_private__hostname = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__vendor() const { return m_slots_OperatingSystemClass.m_private__vendor; } \
        REALLY_INLINE void set__vendor(avmplus::String* newVal) { m_slots_OperatingSystemClass.m_private__vendor = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__linuxDistros() const { return m_slots_OperatingSystemClass.m_private__linuxDistros; } \
        REALLY_INLINE void set__linuxDistros(avmplus::ArrayObject* newVal) { m_slots_OperatingSystemClass.m_private__linuxDistros = newVal; } \
    private: \
        avmplus::NativeID::avmshell_OperatingSystemClassSlots m_slots_OperatingSystemClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::OperatingSystem
//-----------------------------------------------------------
class avmplus_OperatingSystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::OperatingSystemObject;
#define GC_TRIVIAL_TRACER_OperatingSystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileSystem$
//-----------------------------------------------------------
class avmshell_FileSystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileSystemClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__win32_separators;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__posix_separators;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__win32_pathsep;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__posix_pathsep;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__win32_lineEnding;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__posix_lineEnding;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__posix_alt_home;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__win32_reserved_chars;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__win32_reserved_words;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__macosx_reserved_chars;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__linux_reserved_chars;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__rootDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__homeDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_extensionSeparator;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_currentDirectory;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_parentDirectory;
};
#define DECLARE_SLOTS_FileSystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::FileSystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::FileSystemObject>((avmplus::FileSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileSystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::FileSystemObject>((avmplus::FileSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileSystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::FileSystemObject>((avmplus::FileSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::FileSystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::FileSystemObject>((avmplus::FileSystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__win32_separators() const { return m_slots_FileSystemClass.m_private__win32_separators; } \
        REALLY_INLINE void set__win32_separators(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__win32_separators = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__posix_separators() const { return m_slots_FileSystemClass.m_private__posix_separators; } \
        REALLY_INLINE void set__posix_separators(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__posix_separators = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__win32_pathsep() const { return m_slots_FileSystemClass.m_private__win32_pathsep; } \
        REALLY_INLINE void set__win32_pathsep(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__win32_pathsep = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__posix_pathsep() const { return m_slots_FileSystemClass.m_private__posix_pathsep; } \
        REALLY_INLINE void set__posix_pathsep(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__posix_pathsep = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__win32_lineEnding() const { return m_slots_FileSystemClass.m_private__win32_lineEnding; } \
        REALLY_INLINE void set__win32_lineEnding(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__win32_lineEnding = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__posix_lineEnding() const { return m_slots_FileSystemClass.m_private__posix_lineEnding; } \
        REALLY_INLINE void set__posix_lineEnding(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__posix_lineEnding = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__posix_alt_home() const { return m_slots_FileSystemClass.m_private__posix_alt_home; } \
        REALLY_INLINE void set__posix_alt_home(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__posix_alt_home = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__win32_reserved_chars() const { return m_slots_FileSystemClass.m_private__win32_reserved_chars; } \
        REALLY_INLINE void set__win32_reserved_chars(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__win32_reserved_chars = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__win32_reserved_words() const { return m_slots_FileSystemClass.m_private__win32_reserved_words; } \
        REALLY_INLINE void set__win32_reserved_words(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__win32_reserved_words = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__macosx_reserved_chars() const { return m_slots_FileSystemClass.m_private__macosx_reserved_chars; } \
        REALLY_INLINE void set__macosx_reserved_chars(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__macosx_reserved_chars = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ArrayObject* get__linux_reserved_chars() const { return m_slots_FileSystemClass.m_private__linux_reserved_chars; } \
        REALLY_INLINE void set__linux_reserved_chars(avmplus::ArrayObject* newVal) { m_slots_FileSystemClass.m_private__linux_reserved_chars = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__rootDirectory() const { return m_slots_FileSystemClass.m_private__rootDirectory; } \
        REALLY_INLINE void set__rootDirectory(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__rootDirectory = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__homeDirectory() const { return m_slots_FileSystemClass.m_private__homeDirectory; } \
        REALLY_INLINE void set__homeDirectory(avmplus::String* newVal) { m_slots_FileSystemClass.m_private__homeDirectory = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_extensionSeparator() const { return m_slots_FileSystemClass.m_extensionSeparator; } \
        REALLY_INLINE void setconst_extensionSeparator(avmplus::String* newVal) { m_slots_FileSystemClass.m_extensionSeparator = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_currentDirectory() const { return m_slots_FileSystemClass.m_currentDirectory; } \
        REALLY_INLINE void setconst_currentDirectory(avmplus::String* newVal) { m_slots_FileSystemClass.m_currentDirectory = newVal; } \
    public: \
        REALLY_INLINE avmplus::String* get_parentDirectory() const { return m_slots_FileSystemClass.m_parentDirectory; } \
        REALLY_INLINE void setconst_parentDirectory(avmplus::String* newVal) { m_slots_FileSystemClass.m_parentDirectory = newVal; } \
    private: \
        avmplus::NativeID::avmshell_FileSystemClassSlots m_slots_FileSystemClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::FileSystem
//-----------------------------------------------------------
class avmplus_FileSystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileSystemObject;
#define GC_TRIVIAL_TRACER_FileSystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode$
//-----------------------------------------------------------
class avmplus_RunModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MIXED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JITORDIE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_JIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INTERP;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_MIXED);
        gc->TraceLocation(&m_JITORDIE);
        gc->TraceLocation(&m_JIT);
        gc->TraceLocation(&m_INTERP);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::RunMode
//-----------------------------------------------------------
class avmplus_RunModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RunModeObject;
#define GC_TRIVIAL_TRACER_RunModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain$
//-----------------------------------------------------------
class avmplus_DomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainClass;
#define GC_TRIVIAL_TRACER_DomainClass
};
#define DECLARE_SLOTS_DomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::DomainObject> constructObject(GCRef<avmplus::DomainObject> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmplus::DomainObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::DomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::DomainObject>((avmplus::DomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Domain
//-----------------------------------------------------------
class avmplus_DomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DomainObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::DomainObject> m_private__parentDomain;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__parentDomain);
    }
};
#define DECLARE_SLOTS_DomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::DomainObject* get__parentDomain() const { return m_slots_DomainObject.m_private__parentDomain; } \
        REALLY_INLINE void set__parentDomain(avmplus::DomainObject* newVal) { m_slots_DomainObject.m_private__parentDomain = newVal; } \
    private: \
        avmplus::NativeID::avmplus_DomainObjectSlots m_slots_DomainObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment$
//-----------------------------------------------------------
class avmplus_EnvironmentClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentClass;
#define GC_TRIVIAL_TRACER_EnvironmentClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::Environment
//-----------------------------------------------------------
class avmplus_EnvironmentObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EnvironmentObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__vars;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__idx;
    avmplus::AtomWB m_private__env;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__vars);
        gc->TraceLocation(&m_private__idx);
        gc->TraceAtom(&m_private__env);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData$
//-----------------------------------------------------------
class avmplus_BinaryDataClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataClass;
#define GC_TRIVIAL_TRACER_BinaryDataClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell::BinaryData
//-----------------------------------------------------------
class avmplus_BinaryDataObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::BinaryDataObject;
#define GC_TRIVIAL_TRACER_BinaryDataObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility$
//-----------------------------------------------------------
class avmplus_AccessibilityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityClass;
#define GC_TRIVIAL_TRACER_AccessibilityClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::Accessibility
//-----------------------------------------------------------
class avmplus_AccessibilityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityObject;
#define GC_TRIVIAL_TRACER_AccessibilityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation$
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationClass;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityImplementation
//-----------------------------------------------------------
class avmplus_AccessibilityImplementationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityImplementationObject;
private:
    uint32_t m_errno;
    avmplus::bool32 m_stub;
#define GC_TRIVIAL_TRACER_AccessibilityImplementationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties$
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesClass;
#define GC_TRIVIAL_TRACER_AccessibilityPropertiesClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.accessibility::AccessibilityProperties
//-----------------------------------------------------------
class avmplus_AccessibilityPropertiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::AccessibilityPropertiesObject;
private:
    avmplus::bool32 m_silent;
    avmplus::bool32 m_forceSimple;
    avmplus::bool32 m_noAutoLabeling;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_description;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_shortcut;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_description);
        gc->TraceLocation(&m_shortcut);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore$
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreClass;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::EncryptedLocalStore
//-----------------------------------------------------------
class avmplus_EncryptedLocalStoreObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EncryptedLocalStoreObject;
#define GC_TRIVIAL_TRACER_EncryptedLocalStoreObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType$
//-----------------------------------------------------------
class avmplus_SQLCollationTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeClass;
#define GC_TRIVIAL_TRACER_SQLCollationTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLCollationType
//-----------------------------------------------------------
class avmplus_SQLCollationTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLCollationTypeObject;
#define GC_TRIVIAL_TRACER_SQLCollationTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle$
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleClass;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnNameStyle
//-----------------------------------------------------------
class avmplus_SQLColumnNameStyleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnNameStyleObject;
#define GC_TRIVIAL_TRACER_SQLColumnNameStyleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema$
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaClass;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLColumnSchema
//-----------------------------------------------------------
class avmplus_SQLColumnSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLColumnSchemaObject;
#define GC_TRIVIAL_TRACER_SQLColumnSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection$
//-----------------------------------------------------------
class avmplus_SQLConnectionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionClass;
#define GC_TRIVIAL_TRACER_SQLConnectionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLConnection
//-----------------------------------------------------------
class avmplus_SQLConnectionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLConnectionObject;
#define GC_TRIVIAL_TRACER_SQLConnectionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema$
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaClass;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLIndexSchema
//-----------------------------------------------------------
class avmplus_SQLIndexSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLIndexSchemaObject;
#define GC_TRIVIAL_TRACER_SQLIndexSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode$
//-----------------------------------------------------------
class avmplus_SQLModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeClass;
#define GC_TRIVIAL_TRACER_SQLModeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLMode
//-----------------------------------------------------------
class avmplus_SQLModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLModeObject;
#define GC_TRIVIAL_TRACER_SQLModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult$
//-----------------------------------------------------------
class avmplus_SQLResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultClass;
#define GC_TRIVIAL_TRACER_SQLResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLResult
//-----------------------------------------------------------
class avmplus_SQLResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLResultObject;
#define GC_TRIVIAL_TRACER_SQLResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema$
//-----------------------------------------------------------
class avmplus_SQLSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaClass;
#define GC_TRIVIAL_TRACER_SQLSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchema
//-----------------------------------------------------------
class avmplus_SQLSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaObject;
#define GC_TRIVIAL_TRACER_SQLSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult$
//-----------------------------------------------------------
class avmplus_SQLSchemaResultClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultClass;
#define GC_TRIVIAL_TRACER_SQLSchemaResultClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLSchemaResult
//-----------------------------------------------------------
class avmplus_SQLSchemaResultObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLSchemaResultObject;
#define GC_TRIVIAL_TRACER_SQLSchemaResultObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement$
//-----------------------------------------------------------
class avmplus_SQLStatementClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementClass;
#define GC_TRIVIAL_TRACER_SQLStatementClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLStatement
//-----------------------------------------------------------
class avmplus_SQLStatementObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLStatementObject;
#define GC_TRIVIAL_TRACER_SQLStatementObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema$
//-----------------------------------------------------------
class avmplus_SQLTableSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTableSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTableSchema
//-----------------------------------------------------------
class avmplus_SQLTableSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTableSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTableSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType$
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeClass;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTransactionLockType
//-----------------------------------------------------------
class avmplus_SQLTransactionLockTypeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTransactionLockTypeObject;
#define GC_TRIVIAL_TRACER_SQLTransactionLockTypeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema$
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaClass;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLTriggerSchema
//-----------------------------------------------------------
class avmplus_SQLTriggerSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLTriggerSchemaObject;
#define GC_TRIVIAL_TRACER_SQLTriggerSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema$
//-----------------------------------------------------------
class avmplus_SQLViewSchemaClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaClass;
#define GC_TRIVIAL_TRACER_SQLViewSchemaClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.data::SQLViewSchema
//-----------------------------------------------------------
class avmplus_SQLViewSchemaObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLViewSchemaObject;
#define GC_TRIVIAL_TRACER_SQLViewSchemaObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion$
//-----------------------------------------------------------
class avmplus_ActionScriptVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionClass;
private:
    uint32_t m_ACTIONSCRIPT2;
    uint32_t m_ACTIONSCRIPT3;
#define GC_TRIVIAL_TRACER_ActionScriptVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::ActionScriptVersion
//-----------------------------------------------------------
class avmplus_ActionScriptVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ActionScriptVersionObject;
#define GC_TRIVIAL_TRACER_ActionScriptVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping$
//-----------------------------------------------------------
class avmplus_PixelSnappingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEVER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ALWAYS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AUTO;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEVER);
        gc->TraceLocation(&m_ALWAYS);
        gc->TraceLocation(&m_AUTO);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PixelSnapping
//-----------------------------------------------------------
class avmplus_PixelSnappingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PixelSnappingObject;
#define GC_TRIVIAL_TRACER_PixelSnappingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions$
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsClass;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::PNGEncoderOptions
//-----------------------------------------------------------
class avmplus_PNGEncoderOptionsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PNGEncoderOptionsObject;
private:
    avmplus::bool32 m_fastCompression;
#define GC_TRIVIAL_TRACER_PNGEncoderOptionsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene$
//-----------------------------------------------------------
class avmplus_SceneClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneClass;
#define GC_TRIVIAL_TRACER_SceneClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::Scene
//-----------------------------------------------------------
class avmplus_SceneObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SceneObject;
private:
    int32_t m_private__numFrames;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__name;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__labels;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__name);
        gc->TraceLocation(&m_private__labels);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign$
//-----------------------------------------------------------
class avmplus_StageAlignClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TOP_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BOTTOM_RIGHT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TOP);
        gc->TraceLocation(&m_LEFT);
        gc->TraceLocation(&m_BOTTOM);
        gc->TraceLocation(&m_RIGHT);
        gc->TraceLocation(&m_TOP_LEFT);
        gc->TraceLocation(&m_TOP_RIGHT);
        gc->TraceLocation(&m_BOTTOM_LEFT);
        gc->TraceLocation(&m_BOTTOM_RIGHT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAlign
//-----------------------------------------------------------
class avmplus_StageAlignObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAlignObject;
#define GC_TRIVIAL_TRACER_StageAlignObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio$
//-----------------------------------------------------------
class avmplus_StageAspectRatioClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LANDSCAPE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PORTRAIT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANY);
        gc->TraceLocation(&m_LANDSCAPE);
        gc->TraceLocation(&m_PORTRAIT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageAspectRatio
//-----------------------------------------------------------
class avmplus_StageAspectRatioObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageAspectRatioObject;
#define GC_TRIVIAL_TRACER_StageAspectRatioObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState$
//-----------------------------------------------------------
class avmplus_StageDisplayStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULL_SCREEN_INTERACTIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NORMAL;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_FULL_SCREEN);
        gc->TraceLocation(&m_FULL_SCREEN_INTERACTIVE);
        gc->TraceLocation(&m_NORMAL);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageDisplayState
//-----------------------------------------------------------
class avmplus_StageDisplayStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageDisplayStateObject;
#define GC_TRIVIAL_TRACER_StageDisplayStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation$
//-----------------------------------------------------------
class avmplus_StageOrientationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEFAULT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_LEFT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROTATED_RIGHT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNKNOWN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UPSIDE_DOWN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_DEFAULT);
        gc->TraceLocation(&m_ROTATED_LEFT);
        gc->TraceLocation(&m_ROTATED_RIGHT);
        gc->TraceLocation(&m_UNKNOWN);
        gc->TraceLocation(&m_UPSIDE_DOWN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageOrientation
//-----------------------------------------------------------
class avmplus_StageOrientationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageOrientationObject;
#define GC_TRIVIAL_TRACER_StageOrientationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality$
//-----------------------------------------------------------
class avmplus_StageQualityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MEDIUM;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEST;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_8X8_LINEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HIGH_16X16_LINEAR;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_LOW);
        gc->TraceLocation(&m_MEDIUM);
        gc->TraceLocation(&m_HIGH);
        gc->TraceLocation(&m_BEST);
        gc->TraceLocation(&m_HIGH_8X8);
        gc->TraceLocation(&m_HIGH_8X8_LINEAR);
        gc->TraceLocation(&m_HIGH_16X16);
        gc->TraceLocation(&m_HIGH_16X16_LINEAR);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageQuality
//-----------------------------------------------------------
class avmplus_StageQualityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageQualityObject;
#define GC_TRIVIAL_TRACER_StageQualityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode$
//-----------------------------------------------------------
class avmplus_StageScaleModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SHOW_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXACT_FIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_BORDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NO_SCALE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_SHOW_ALL);
        gc->TraceLocation(&m_EXACT_FIT);
        gc->TraceLocation(&m_NO_BORDER);
        gc->TraceLocation(&m_NO_SCALE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::StageScaleMode
//-----------------------------------------------------------
class avmplus_StageScaleModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StageScaleModeObject;
#define GC_TRIVIAL_TRACER_StageScaleModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion$
//-----------------------------------------------------------
class avmplus_SWFVersionClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionClass;
private:
    uint32_t m_FLASH1;
    uint32_t m_FLASH2;
    uint32_t m_FLASH3;
    uint32_t m_FLASH4;
    uint32_t m_FLASH5;
    uint32_t m_FLASH6;
    uint32_t m_FLASH7;
    uint32_t m_FLASH8;
    uint32_t m_FLASH9;
    uint32_t m_FLASH10;
    uint32_t m_FLASH11;
    uint32_t m_FLASH12;
    uint32_t m_FLASH13;
    uint32_t m_FLASH14;
    uint32_t m_FLASH15;
    uint32_t m_FLASH16;
    uint32_t m_FLASH17;
    uint32_t m_FLASH18;
    uint32_t m_FLASH19;
#define GC_TRIVIAL_TRACER_SWFVersionClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::SWFVersion
//-----------------------------------------------------------
class avmplus_SWFVersionObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SWFVersionObject;
#define GC_TRIVIAL_TRACER_SWFVersionObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling$
//-----------------------------------------------------------
class avmplus_TriangleCullingClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NONE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_POSITIVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEGATIVE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NONE);
        gc->TraceLocation(&m_POSITIVE);
        gc->TraceLocation(&m_NEGATIVE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.display::TriangleCulling
//-----------------------------------------------------------
class avmplus_TriangleCullingObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TriangleCullingObject;
#define GC_TRIVIAL_TRACER_TriangleCullingObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError$
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorClass;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::ScriptTimeoutError
//-----------------------------------------------------------
class avmplus_ScriptTimeoutErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ScriptTimeoutErrorObject;
#define GC_TRIVIAL_TRACER_ScriptTimeoutErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError$
//-----------------------------------------------------------
class avmplus_StackOverflowErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorClass;
#define GC_TRIVIAL_TRACER_StackOverflowErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::StackOverflowError
//-----------------------------------------------------------
class avmplus_StackOverflowErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackOverflowErrorObject;
#define GC_TRIVIAL_TRACER_StackOverflowErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError$
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorClass;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::InvalidSWFError
//-----------------------------------------------------------
class avmplus_InvalidSWFErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::InvalidSWFErrorObject;
#define GC_TRIVIAL_TRACER_InvalidSWFErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation$
//-----------------------------------------------------------
class avmplus_SQLErrorOperationClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ATTACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BEGIN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMMIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPACT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEANALYZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DETACH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXECUTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REENCRYPT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RELEASE_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ROLLBACK_TO_SAVEPOINT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCHEMA;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SET_SAVEPOINT;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ANALYZE);
        gc->TraceLocation(&m_ATTACH);
        gc->TraceLocation(&m_BEGIN);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMMIT);
        gc->TraceLocation(&m_COMPACT);
        gc->TraceLocation(&m_DEANALYZE);
        gc->TraceLocation(&m_DETACH);
        gc->TraceLocation(&m_EXECUTE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_REENCRYPT);
        gc->TraceLocation(&m_RELEASE_SAVEPOINT);
        gc->TraceLocation(&m_ROLLBACK);
        gc->TraceLocation(&m_ROLLBACK_TO_SAVEPOINT);
        gc->TraceLocation(&m_SCHEMA);
        gc->TraceLocation(&m_SET_SAVEPOINT);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLErrorOperation
//-----------------------------------------------------------
class avmplus_SQLErrorOperationObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorOperationObject;
#define GC_TRIVIAL_TRACER_SQLErrorOperationObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError$
//-----------------------------------------------------------
class avmplus_SQLErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorClass;
#define GC_TRIVIAL_TRACER_SQLErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::SQLError
//-----------------------------------------------------------
class avmplus_SQLErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SQLErrorObject;
private:
    int32_t m_private__detailID;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__operation;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__details;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__detailArguments;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__operation);
        gc->TraceLocation(&m_private__details);
        gc->TraceLocation(&m_private__detailArguments);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError$
//-----------------------------------------------------------
class avmplus_DRMManagerErrorClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorClass;
#define GC_TRIVIAL_TRACER_DRMManagerErrorClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.errors::DRMManagerError
//-----------------------------------------------------------
class avmplus_DRMManagerErrorObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DRMManagerErrorObject;
private:
    int32_t m_private__subErrorID;
#define GC_TRIVIAL_TRACER_DRMManagerErrorObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event$
//-----------------------------------------------------------
class avmplus_EventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ADDED_TO_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CANCEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLEAR;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONNECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_COPY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CUT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DEACTIVATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ENTER_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_CONSTRUCTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXIT_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FRAME_LABEL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ID3;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_INIT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_MOUSE_LEAVE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_OPEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PASTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOVED_FROM_STAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RESIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SCROLL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXT_INTERACTION_MODE_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SELECT_ALL;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SOUND_COMPLETE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_CHILDREN_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_ENABLED_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TAB_INDEX_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UNLOAD;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FULLSCREEN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CONTEXT3D_CREATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TEXTURE_READY;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_VIDEO_FRAME;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_SUSPEND;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_MESSAGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CHANNEL_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_CLOSING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXITING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_DISPLAYING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_PREPARING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NETWORK_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_IDLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_USER_PRESENT;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_OUTPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_ERROR_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_STANDARD_INPUT_CLOSE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_BOUNDS_CHANGE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_RENDER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTML_DOM_INITIALIZE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCATION_CHANGE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_ACTIVATE);
        gc->TraceLocation(&m_ADDED);
        gc->TraceLocation(&m_ADDED_TO_STAGE);
        gc->TraceLocation(&m_CANCEL);
        gc->TraceLocation(&m_CHANGE);
        gc->TraceLocation(&m_CLEAR);
        gc->TraceLocation(&m_CLOSE);
        gc->TraceLocation(&m_COMPLETE);
        gc->TraceLocation(&m_CONNECT);
        gc->TraceLocation(&m_COPY);
        gc->TraceLocation(&m_CUT);
        gc->TraceLocation(&m_DEACTIVATE);
        gc->TraceLocation(&m_ENTER_FRAME);
        gc->TraceLocation(&m_FRAME_CONSTRUCTED);
        gc->TraceLocation(&m_EXIT_FRAME);
        gc->TraceLocation(&m_FRAME_LABEL);
        gc->TraceLocation(&m_ID3);
        gc->TraceLocation(&m_INIT);
        gc->TraceLocation(&m_MOUSE_LEAVE);
        gc->TraceLocation(&m_OPEN);
        gc->TraceLocation(&m_PASTE);
        gc->TraceLocation(&m_REMOVED);
        gc->TraceLocation(&m_REMOVED_FROM_STAGE);
        gc->TraceLocation(&m_RENDER);
        gc->TraceLocation(&m_RESIZE);
        gc->TraceLocation(&m_SCROLL);
        gc->TraceLocation(&m_TEXT_INTERACTION_MODE_CHANGE);
        gc->TraceLocation(&m_SELECT);
        gc->TraceLocation(&m_SELECT_ALL);
        gc->TraceLocation(&m_SOUND_COMPLETE);
        gc->TraceLocation(&m_TAB_CHILDREN_CHANGE);
        gc->TraceLocation(&m_TAB_ENABLED_CHANGE);
        gc->TraceLocation(&m_TAB_INDEX_CHANGE);
        gc->TraceLocation(&m_UNLOAD);
        gc->TraceLocation(&m_FULLSCREEN);
        gc->TraceLocation(&m_CONTEXT3D_CREATE);
        gc->TraceLocation(&m_TEXTURE_READY);
        gc->TraceLocation(&m_VIDEO_FRAME);
        gc->TraceLocation(&m_SUSPEND);
        gc->TraceLocation(&m_CHANNEL_MESSAGE);
        gc->TraceLocation(&m_CHANNEL_STATE);
        gc->TraceLocation(&m_WORKER_STATE);
        gc->TraceLocation(&m_CLOSING);
        gc->TraceLocation(&m_EXITING);
        gc->TraceLocation(&m_DISPLAYING);
        gc->TraceLocation(&m_PREPARING);
        gc->TraceLocation(&m_NETWORK_CHANGE);
        gc->TraceLocation(&m_USER_IDLE);
        gc->TraceLocation(&m_USER_PRESENT);
        gc->TraceLocation(&m_STANDARD_OUTPUT_CLOSE);
        gc->TraceLocation(&m_STANDARD_ERROR_CLOSE);
        gc->TraceLocation(&m_STANDARD_INPUT_CLOSE);
        gc->TraceLocation(&m_HTML_BOUNDS_CHANGE);
        gc->TraceLocation(&m_HTML_RENDER);
        gc->TraceLocation(&m_HTML_DOM_INITIALIZE);
        gc->TraceLocation(&m_LOCATION_CHANGE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::Event
//-----------------------------------------------------------
class avmplus_EventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventObject;
private:
    avmplus::bool32 m_private__bubbles;
    avmplus::bool32 m_private__cancelable;
    uint32_t m_private__currentphase;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__type;
    avmplus::AtomWB m_private__target;
    avmplus::AtomWB m_private__currenttarget;
    avmplus::AtomWB m_private__preventdefault;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__type);
        gc->TraceAtom(&m_private__target);
        gc->TraceAtom(&m_private__currenttarget);
        gc->TraceAtom(&m_private__preventdefault);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::File$
//-----------------------------------------------------------
class avmshell_FileGlueClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileGlueClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::RegExpObject> m_private_pathIsURL;
};
#define DECLARE_SLOTS_FileGlueClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::FileGlueObject> constructObject(GCRef<avmplus::String> arg1) \
        { \
            avmplus::Atom args[2] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom(), arg1->atom() }; \
            avmplus::Atom const result = this->construct(1, args); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        inline GCRef<avmshell::FileGlueObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::FileGlueObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileGlueObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileGlueObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileGlueObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::FileGlueObject>((avmshell::FileGlueObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::RegExpObject* get_pathIsURL() const { return m_slots_FileGlueClass.m_private_pathIsURL; } \
        REALLY_INLINE void setconst_pathIsURL(avmplus::RegExpObject* newVal) { m_slots_FileGlueClass.m_private_pathIsURL = newVal; } \
    private: \
        avmplus::NativeID::avmshell_FileGlueClassSlots m_slots_FileGlueClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::File
//-----------------------------------------------------------
class avmshell_FileGlueObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileGlueObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__url;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__nativePath;
};
#define DECLARE_SLOTS_FileGlueObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::String* get__url() const { return m_slots_FileGlueObject.m_private__url; } \
        REALLY_INLINE void set__url(avmplus::String* newVal) { m_slots_FileGlueObject.m_private__url = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__nativePath() const { return m_slots_FileGlueObject.m_private__nativePath; } \
        REALLY_INLINE void set__nativePath(avmplus::String* newVal) { m_slots_FileGlueObject.m_private__nativePath = newVal; } \
    private: \
        avmplus::NativeID::avmshell_FileGlueObjectSlots m_slots_FileGlueObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::FileMode$
//-----------------------------------------------------------
class avmplus_FileModeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileModeClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_READ;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WRITE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_UPDATE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_APPEND;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_READ);
        gc->TraceLocation(&m_WRITE);
        gc->TraceLocation(&m_UPDATE);
        gc->TraceLocation(&m_APPEND);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::FileMode
//-----------------------------------------------------------
class avmplus_FileModeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileModeObject;
#define GC_TRIVIAL_TRACER_FileModeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::FileStream$
//-----------------------------------------------------------
class avmplus_FileStreamClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileStreamClass;
#define GC_TRIVIAL_TRACER_FileStreamClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.filesystem::FileStream
//-----------------------------------------------------------
class avmplus_FileStreamObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::FileStreamObject;
#define GC_TRIVIAL_TRACER_FileStreamObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D$
//-----------------------------------------------------------
class avmplus_Orientation3DClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EULER_ANGLES;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_AXIS_ANGLE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_QUATERNION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_EULER_ANGLES);
        gc->TraceLocation(&m_AXIS_ANGLE);
        gc->TraceLocation(&m_QUATERNION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Orientation3D
//-----------------------------------------------------------
class avmplus_Orientation3DObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::Orientation3DObject;
#define GC_TRIVIAL_TRACER_Orientation3DObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point$
//-----------------------------------------------------------
class avmplus_PointClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointClass;
#define GC_TRIVIAL_TRACER_PointClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Point
//-----------------------------------------------------------
class avmplus_PointObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::PointObject;
private:
    double m_x;
    double m_y;
#define GC_TRIVIAL_TRACER_PointObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle$
//-----------------------------------------------------------
class avmplus_RectangleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleClass;
#define GC_TRIVIAL_TRACER_RectangleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.geom::Rectangle
//-----------------------------------------------------------
class avmplus_RectangleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::RectangleObject;
private:
    double m_x;
    double m_y;
    double m_width;
    double m_height;
#define GC_TRIVIAL_TRACER_RectangleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::FileReference$
//-----------------------------------------------------------
class avmshell_FileReferenceClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileReferenceClass;
private:
    uint32_t m_private_kInvalidParamError;
    uint32_t m_private_kNullPointerError;
    uint32_t m_private_kInvalidCallError;
    uint32_t m_private_kLocalSecurityError;
};
#define DECLARE_SLOTS_FileReferenceClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::FileReferenceObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::FileReferenceObject>((avmshell::FileReferenceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::FileReferenceObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::FileReferenceObject>((avmshell::FileReferenceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileReferenceObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::FileReferenceObject>((avmshell::FileReferenceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileReferenceObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::FileReferenceObject>((avmshell::FileReferenceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::FileReferenceObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::FileReferenceObject>((avmshell::FileReferenceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE uint32_t get_kInvalidParamError() const { return m_slots_FileReferenceClass.m_private_kInvalidParamError; } \
        REALLY_INLINE void setconst_kInvalidParamError(uint32_t newVal) { m_slots_FileReferenceClass.m_private_kInvalidParamError = newVal; } \
    protected: \
        REALLY_INLINE uint32_t get_kNullPointerError() const { return m_slots_FileReferenceClass.m_private_kNullPointerError; } \
        REALLY_INLINE void setconst_kNullPointerError(uint32_t newVal) { m_slots_FileReferenceClass.m_private_kNullPointerError = newVal; } \
    protected: \
        REALLY_INLINE uint32_t get_kInvalidCallError() const { return m_slots_FileReferenceClass.m_private_kInvalidCallError; } \
        REALLY_INLINE void setconst_kInvalidCallError(uint32_t newVal) { m_slots_FileReferenceClass.m_private_kInvalidCallError = newVal; } \
    protected: \
        REALLY_INLINE uint32_t get_kLocalSecurityError() const { return m_slots_FileReferenceClass.m_private_kLocalSecurityError; } \
        REALLY_INLINE void setconst_kLocalSecurityError(uint32_t newVal) { m_slots_FileReferenceClass.m_private_kLocalSecurityError = newVal; } \
    private: \
        avmplus::NativeID::avmshell_FileReferenceClassSlots m_slots_FileReferenceClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::FileReference
//-----------------------------------------------------------
class avmshell_FileReferenceObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::FileReferenceObject;
private:
    avmplus::bool32 m_private__populated;
    avmplus::bool32 m_private__opened;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__fileref;
    MMgc::GCTraceableObject::GCMember<avmplus::ByteArrayObject> m_private__data;
};
#define DECLARE_SLOTS_FileReferenceObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE bool get__populated() const { return m_slots_FileReferenceObject.m_private__populated != 0; } \
        REALLY_INLINE void set__populated(avmplus::bool32 newVal) { m_slots_FileReferenceObject.m_private__populated = newVal; } \
    protected: \
        REALLY_INLINE bool get__opened() const { return m_slots_FileReferenceObject.m_private__opened != 0; } \
        REALLY_INLINE void set__opened(avmplus::bool32 newVal) { m_slots_FileReferenceObject.m_private__opened = newVal; } \
    protected: \
        REALLY_INLINE avmplus::String* get__fileref() const { return m_slots_FileReferenceObject.m_private__fileref; } \
        REALLY_INLINE void set__fileref(avmplus::String* newVal) { m_slots_FileReferenceObject.m_private__fileref = newVal; } \
    protected: \
        REALLY_INLINE avmplus::ByteArrayObject* get__data() const { return m_slots_FileReferenceObject.m_private__data; } \
        REALLY_INLINE void set__data(avmplus::ByteArrayObject* newVal) { m_slots_FileReferenceObject.m_private__data = newVal; } \
    private: \
        avmplus::NativeID::avmshell_FileReferenceObjectSlots m_slots_FileReferenceObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequest$
//-----------------------------------------------------------
class avmplus_URLRequestClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestClass;
private:
    uint32_t m_private_kInvalidParamError;
#define GC_TRIVIAL_TRACER_URLRequestClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequest
//-----------------------------------------------------------
class avmplus_URLRequestObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__requestHeaders;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__userAgent;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__requestHeaders);
        gc->TraceLocation(&m_private__userAgent);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestDefaults$
//-----------------------------------------------------------
class avmplus_URLRequestDefaultsClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestDefaultsClass;
private:
    uint32_t m_private_kApplicationFeatureSecurityError;
    avmplus::bool32 m_private__followRedirects;
    avmplus::bool32 m_private__manageCookies;
    avmplus::bool32 m_private__authenticate;
    avmplus::bool32 m_private__useCache;
    avmplus::bool32 m_private__cacheResponse;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__userAgent;
    avmplus::AtomWB m_private__loginCredentials;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__defaultUserAgent;
    double m_private__idleTimeout;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__userAgent);
        gc->TraceAtom(&m_private__loginCredentials);
        gc->TraceLocation(&m_private__defaultUserAgent);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestDefaults
//-----------------------------------------------------------
class avmplus_URLRequestDefaultsObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestDefaultsObject;
#define GC_TRIVIAL_TRACER_URLRequestDefaultsObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader$
//-----------------------------------------------------------
class avmplus_URLRequestHeaderClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderClass;
#define GC_TRIVIAL_TRACER_URLRequestHeaderClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.net::URLRequestHeader
//-----------------------------------------------------------
class avmplus_URLRequestHeaderObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::URLRequestHeaderObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_value;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_value);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame$
//-----------------------------------------------------------
class avmplus_StackFrameClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameClass;
#define GC_TRIVIAL_TRACER_StackFrameClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::StackFrame
//-----------------------------------------------------------
class avmplus_StackFrameObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::StackFrameObject;
private:
    uint32_t m_line;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_name;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_file;
    double m_scriptID;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_name);
        gc->TraceLocation(&m_file);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample$
//-----------------------------------------------------------
class avmplus_SampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleClass;
#define GC_TRIVIAL_TRACER_SampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::Sample
//-----------------------------------------------------------
class avmplus_SampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_stack;
    double m_time;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_stack);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory$
//-----------------------------------------------------------
class avmplus_ClassFactoryClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_StackFrameClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_SampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_DeleteObjectSampleClass;
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_NewObjectSampleClass;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_StackFrameClass);
        gc->TraceLocation(&m_SampleClass);
        gc->TraceLocation(&m_DeleteObjectSampleClass);
        gc->TraceLocation(&m_NewObjectSampleClass);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::ClassFactory
//-----------------------------------------------------------
class avmplus_ClassFactoryObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::ClassFactoryObject;
#define GC_TRIVIAL_TRACER_ClassFactoryObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities$
//-----------------------------------------------------------
class avmplus_CapabilitiesClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__ARCH;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__M;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__PR32;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__PR64;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__ARCH);
        gc->TraceLocation(&m_private__M);
        gc->TraceLocation(&m_private__PR32);
        gc->TraceLocation(&m_private__PR64);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Capabilities
//-----------------------------------------------------------
class avmplus_CapabilitiesObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CapabilitiesObject;
#define GC_TRIVIAL_TRACER_CapabilitiesObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Security$
//-----------------------------------------------------------
class avmplus_SecurityClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SecurityClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__sandboxType;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_REMOTE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCAL_WITH_FILE;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCAL_WITH_NETWORK;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LOCAL_TRUSTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_APPLICATION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__sandboxType);
        gc->TraceLocation(&m_REMOTE);
        gc->TraceLocation(&m_LOCAL_WITH_FILE);
        gc->TraceLocation(&m_LOCAL_WITH_NETWORK);
        gc->TraceLocation(&m_LOCAL_TRUSTED);
        gc->TraceLocation(&m_APPLICATION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Security
//-----------------------------------------------------------
class avmplus_SecurityObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SecurityObject;
#define GC_TRIVIAL_TRACER_SecurityObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::SecurityPrivilege$
//-----------------------------------------------------------
class avmplus_SecurityPrivilegeClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SecurityPrivilegeClass;
private:
    avmplus::AtomWB m_FILE;
    avmplus::AtomWB m_FILE_READ;
    avmplus::AtomWB m_FILE_WRITE;
    avmplus::AtomWB m_FILE_APPSTORE;
    avmplus::AtomWB m_FILE_PATHACCESS;
    avmplus::AtomWB m_FILE_TEMP;
    avmplus::AtomWB m_FILE_WRITE_RESOURCE;
    avmplus::AtomWB m_HTTP_ALL;
    avmplus::AtomWB m_HTML;
    avmplus::AtomWB m_WINDOW;
    avmplus::AtomWB m_SCREEN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceAtom(&m_FILE);
        gc->TraceAtom(&m_FILE_READ);
        gc->TraceAtom(&m_FILE_WRITE);
        gc->TraceAtom(&m_FILE_APPSTORE);
        gc->TraceAtom(&m_FILE_PATHACCESS);
        gc->TraceAtom(&m_FILE_TEMP);
        gc->TraceAtom(&m_FILE_WRITE_RESOURCE);
        gc->TraceAtom(&m_HTTP_ALL);
        gc->TraceAtom(&m_HTML);
        gc->TraceAtom(&m_WINDOW);
        gc->TraceAtom(&m_SCREEN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::SecurityPrivilege
//-----------------------------------------------------------
class avmplus_SecurityPrivilegeObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SecurityPrivilegeObject;
#define GC_TRIVIAL_TRACER_SecurityPrivilegeObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System$
//-----------------------------------------------------------
class avmshell_SystemClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::SystemClass;
private:
    avmplus::bool32 m_private__useCodePage;
};
#define DECLARE_SLOTS_SystemClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::SystemObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::SystemObject>((avmplus::SystemObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE bool get__useCodePage() const { return m_slots_SystemClass.m_private__useCodePage != 0; } \
        REALLY_INLINE void set__useCodePage(avmplus::bool32 newVal) { m_slots_SystemClass.m_private__useCodePage = newVal; } \
    private: \
        avmplus::NativeID::avmshell_SystemClassSlots m_slots_SystemClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::System
//-----------------------------------------------------------
class avmplus_SystemObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::SystemObject;
#define GC_TRIVIAL_TRACER_SystemObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState$
//-----------------------------------------------------------
class avmplus_WorkerStateClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_NEW;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_RUNNING;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TERMINATED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_FAILED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_ABORTED;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_EXCEPTION;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_NEW);
        gc->TraceLocation(&m_RUNNING);
        gc->TraceLocation(&m_TERMINATED);
        gc->TraceLocation(&m_FAILED);
        gc->TraceLocation(&m_ABORTED);
        gc->TraceLocation(&m_EXCEPTION);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerState
//-----------------------------------------------------------
class avmplus_WorkerStateObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerStateObject;
#define GC_TRIVIAL_TRACER_WorkerStateObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker$
//-----------------------------------------------------------
class avmshell_ShellWorkerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct_native(avmshell::ShellWorkerClass::createInstanceProc, 0, args); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerObject>((avmshell::ShellWorkerObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerObject* get_m_current() const { return m_slots_ShellWorkerClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerObject* newVal) { m_slots_ShellWorkerClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerClassSlots m_slots_ShellWorkerClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::Worker
//-----------------------------------------------------------
class avmshell_ShellWorkerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ByteArrayObject> m_private_m_byteCode;
};
#define DECLARE_SLOTS_ShellWorkerObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmplus::ByteArrayObject* get_m_byteCode() const { return m_slots_ShellWorkerObject.m_private_m_byteCode; } \
        REALLY_INLINE void set_m_byteCode(avmplus::ByteArrayObject* newVal) { m_slots_ShellWorkerObject.m_private_m_byteCode = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerObjectSlots m_slots_ShellWorkerObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent$
//-----------------------------------------------------------
class avmplus_WorkerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_WORKER_STATE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_WORKER_STATE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerEvent
//-----------------------------------------------------------
class avmplus_WorkerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::WorkerEventObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_previousState;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private_m_currentState;
    avmplus::AtomWB m_flash_system_m_target;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private_m_previousState);
        gc->TraceLocation(&m_private_m_currentState);
        gc->TraceAtom(&m_flash_system_m_target);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain$
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainClass;
private:
    MMgc::GCTraceableObject::GCMember<avmshell::ShellWorkerDomainObject> m_private_m_current;
};
#define DECLARE_SLOTS_ShellWorkerDomainClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmshell::ShellWorkerDomainObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmshell::ShellWorkerDomainObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmshell::ShellWorkerDomainObject>((avmshell::ShellWorkerDomainObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    protected: \
        REALLY_INLINE avmshell::ShellWorkerDomainObject* get_m_current() const { return m_slots_ShellWorkerDomainClass.m_private_m_current; } \
        REALLY_INLINE void set_m_current(avmshell::ShellWorkerDomainObject* newVal) { m_slots_ShellWorkerDomainClass.m_private_m_current = newVal; } \
    private: \
        avmplus::NativeID::avmshell_ShellWorkerDomainClassSlots m_slots_ShellWorkerDomainClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.system::WorkerDomain
//-----------------------------------------------------------
class avmshell_ShellWorkerDomainObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmshell::ShellWorkerDomainObject;
};
#define DECLARE_SLOTS_ShellWorkerDomainObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace$
//-----------------------------------------------------------
class avmplus_TraceClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceClass;
private:
    int32_t m_OFF;
    int32_t m_METHODS;
    int32_t m_METHODS_WITH_ARGS;
    int32_t m_METHODS_AND_LINES;
    int32_t m_METHODS_AND_LINES_WITH_ARGS;
    avmplus::AtomWB m_FILE;
    avmplus::AtomWB m_LISTENER;
};
#define DECLARE_SLOTS_TraceClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::TraceObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::TraceObject>((avmplus::TraceObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE int32_t get_OFF() const { return m_slots_TraceClass.m_OFF; } \
        REALLY_INLINE void setconst_OFF(int32_t newVal) { m_slots_TraceClass.m_OFF = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS() const { return m_slots_TraceClass.m_METHODS; } \
        REALLY_INLINE void setconst_METHODS(int32_t newVal) { m_slots_TraceClass.m_METHODS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES() const { return m_slots_TraceClass.m_METHODS_AND_LINES; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES = newVal; } \
    public: \
        REALLY_INLINE int32_t get_METHODS_AND_LINES_WITH_ARGS() const { return m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS; } \
        REALLY_INLINE void setconst_METHODS_AND_LINES_WITH_ARGS(int32_t newVal) { m_slots_TraceClass.m_METHODS_AND_LINES_WITH_ARGS = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_FILE() const { return m_slots_TraceClass.m_FILE; } \
        REALLY_INLINE void setconst_FILE(avmplus::Atom newVal) { m_slots_TraceClass.m_FILE = newVal; } \
    public: \
        REALLY_INLINE avmplus::Atom get_LISTENER() const { return m_slots_TraceClass.m_LISTENER; } \
        REALLY_INLINE void setconst_LISTENER(avmplus::Atom newVal) { m_slots_TraceClass.m_LISTENER = newVal; } \
    private: \
        avmplus::NativeID::avmplus_TraceClassSlots m_slots_TraceClass \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.trace::Trace
//-----------------------------------------------------------
class avmplus_TraceObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TraceObject;
#define GC_TRIVIAL_TRACER_TraceObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian$
//-----------------------------------------------------------
class avmplus_EndianClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_BIG_ENDIAN;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_LITTLE_ENDIAN;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_BIG_ENDIAN);
        gc->TraceLocation(&m_LITTLE_ENDIAN);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Endian
//-----------------------------------------------------------
class avmplus_EndianObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EndianObject;
#define GC_TRIVIAL_TRACER_EndianObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop$
//-----------------------------------------------------------
class avmplus_CoreEventLoopClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopClass;
#define GC_TRIVIAL_TRACER_CoreEventLoopClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// shell.async::CoreEventLoop
//-----------------------------------------------------------
class avmplus_CoreEventLoopObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::CoreEventLoopObject;
private:
    avmplus::bool32 m_private__running;
    uint32_t m_private__frequency;
    uint32_t m_private__started;
    uint32_t m_private__elapsed;
    uint32_t m_private__frame;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__timers;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__callback;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__timers);
        gc->TraceLocation(&m_private__callback);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher$
//-----------------------------------------------------------
class avmplus_EventDispatcherClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectlist;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__objectmap;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m__objectlist);
        gc->TraceLocation(&m__objectmap);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::EventDispatcher
//-----------------------------------------------------------
class avmplus_EventDispatcherObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::EventDispatcherObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::IEventDispatcherInterface> m_private__target;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listeners;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersNames;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m__listenersCalls;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__target);
        gc->TraceLocation(&m__listeners);
        gc->TraceLocation(&m__listenersNames);
        gc->TraceLocation(&m__listenersCalls);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent$
//-----------------------------------------------------------
class avmplus_HTTPStatusEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_STATUS;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_HTTP_RESPONSE_STATUS;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_HTTP_STATUS);
        gc->TraceLocation(&m_HTTP_RESPONSE_STATUS);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::HTTPStatusEvent
//-----------------------------------------------------------
class avmplus_HTTPStatusEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::HTTPStatusEventObject;
private:
    int32_t m_private__status;
    avmplus::bool32 m_private__redirected;
    MMgc::GCTraceableObject::GCMember<avmplus::ArrayObject> m_private__responseHeaders;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_private__responseUrl;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__responseHeaders);
        gc->TraceLocation(&m_private__responseUrl);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent$
//-----------------------------------------------------------
class avmplus_TimerEventClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventClass;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER;
    MMgc::GCTraceableObject::GCMember<avmplus::String> m_TIMER_COMPLETE;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_TIMER);
        gc->TraceLocation(&m_TIMER_COMPLETE);
    }
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.events::TimerEvent
//-----------------------------------------------------------
class avmplus_TimerEventObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerEventObject;
#define GC_TRIVIAL_TRACER_TimerEventObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample$
//-----------------------------------------------------------
class avmplus_NewObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleClass;
};
#define DECLARE_SLOTS_NewObjectSampleClass \
    public: \
        static avmplus::ClassClosure* FASTCALL createClassClosure(avmplus::VTable* cvtable); \
    public: \
        static avmplus::ScriptObject* FASTCALL createInstanceProc(avmplus::ClassClosure*); \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    public: \
        inline GCRef<avmplus::NewObjectSampleObject> constructObject() \
        { \
            avmplus::Atom args[1] = { thisRef.reinterpretCast<avmplus::ScriptObject>()->atom() }; \
            avmplus::Atom const result = this->construct(0, args); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    public: \
        REALLY_INLINE bool isType(avmplus::Atom value) \
        { \
            return isTypeImpl(value); \
        } \
        REALLY_INLINE bool isType(GCRef<avmplus::ScriptObject> value) \
        { \
            return isTypeImpl(value->atom()); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = asTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> asType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = asTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(avmplus::Atom value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
        REALLY_INLINE GCRef<avmplus::NewObjectSampleObject> coerceToType(GCRef<avmplus::ScriptObject> value) \
        { \
            avmplus::Atom const result = coerceToTypeImpl(value->atom()); \
            return GCRef<avmplus::NewObjectSampleObject>((avmplus::NewObjectSampleObject*)(avmplus::AvmCore::atomToScriptObject(result))); \
        } \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::NewObjectSample
//-----------------------------------------------------------
class avmplus_NewObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::NewObjectSampleObject;
private:
    MMgc::GCTraceableObject::GCMember<avmplus::ClassClosure> m_type;
    double m_id;
};
#define DECLARE_SLOTS_NewObjectSampleObject \
    public: \
        AvmThunk_DEBUG_ONLY( virtual avmplus::Atom construct(int argc, avmplus::Atom* argv); ) \
    private: \
        AvmThunk_DEBUG_ONLY( virtual void createInstance() { AvmAssert(0); } ) \
    private: \
        friend class avmplus::NativeID::SlotOffsetsAndAsserts; \
    public: \
        REALLY_INLINE avmplus::ClassClosure* get_type() const { return m_slots_NewObjectSampleObject.m_type; } \
        REALLY_INLINE void setconst_type(avmplus::ClassClosure* newVal) { m_slots_NewObjectSampleObject.m_type = newVal; } \
    public: \
        REALLY_INLINE double get_id() const { return m_slots_NewObjectSampleObject.m_id; } \
        REALLY_INLINE void setconst_id(double newVal) { m_slots_NewObjectSampleObject.m_id = newVal; } \
    private: \
        avmplus::NativeID::avmplus_NewObjectSampleObjectSlots m_slots_NewObjectSampleObject \

//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample$
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleClass;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.sampler::DeleteObjectSample
//-----------------------------------------------------------
class avmplus_DeleteObjectSampleObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::DeleteObjectSampleObject;
private:
    double m_id;
    double m_size;
#define GC_TRIVIAL_TRACER_DeleteObjectSampleObject
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer$
//-----------------------------------------------------------
class avmplus_TimerClassSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerClass;
#define GC_TRIVIAL_TRACER_TimerClass
};
//-----------------------------------------------------------

//-----------------------------------------------------------
// flash.utils::Timer
//-----------------------------------------------------------
class avmplus_TimerObjectSlots
{
    friend class SlotOffsetsAndAsserts;
    friend class avmplus::TimerObject;
private:
    int32_t m_private__repeatCount;
    int32_t m_private__iteration;
    avmplus::bool32 m_private__running;
    uint32_t m__started;
    uint32_t m__elapsed;
    MMgc::GCTraceableObject::GCMember<avmplus::FunctionObject> m_private__closure;
    double m_private__delay;
public:
    REALLY_INLINE void gcTracePrivateProperties(MMgc::GC* gc)
    {
        gc->TraceLocation(&m_private__closure);
    }
};
//-----------------------------------------------------------

} }
namespace avmplus {

class shell_toplevelClassManifest : public avmplus::ClassManifestBase
{
    friend class avmplus::AvmCore;
    friend class avmplus::IntVectorClass;
    friend class avmplus::UIntVectorClass;
    FLOAT_ONLY(friend class avmplus::FloatVectorClass;)
    FLOAT_ONLY(friend class avmplus::Float4VectorClass;)
    friend class avmplus::DoubleVectorClass;
    friend class avmplus::ObjectVectorClass;
private:
    REALLY_INLINE shell_toplevelClassManifest(avmplus::ScriptEnv* e) : ClassManifestBase(138, e) { }
    REALLY_INLINE static shell_toplevelClassManifest* create(avmplus::ScriptEnv* e) { return new (MMgc::GC::GetGC(e), MMgc::kExact, sizeof(ClassClosure*)*137) shell_toplevelClassManifest(e); }
public:
    REALLY_INLINE GCRef<avmplus::AccessibilityClass> get_AccessibilityClass() { return (avmplus::AccessibilityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_Accessibility)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityImplementationClass> get_AccessibilityImplementationClass() { return (avmplus::AccessibilityImplementationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityImplementation)); }
    REALLY_INLINE GCRef<avmplus::AccessibilityPropertiesClass> get_AccessibilityPropertiesClass() { return (avmplus::AccessibilityPropertiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_AccessibilityProperties)); }
    REALLY_INLINE GCRef<avmplus::ActionScriptVersionClass> get_ActionScriptVersionClass() { return (avmplus::ActionScriptVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_ActionScriptVersion)); }
    REALLY_INLINE GCRef<avmplus::BinaryDataClass> get_BinaryDataClass() { return (avmplus::BinaryDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_BinaryData)); }
    REALLY_INLINE GCRef<avmshell::CEAIrrorClass> get_CEAIrrorClass() { return (avmshell::CEAIrrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_CEAIrror)); }
    REALLY_INLINE GCRef<avmshell::CErrorClass> get_CErrorClass() { return (avmshell::CErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_CError)); }
    REALLY_INLINE GCRef<avmplus::CapabilitiesClass> get_CapabilitiesClass() { return (avmplus::CapabilitiesClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Capabilities)); }
    REALLY_INLINE GCRef<avmplus::ClassFactoryClass> get_ClassFactoryClass() { return (avmplus::ClassFactoryClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_ClassFactory)); }
    REALLY_INLINE GCRef<avmplus::CoreEventLoopClass> get_CoreEventLoopClass() { return (avmplus::CoreEventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_CoreEventLoop)); }
    REALLY_INLINE GCRef<avmshell::CDIRClass> get_DIRClass() { return (avmshell::CDIRClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_dirent_DIR)); }
    REALLY_INLINE GCRef<avmplus::DRMManagerErrorClass> get_DRMManagerErrorClass() { return (avmplus::DRMManagerErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_DRMManagerError)); }
    REALLY_INLINE GCRef<avmplus::DeleteObjectSampleClass> get_DeleteObjectSampleClass() { return (avmplus::DeleteObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_DeleteObjectSample)); }
    REALLY_INLINE GCRef<avmshell::DiagnosticsClass> get_DiagnosticsClass() { return (avmshell::DiagnosticsClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Diagnostics)); }
    REALLY_INLINE GCRef<avmplus::DomainClass> get_DomainClass() { return (avmplus::DomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Domain)); }
    REALLY_INLINE GCRef<avmplus::EncryptedLocalStoreClass> get_EncryptedLocalStoreClass() { return (avmplus::EncryptedLocalStoreClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_EncryptedLocalStore)); }
    REALLY_INLINE GCRef<avmplus::EndianClass> get_EndianClass() { return (avmplus::EndianClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Endian)); }
    REALLY_INLINE GCRef<avmplus::EnvironmentClass> get_EnvironmentClass() { return (avmplus::EnvironmentClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Environment)); }
    REALLY_INLINE GCRef<avmplus::ErrorNumberClass> get_ErrorNumberClass() { return (avmplus::ErrorNumberClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno_ErrorNumber)); }
    REALLY_INLINE GCRef<avmplus::EventClass> get_EventClass() { return (avmplus::EventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_Event)); }
    REALLY_INLINE GCRef<avmplus::EventDispatcherClass> get_EventDispatcherClass() { return (avmplus::EventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_EventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::EventLoopClass> get_EventLoopClass() { return (avmplus::EventLoopClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_async_EventLoop)); }
    REALLY_INLINE GCRef<avmshell::CFILEClass> get_FILEClass() { return (avmshell::CFILEClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_FILE)); }
    REALLY_INLINE GCRef<avmshell::FileGlueClass> get_FileClass() { return (avmshell::FileGlueClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_filesystem_File)); }
    REALLY_INLINE GCRef<avmplus::FileModeClass> get_FileModeClass() { return (avmplus::FileModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_filesystem_FileMode)); }
    REALLY_INLINE GCRef<avmshell::FileReferenceClass> get_FileReferenceClass() { return (avmshell::FileReferenceClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_FileReference)); }
    REALLY_INLINE GCRef<avmplus::FileStreamClass> get_FileStreamClass() { return (avmplus::FileStreamClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_filesystem_FileStream)); }
    REALLY_INLINE GCRef<avmshell::FileSystemClass> get_FileSystemClass() { return (avmshell::FileSystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_FileSystem)); }
    REALLY_INLINE GCRef<avmplus::HTTPStatusEventClass> get_HTTPStatusEventClass() { return (avmplus::HTTPStatusEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_HTTPStatusEvent)); }
    REALLY_INLINE GCRef<avmshell::HardwareInformationClass> get_HardwareInformationClass() { return (avmshell::HardwareInformationClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_HardwareInformation)); }
    REALLY_INLINE GCRef<avmplus::IBitmapDrawableClass> get_IBitmapDrawableClass() { return (avmplus::IBitmapDrawableClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IBitmapDrawable)); }
    REALLY_INLINE GCRef<avmplus::IDrawCommandClass> get_IDrawCommandClass() { return (avmplus::IDrawCommandClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IDrawCommand)); }
    REALLY_INLINE GCRef<avmplus::IEventDispatcherClass> get_IEventDispatcherClass() { return (avmplus::IEventDispatcherClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_IEventDispatcher)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsDataClass> get_IGraphicsDataClass() { return (avmplus::IGraphicsDataClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsData)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsFillClass> get_IGraphicsFillClass() { return (avmplus::IGraphicsFillClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsFill)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsPathClass> get_IGraphicsPathClass() { return (avmplus::IGraphicsPathClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsPath)); }
    REALLY_INLINE GCRef<avmplus::IGraphicsStrokeClass> get_IGraphicsStrokeClass() { return (avmplus::IGraphicsStrokeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_IGraphicsStroke)); }
    REALLY_INLINE GCRef<avmplus::ISearchableTextClass> get_ISearchableTextClass() { return (avmplus::ISearchableTextClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISearchableText)); }
    REALLY_INLINE GCRef<avmplus::ISimpleTextSelectionClass> get_ISimpleTextSelectionClass() { return (avmplus::ISimpleTextSelectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_accessibility_ISimpleTextSelection)); }
    REALLY_INLINE GCRef<avmplus::InvalidSWFErrorClass> get_InvalidSWFErrorClass() { return (avmplus::InvalidSWFErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_InvalidSWFError)); }
    REALLY_INLINE GCRef<avmplus::NewObjectSampleClass> get_NewObjectSampleClass() { return (avmplus::NewObjectSampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_NewObjectSample)); }
    REALLY_INLINE GCRef<avmshell::OperatingSystemClass> get_OperatingSystemClass() { return (avmshell::OperatingSystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_OperatingSystem)); }
    REALLY_INLINE GCRef<avmplus::Orientation3DClass> get_Orientation3DClass() { return (avmplus::Orientation3DClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Orientation3D)); }
    REALLY_INLINE GCRef<avmplus::PNGEncoderOptionsClass> get_PNGEncoderOptionsClass() { return (avmplus::PNGEncoderOptionsClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PNGEncoderOptions)); }
    REALLY_INLINE GCRef<avmplus::PixelSnappingClass> get_PixelSnappingClass() { return (avmplus::PixelSnappingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_PixelSnapping)); }
    REALLY_INLINE GCRef<avmplus::PointClass> get_PointClass() { return (avmplus::PointClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Point)); }
    REALLY_INLINE GCRef<avmshell::ProgramClass> get_ProgramClass() { return (avmshell::ProgramClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Program)); }
    REALLY_INLINE GCRef<avmplus::RectangleClass> get_RectangleClass() { return (avmplus::RectangleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_geom_Rectangle)); }
    REALLY_INLINE GCRef<avmplus::RunModeClass> get_RunModeClass() { return (avmplus::RunModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_RunMode)); }
    REALLY_INLINE GCRef<avmshell::RuntimeClass> get_RuntimeClass() { return (avmshell::RuntimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_shell_Runtime)); }
    REALLY_INLINE GCRef<avmplus::SQLCollationTypeClass> get_SQLCollationTypeClass() { return (avmplus::SQLCollationTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLCollationType)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnNameStyleClass> get_SQLColumnNameStyleClass() { return (avmplus::SQLColumnNameStyleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnNameStyle)); }
    REALLY_INLINE GCRef<avmplus::SQLColumnSchemaClass> get_SQLColumnSchemaClass() { return (avmplus::SQLColumnSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLColumnSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLConnectionClass> get_SQLConnectionClass() { return (avmplus::SQLConnectionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLConnection)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorClass> get_SQLErrorClass() { return (avmplus::SQLErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLError)); }
    REALLY_INLINE GCRef<avmplus::SQLErrorOperationClass> get_SQLErrorOperationClass() { return (avmplus::SQLErrorOperationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_SQLErrorOperation)); }
    REALLY_INLINE GCRef<avmplus::SQLIndexSchemaClass> get_SQLIndexSchemaClass() { return (avmplus::SQLIndexSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLIndexSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLModeClass> get_SQLModeClass() { return (avmplus::SQLModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLMode)); }
    REALLY_INLINE GCRef<avmplus::SQLResultClass> get_SQLResultClass() { return (avmplus::SQLResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLResult)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaClass> get_SQLSchemaClass() { return (avmplus::SQLSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLSchemaResultClass> get_SQLSchemaResultClass() { return (avmplus::SQLSchemaResultClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLSchemaResult)); }
    REALLY_INLINE GCRef<avmplus::SQLStatementClass> get_SQLStatementClass() { return (avmplus::SQLStatementClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLStatement)); }
    REALLY_INLINE GCRef<avmplus::SQLTableSchemaClass> get_SQLTableSchemaClass() { return (avmplus::SQLTableSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTableSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLTransactionLockTypeClass> get_SQLTransactionLockTypeClass() { return (avmplus::SQLTransactionLockTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTransactionLockType)); }
    REALLY_INLINE GCRef<avmplus::SQLTriggerSchemaClass> get_SQLTriggerSchemaClass() { return (avmplus::SQLTriggerSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLTriggerSchema)); }
    REALLY_INLINE GCRef<avmplus::SQLViewSchemaClass> get_SQLViewSchemaClass() { return (avmplus::SQLViewSchemaClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_data_SQLViewSchema)); }
    REALLY_INLINE GCRef<avmplus::SWFVersionClass> get_SWFVersionClass() { return (avmplus::SWFVersionClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_SWFVersion)); }
    REALLY_INLINE GCRef<avmplus::SampleClass> get_SampleClass() { return (avmplus::SampleClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_Sample)); }
    REALLY_INLINE GCRef<avmplus::SceneClass> get_SceneClass() { return (avmplus::SceneClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_Scene)); }
    REALLY_INLINE GCRef<avmplus::ScriptTimeoutErrorClass> get_ScriptTimeoutErrorClass() { return (avmplus::ScriptTimeoutErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_ScriptTimeoutError)); }
    REALLY_INLINE GCRef<avmplus::SecurityClass> get_SecurityClass() { return (avmplus::SecurityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Security)); }
    REALLY_INLINE GCRef<avmplus::SecurityPrivilegeClass> get_SecurityPrivilegeClass() { return (avmplus::SecurityPrivilegeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_SecurityPrivilege)); }
    REALLY_INLINE GCRef<avmplus::StackFrameClass> get_StackFrameClass() { return (avmplus::StackFrameClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_sampler_StackFrame)); }
    REALLY_INLINE GCRef<avmplus::StackOverflowErrorClass> get_StackOverflowErrorClass() { return (avmplus::StackOverflowErrorClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_errors_StackOverflowError)); }
    REALLY_INLINE GCRef<avmplus::StageAlignClass> get_StageAlignClass() { return (avmplus::StageAlignClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAlign)); }
    REALLY_INLINE GCRef<avmplus::StageAspectRatioClass> get_StageAspectRatioClass() { return (avmplus::StageAspectRatioClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageAspectRatio)); }
    REALLY_INLINE GCRef<avmplus::StageDisplayStateClass> get_StageDisplayStateClass() { return (avmplus::StageDisplayStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageDisplayState)); }
    REALLY_INLINE GCRef<avmplus::StageOrientationClass> get_StageOrientationClass() { return (avmplus::StageOrientationClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageOrientation)); }
    REALLY_INLINE GCRef<avmplus::StageQualityClass> get_StageQualityClass() { return (avmplus::StageQualityClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageQuality)); }
    REALLY_INLINE GCRef<avmplus::StageScaleModeClass> get_StageScaleModeClass() { return (avmplus::StageScaleModeClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_StageScaleMode)); }
    REALLY_INLINE GCRef<avmshell::SystemClass> get_SystemClass() { return (avmshell::SystemClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_System)); }
    REALLY_INLINE GCRef<avmplus::TimerClass> get_TimerClass() { return (avmplus::TimerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_utils_Timer)); }
    REALLY_INLINE GCRef<avmplus::TimerEventClass> get_TimerEventClass() { return (avmplus::TimerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_events_TimerEvent)); }
    REALLY_INLINE GCRef<avmplus::TraceClass> get_TraceClass() { return (avmplus::TraceClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_trace_Trace)); }
    REALLY_INLINE GCRef<avmplus::TriangleCullingClass> get_TriangleCullingClass() { return (avmplus::TriangleCullingClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_display_TriangleCulling)); }
    REALLY_INLINE GCRef<avmplus::URLRequestClass> get_URLRequestClass() { return (avmplus::URLRequestClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_URLRequest)); }
    REALLY_INLINE GCRef<avmplus::URLRequestDefaultsClass> get_URLRequestDefaultsClass() { return (avmplus::URLRequestDefaultsClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_URLRequestDefaults)); }
    REALLY_INLINE GCRef<avmplus::URLRequestHeaderClass> get_URLRequestHeaderClass() { return (avmplus::URLRequestHeaderClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_net_URLRequestHeader)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerClass> get_WorkerClass() { return (avmshell::ShellWorkerClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_Worker)); }
    REALLY_INLINE GCRef<avmshell::ShellWorkerDomainClass> get_WorkerDomainClass() { return (avmshell::ShellWorkerDomainClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerDomain)); }
    REALLY_INLINE GCRef<avmplus::WorkerEventClass> get_WorkerEventClass() { return (avmplus::WorkerEventClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerEvent)); }
    REALLY_INLINE GCRef<avmplus::WorkerStateClass> get_WorkerStateClass() { return (avmplus::WorkerStateClass*)(lazyInitClass(avmplus::NativeID::abcclass_flash_system_WorkerState)); }
    REALLY_INLINE GCRef<avmshell::CTypeClass> get___ctypeClass() { return (avmshell::CTypeClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_ctype___ctype)); }
    REALLY_INLINE GCRef<avmshell::CErrnoClass> get___errnoClass() { return (avmshell::CErrnoClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_errno___errno)); }
    REALLY_INLINE GCRef<avmshell::CFcntlClass> get___fcntlClass() { return (avmshell::CFcntlClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_fcntl___fcntl)); }
    REALLY_INLINE GCRef<avmshell::CArpaInetClass> get___inetClass() { return (avmshell::CArpaInetClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_arpa_inet___inet)); }
    REALLY_INLINE GCRef<avmshell::CLimitsClass> get___limitsClass() { return (avmshell::CLimitsClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_limits___limits)); }
    REALLY_INLINE GCRef<avmshell::CLocaleClass> get___localeClass() { return (avmshell::CLocaleClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_locale___locale)); }
    REALLY_INLINE GCRef<avmshell::CNetdbClass> get___netdbClass() { return (avmshell::CNetdbClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb___netdb)); }
    REALLY_INLINE GCRef<avmshell::CNetinetInClass> get___netinetClass() { return (avmshell::CNetinetInClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet___netinet)); }
    REALLY_INLINE GCRef<avmshell::CSysSelectClass> get___selectClass() { return (avmshell::CSysSelectClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_select___select)); }
    REALLY_INLINE GCRef<avmshell::CSignalClass> get___signalClass() { return (avmshell::CSignalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal___signal)); }
    REALLY_INLINE GCRef<avmshell::CSysSocketClass> get___socketClass() { return (avmshell::CSysSocketClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket___socket)); }
    REALLY_INLINE GCRef<avmshell::CSysStatClass> get___statClass() { return (avmshell::CSysStatClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat___stat)); }
    REALLY_INLINE GCRef<avmshell::CStdioClass> get___stdioClass() { return (avmshell::CStdioClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio___stdio)); }
    REALLY_INLINE GCRef<avmshell::CStdlibClass> get___stdlibClass() { return (avmshell::CStdlibClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib___stdlib)); }
    REALLY_INLINE GCRef<avmshell::CTimeClass> get___timeClass() { return (avmshell::CTimeClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time___time)); }
    REALLY_INLINE GCRef<avmshell::CUnistdClass> get___unistdClass() { return (avmshell::CUnistdClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_unistd___unistd)); }
    REALLY_INLINE GCRef<avmshell::CSysWaitClass> get___waitClass() { return (avmshell::CSysWaitClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait___wait)); }
    REALLY_INLINE GCRef<avmshell::CaddrinfoClass> get_addrinfoClass() { return (avmshell::CaddrinfoClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_addrinfo)); }
    REALLY_INLINE GCRef<avmshell::CdirentClass> get_direntClass() { return (avmshell::CdirentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_dirent_dirent)); }
    REALLY_INLINE GCRef<avmshell::Cdiv_tClass> get_div_tClass() { return (avmshell::Cdiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_div_t)); }
    REALLY_INLINE GCRef<avmshell::Cfd_setClass> get_fd_setClass() { return (avmshell::Cfd_setClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_select_fd_set)); }
    REALLY_INLINE GCRef<avmshell::Cfpos_tClass> get_fpos_tClass() { return (avmshell::Cfpos_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdio_fpos_t)); }
    REALLY_INLINE GCRef<avmshell::ChostentClass> get_hostentClass() { return (avmshell::ChostentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_hostent)); }
    REALLY_INLINE GCRef<avmshell::CIn6_AddrClass> get_in6_addrClass() { return (avmshell::CIn6_AddrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in6_addr)); }
    REALLY_INLINE GCRef<avmshell::CIn_AddrClass> get_in_addrClass() { return (avmshell::CIn_AddrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_in_addr)); }
    REALLY_INLINE GCRef<avmplus::ipv6_mreqClass> get_ipv6_mreqClass() { return (avmplus::ipv6_mreqClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_ipv6_mreq)); }
    REALLY_INLINE GCRef<avmplus::itimerspecClass> get_itimerspecClass() { return (avmplus::itimerspecClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time_itimerspec)); }
    REALLY_INLINE GCRef<avmshell::Cldiv_tClass> get_ldiv_tClass() { return (avmshell::Cldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_ldiv_t)); }
    REALLY_INLINE GCRef<avmshell::Clldiv_tClass> get_lldiv_tClass() { return (avmshell::Clldiv_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_stdlib_lldiv_t)); }
    REALLY_INLINE GCRef<avmplus::msghdrClass> get_msghdrClass() { return (avmplus::msghdrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_msghdr)); }
    REALLY_INLINE GCRef<avmplus::netentClass> get_netentClass() { return (avmplus::netentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_netent)); }
    REALLY_INLINE GCRef<avmshell::Cpid_tClass> get_pid_tClass() { return (avmshell::Cpid_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_spawn_pid_t)); }
    REALLY_INLINE GCRef<avmshell::CprotoentClass> get_protoentClass() { return (avmshell::CprotoentClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_protoent)); }
    REALLY_INLINE GCRef<avmplus::serventClass> get_serventClass() { return (avmplus::serventClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netdb_servent)); }
    REALLY_INLINE GCRef<avmshell::Csiginfo_tClass> get_siginfo_tClass() { return (avmshell::Csiginfo_tClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_siginfo_t)); }
    REALLY_INLINE GCRef<avmshell::CsigvalClass> get_sigvalClass() { return (avmshell::CsigvalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_signal_sigval)); }
    REALLY_INLINE GCRef<avmshell::CsockaddrClass> get_sockaddrClass() { return (avmshell::CsockaddrClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr)); }
    REALLY_INLINE GCRef<avmshell::CSockaddr_in6Class> get_sockaddr_in6Class() { return (avmshell::CSockaddr_in6Class*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in6)); }
    REALLY_INLINE GCRef<avmshell::CSockaddr_inClass> get_sockaddr_inClass() { return (avmshell::CSockaddr_inClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_netinet_sockaddr_in)); }
    REALLY_INLINE GCRef<avmplus::sockaddr_storageClass> get_sockaddr_storageClass() { return (avmplus::sockaddr_storageClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_socket_sockaddr_storage)); }
    REALLY_INLINE GCRef<avmshell::CStatusClass> get_statusClass() { return (avmshell::CStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_stat_status)); }
    REALLY_INLINE GCRef<avmplus::timespecClass> get_timespecClass() { return (avmplus::timespecClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time_timespec)); }
    REALLY_INLINE GCRef<avmshell::CtimevalClass> get_timevalClass() { return (avmshell::CtimevalClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_select_timeval)); }
    REALLY_INLINE GCRef<avmplus::tmClass> get_tmClass() { return (avmplus::tmClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_time_tm)); }
    REALLY_INLINE GCRef<avmplus::utsnameClass> get_utsnameClass() { return (avmplus::utsnameClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_utsname_utsname)); }
    REALLY_INLINE GCRef<avmshell::CWaitStatusClass> get_wait_statusClass() { return (avmshell::CWaitStatusClass*)(lazyInitClass(avmplus::NativeID::abcclass_C_sys_wait_wait_status)); }
};
}
#endif // _H_nativegen_header_shell_toplevel
