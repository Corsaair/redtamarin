; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\src\redux\core\Interpreter.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??1Translator@avmplus@@QAE@XZ:PROC		; avmplus::Translator::~Translator
PUBLIC	?branchCheck@AvmCore@avmplus@@QAEXPAVMethodEnv@2@_NH@Z ; avmplus::AvmCore::branchCheck
; Function compile flags: /Ogtpy
; File c:\src\redux\core\avmcore.h
;	COMDAT ?branchCheck@AvmCore@avmplus@@QAEXPAVMethodEnv@2@_NH@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
_interruptable$ = 12					; size = 1
_go$ = 16						; size = 4
?branchCheck@AvmCore@avmplus@@QAEXPAVMethodEnv@2@_NH@Z PROC ; avmplus::AvmCore::branchCheck, COMDAT
; _this$ = ecx

; 125  : 			if(go < 0)

	cmp	DWORD PTR _go$[esp-4], 0
	jge	SHORT $LN1@branchChec

; 126  : 			{
; 127  : #ifdef DEBUGGER
; 128  : 				sampleCheck();
; 129  : #endif
; 130  : 				if (interruptable && interrupted)

	cmp	BYTE PTR _interruptable$[esp-4], 0
	je	SHORT $LN1@branchChec
	cmp	DWORD PTR [ecx+220], 0
	je	SHORT $LN1@branchChec

; 131  : 						interrupt(env);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _env$[esp-4]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	call	eax
$LN1@branchChec:

; 132  : 			}
; 133  : 		}

	ret	12					; 0000000cH
?branchCheck@AvmCore@avmplus@@QAEXPAVMethodEnv@2@_NH@Z ENDP ; avmplus::AvmCore::branchCheck
_TEXT	ENDS
EXTRN	?integer@AvmCore@avmplus@@QBEHH@Z:PROC		; avmplus::AvmCore::integer
EXTRN	?intToAtom@AvmCore@avmplus@@QAEHH@Z:PROC	; avmplus::AvmCore::intToAtom
EXTRN	?uintToAtom@AvmCore@avmplus@@QAEHI@Z:PROC	; avmplus::AvmCore::uintToAtom
EXTRN	?istype@AvmCore@avmplus@@QAE_NHPAVTraits@2@@Z:PROC ; avmplus::AvmCore::istype
EXTRN	__fltused:DWORD
EXTRN	?newNamespace@AvmCore@avmplus@@QAEPAVNamespace@2@PAVString@2@W4NamespaceType@32@@Z:PROC ; avmplus::AvmCore::newNamespace
EXTRN	?endTry@ExceptionFrame@avmplus@@QAEXXZ:PROC	; avmplus::ExceptionFrame::endTry
EXTRN	?integer_i@AvmCore@avmplus@@SAHH@Z:PROC
EXTRN	?real2int@MathUtils@avmplus@@SAHN@Z:PROC	; avmplus::MathUtils::real2int
EXTRN	?integer_u@AvmCore@avmplus@@SAIH@Z:PROC
EXTRN	?isDictionary@AvmCore@avmplus@@QAE_NH@Z:PROC	; avmplus::AvmCore::isDictionary
EXTRN	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z:PROC ; avmplus::PoolObject::parseMultiname
PUBLIC	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
EXTRN	?internRtns@MethodEnv@avmplus@@QAEPAVNamespace@2@H@Z:PROC ; avmplus::MethodEnv::internRtns
EXTRN	?intern@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::intern
EXTRN	?throwTypeError@Toplevel@avmplus@@QBEXHPAVString@2@@Z:PROC ; avmplus::Toplevel::throwTypeError
EXTRN	?toErrorString@AvmCore@avmplus@@QAEPAVString@2@PAVTraits@2@@Z:PROC ; avmplus::AvmCore::toErrorString
EXTRN	?toTraits@Toplevel@avmplus@@QAEPAVTraits@2@H@Z:PROC ; avmplus::Toplevel::toTraits
EXTRN	?isXMLList@AvmCore@avmplus@@QAE_NH@Z:PROC	; avmplus::AvmCore::isXMLList
; Function compile flags: /Ogtpy
; File c:\src\redux\core\interpreter.cpp
_TEXT	SEGMENT
_env$ = 8						; size = 4
tv246 = 12						; size = 4
_name$ = 12						; size = 4
_sp$ = 16						; size = 4
_isDelete$ = 20						; size = 1
?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z PROC ; avmplus::initMultiname

; 2537 : 	{

	push	ebx
	push	ebp

; 2538 : 		if (name.isRtname())
; 2539 : 		{
; 2540 : 			Atom index = *(sp--);

	mov	ebp, DWORD PTR _sp$[esp+4]
	push	esi
	mov	esi, DWORD PTR _name$[esp+8]
	test	BYTE PTR [esi], 8
	push	edi
	je	$LN55@initMultin

; 2541 : 			AvmCore* core = env->core();

	mov	eax, DWORD PTR _env$[esp+12]
	mov	ecx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [edx+4]
	sub	ebp, 4

; 2542 : 
; 2543 : 			if (isDelete)

	cmp	BYTE PTR _isDelete$[esp+12], 0
	je	SHORT $LN67@initMultin

; 2544 : 			{
; 2545 : 				if (core->isXMLList(index))

	push	edi
	mov	ecx, ebx
	call	?isXMLList@AvmCore@avmplus@@QAE_NH@Z	; avmplus::AvmCore::isXMLList
	test	al, al
	je	SHORT $LN67@initMultin

; 2546 : 				{
; 2547 : 					// Error according to E4X spec, section 11.3.1
; 2548 : 					env->toplevel()->throwTypeError(kDeleteTypeError, core->toErrorString(env->toplevel()->toTraits(index)));

	mov	eax, DWORD PTR _env$[esp+12]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	push	edi
	mov	DWORD PTR tv246[esp+16], ecx
	call	?toTraits@Toplevel@avmplus@@QAEPAVTraits@2@H@Z ; avmplus::Toplevel::toTraits
	push	eax
	mov	ecx, ebx
	call	?toErrorString@AvmCore@avmplus@@QAEPAVString@2@PAVTraits@2@@Z ; avmplus::AvmCore::toErrorString
	mov	ecx, DWORD PTR tv246[esp+12]
	push	eax
	push	1119					; 0000045fH
	call	?throwTypeError@Toplevel@avmplus@@QBEXHPAVString@2@@Z ; avmplus::Toplevel::throwTypeError
$LN67@initMultin:

; 2549 : 				}
; 2550 : 			}
; 2551 : 			
; 2552 : 			// is it a qname?
; 2553 : 			if (AvmCore::isObject(index))

	mov	edx, edi
	and	dl, 7
	cmp	dl, 1
	jne	SHORT $LN4@initMultin
	cmp	edi, 4
	jb	SHORT $LN4@initMultin

; 2554 : 			{
; 2555 : 				ScriptObject* i = AvmCore::atomToScriptObject(index);

	mov	eax, edi
	and	eax, -8					; fffffff8H

; 2556 : 				if (i->traits() == core->traits.qName_itraits)

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [ebx+176]
	jne	SHORT $LN4@initMultin

; 2557 : 				{
; 2558 : 					QNameObject* qname = (QNameObject*) i;
; 2559 : 					bool attr = name.isAttr();

	mov	cl, BYTE PTR [esi]

; 2560 : 					qname->getMultiname(name);

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi], edx
	and	cl, 1
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [esi+12], eax

; 2561 : 					if (attr)

	je	SHORT $LN46@initMultin

; 2562 : 						name.setAttr(attr);

	or	DWORD PTR [esi], 1
$LN46@initMultin:

; 2563 : 
; 2564 : 					// Discard runtime namespace if present
; 2565 : 					if (name.isRtns())

	test	BYTE PTR [esi], 4
	je	SHORT $LN1@initMultin
	pop	edi

; 2576 : 			name.setNamespace(env->internRtns(*(sp--)));

	sub	ebp, 4
	pop	esi

; 2577 : 
; 2578 : 		return sp;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2579 : 	}

	ret	0
$LN4@initMultin:

; 2566 : 						sp--;
; 2567 : 
; 2568 : 					return sp;
; 2569 : 				}
; 2570 : 			}
; 2571 : 					
; 2572 : 			name.setName(core->intern(index));

	push	edi
	mov	ecx, ebx
	call	?intern@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::intern
	and	DWORD PTR [esi], -9			; fffffff7H
	mov	DWORD PTR [esi+4], eax
$LN55@initMultin:

; 2573 : 		}
; 2574 : 
; 2575 : 		if (name.isRtns())

	test	BYTE PTR [esi], 4
	je	SHORT $LN1@initMultin

; 2576 : 			name.setNamespace(env->internRtns(*(sp--)));

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR _env$[esp+12]
	push	eax
	call	?internRtns@MethodEnv@avmplus@@QAEPAVNamespace@2@H@Z ; avmplus::MethodEnv::internRtns
	and	DWORD PTR [esi], -21			; ffffffebH
	mov	DWORD PTR [esi+8], eax
	sub	ebp, 4
$LN1@initMultin:
	pop	edi
	pop	esi

; 2577 : 
; 2578 : 		return sp;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2579 : 	}

	ret	0
?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ENDP ; avmplus::initMultiname
_TEXT	ENDS
PUBLIC	?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ; avmplus::getTraits
EXTRN	?internString@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::internString
EXTRN	?concatStrings@AvmCore@avmplus@@QBEPAVString@2@PAV32@0@Z:PROC ; avmplus::AvmCore::concatStrings
EXTRN	?formatClassName@Traits@avmplus@@QAEPAVString@2@XZ:PROC ; avmplus::Traits::formatClassName
EXTRN	?newString@AvmCore@avmplus@@QBEPAVString@2@PBD@Z:PROC ; avmplus::AvmCore::newString
EXTRN	??0Multiname@avmplus@@QAE@XZ:PROC		; avmplus::Multiname::Multiname
EXTRN	?getTraits@PoolObject@avmplus@@QBEPAVTraits@2@PAVMultiname@2@PBVToplevel@2@_N@Z:PROC ; avmplus::PoolObject::getTraits
;	COMDAT ??_C@_02EBJODEPI@?4?$DM?$AA@
; File c:\src\redux\core\multiname.h
CONST	SEGMENT
??_C@_02EBJODEPI@?4?$DM?$AA@ DB '.<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\redux\core\interpreter.cpp
CONST	ENDS
_TEXT	SEGMENT
$T41168 = -36						; size = 4
_newname$40615 = -32					; size = 16
_param_name$40610 = -16					; size = 16
_param_traits$40611 = 8					; size = 4
_name$ = 8						; size = 4
_pool$ = 12						; size = 4
_toplevel$ = 16						; size = 4
_core$ = 20						; size = 4
?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z PROC ; avmplus::getTraits

; 2582 : 	{

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp

; 2583 : 		Traits* t = pool->getTraits(name, toplevel);

	mov	ebp, DWORD PTR _toplevel$[esp+40]
	push	esi
	mov	esi, DWORD PTR _name$[esp+44]
	push	edi
	mov	edi, DWORD PTR _pool$[esp+48]
	push	1
	push	ebp
	push	esi
	mov	ecx, edi
	call	?getTraits@PoolObject@avmplus@@QBEPAVTraits@2@PAVMultiname@2@PBVToplevel@2@_N@Z ; avmplus::PoolObject::getTraits

; 2584 : 		if( name->isParameterizedType() )

	test	BYTE PTR [esi], 64			; 00000040H
	mov	ebx, eax
	je	$LN43@getTraits

; 2585 : 		{
; 2586 : 			Multiname param_name;

	lea	ecx, DWORD PTR _param_name$40610[esp+52]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2587 : 			pool->parseMultiname(param_name, name->getTypeParameter());

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [edi+104]
	lea	eax, DWORD PTR _param_name$40610[esp+52]
	push	eax
	mov	eax, DWORD PTR [edx+ecx*4]
	shr	eax, 3
	add	eax, DWORD PTR [edi+272]
	mov	ecx, edi
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2588 : 
; 2589 : 			Traits* param_traits = getTraits(&param_name, pool, toplevel, core);

	mov	esi, DWORD PTR _core$[esp+48]
	push	esi
	push	ebp
	lea	ecx, DWORD PTR _param_name$40610[esp+60]
	push	edi
	push	ecx
	call	?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ; avmplus::getTraits

; 2590 : 			Stringp fullname = core->internString( core->concatStrings(t->name, 
; 2591 : 				core->concatStrings(core->concatStrings(core->newString(".<"), param_traits->formatClassName()), core->newString(">")))->atom());

	mov	edx, DWORD PTR [ebx+28]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	ecx, esi
	mov	DWORD PTR _param_traits$40611[esp+52], eax
	mov	DWORD PTR $T41168[esp+56], edx
	call	?newString@AvmCore@avmplus@@QBEPAVString@2@PBD@Z ; avmplus::AvmCore::newString
	mov	ecx, DWORD PTR _param_traits$40611[esp+48]
	push	eax
	call	?formatClassName@Traits@avmplus@@QAEPAVString@2@XZ ; avmplus::Traits::formatClassName
	push	eax
	push	OFFSET ??_C@_02EBJODEPI@?4?$DM?$AA@
	mov	ecx, esi
	call	?newString@AvmCore@avmplus@@QBEPAVString@2@PBD@Z ; avmplus::AvmCore::newString
	push	eax
	mov	ecx, esi
	call	?concatStrings@AvmCore@avmplus@@QBEPAVString@2@PAV32@0@Z ; avmplus::AvmCore::concatStrings
	push	eax
	mov	ecx, esi
	call	?concatStrings@AvmCore@avmplus@@QBEPAVString@2@PAV32@0@Z ; avmplus::AvmCore::concatStrings
	push	eax
	mov	eax, DWORD PTR $T41168[esp+56]
	push	eax
	mov	ecx, esi
	call	?concatStrings@AvmCore@avmplus@@QBEPAVString@2@PAV32@0@Z ; avmplus::AvmCore::concatStrings
	or	eax, 2
	push	eax
	mov	ecx, esi
	call	?internString@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::internString

; 2592 : 
; 2593 : 			Multiname newname;

	lea	ecx, DWORD PTR _newname$40615[esp+52]
	mov	esi, eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2594 : 			newname.setName(fullname);

	mov	eax, DWORD PTR _newname$40615[esp+52]

; 2595 : 			newname.setNamespace(t->ns);

	mov	ecx, DWORD PTR [ebx+24]

; 2596 : 			t = pool->getTraits(&newname, toplevel);

	push	1
	and	eax, -9					; fffffff7H
	push	ebp
	lea	edx, DWORD PTR _newname$40615[esp+60]
	and	eax, -21				; ffffffebH
	mov	DWORD PTR _newname$40615[esp+68], ecx
	push	edx
	mov	ecx, edi
	mov	DWORD PTR _newname$40615[esp+68], esi
	mov	DWORD PTR _newname$40615[esp+64], eax
	call	?getTraits@PoolObject@avmplus@@QBEPAVTraits@2@PAVMultiname@2@PBVToplevel@2@_N@Z ; avmplus::PoolObject::getTraits

; 2597 : 		}

$LN43@getTraits:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2598 : 		return t;
; 2599 : 	}

	add	esp, 36					; 00000024H
	ret	0
?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ENDP ; avmplus::getTraits
_TEXT	ENDS
PUBLIC	?interp@avmplus@@YAHPAVMethodEnv@1@HPAI@Z	; avmplus::interp
EXTRN	?in@MethodEnv@avmplus@@QBEHHH@Z:PROC		; avmplus::MethodEnv::in
EXTRN	?instanceof@Toplevel@avmplus@@QAEHHH@Z:PROC	; avmplus::Toplevel::instanceof
EXTRN	?throwAtom@AvmCore@avmplus@@QAEXH@Z:PROC	; avmplus::AvmCore::throwAtom
EXTRN	?newcatch@MethodEnv@avmplus@@QAEPAVScriptObject@2@PAVTraits@2@@Z:PROC ; avmplus::MethodEnv::newcatch
EXTRN	?newActivation@AvmCore@avmplus@@QAEPAVScriptObject@2@PAVVTable@2@PAV32@@Z:PROC ; avmplus::AvmCore::newActivation
EXTRN	?getActivation@MethodEnv@avmplus@@QAEPAVVTable@2@XZ:PROC ; avmplus::MethodEnv::getActivation
EXTRN	?toClassITraits@MethodEnv@avmplus@@QAEPAVTraits@2@H@Z:PROC ; avmplus::MethodEnv::toClassITraits
EXTRN	?astype@MethodEnv@avmplus@@QAEHHPAVTraits@2@@Z:PROC ; avmplus::MethodEnv::astype
EXTRN	?setsuper@MethodEnv@avmplus@@QBEXHPAVMultiname@2@H@Z:PROC ; avmplus::MethodEnv::setsuper
EXTRN	?getsuper@MethodEnv@avmplus@@QBEHHPAVMultiname@2@@Z:PROC ; avmplus::MethodEnv::getsuper
EXTRN	?callsuper@MethodEnv@avmplus@@QBEHPAVMultiname@2@HPAH@Z:PROC ; avmplus::MethodEnv::callsuper
EXTRN	?op_applytype@Toplevel@avmplus@@QAEHHHPAH@Z:PROC ; avmplus::Toplevel::op_applytype
EXTRN	?constructprop@Toplevel@avmplus@@QAEHPAVMultiname@2@HPAHPAVVTable@2@@Z:PROC ; avmplus::Toplevel::constructprop
EXTRN	?callproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@HPAHPAVVTable@2@@Z:PROC ; avmplus::Toplevel::callproperty
EXTRN	?coerceEnter@MethodEnv@avmplus@@QAEHHPAH@Z:PROC	; avmplus::MethodEnv::coerceEnter
EXTRN	?newclass@MethodEnv@avmplus@@QBEPAVClassClosure@2@PAVAbstractFunction@2@PAV32@PAVScopeChain@2@PAH@Z:PROC ; avmplus::MethodEnv::newclass
EXTRN	?newfunction@MethodEnv@avmplus@@QBEPAVClassClosure@2@PAVAbstractFunction@2@PAVScopeChain@2@PAH@Z:PROC ; avmplus::MethodEnv::newfunction
EXTRN	?getMethodInfo@PoolObject@avmplus@@QAEPAVAbstractFunction@2@I@Z:PROC ; avmplus::PoolObject::getMethodInfo
EXTRN	?op_construct@Toplevel@avmplus@@QAEHHHPAH@Z:PROC ; avmplus::Toplevel::op_construct
EXTRN	?op_call@Toplevel@avmplus@@QAEHHHPAH@Z:PROC	; avmplus::Toplevel::op_call
EXTRN	?getSlotAtom@ScriptObject@avmplus@@QAEHH@Z:PROC	; avmplus::ScriptObject::getSlotAtom
EXTRN	?setSlotAtom@ScriptObject@avmplus@@QAEXHH@Z:PROC ; avmplus::ScriptObject::setSlotAtom
EXTRN	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z:PROC ; avmplus::Toplevel::coerce
EXTRN	?delproperty@MethodEnv@avmplus@@QBEHHPAVMultiname@2@@Z:PROC ; avmplus::MethodEnv::delproperty
EXTRN	?hasnext2@MethodEnv@avmplus@@QBEHAAH0@Z:PROC	; avmplus::MethodEnv::hasnext2
EXTRN	?hasnext@MethodEnv@avmplus@@QBEHHH@Z:PROC	; avmplus::MethodEnv::hasnext
EXTRN	?nextvalue@MethodEnv@avmplus@@QBEHHH@Z:PROC	; avmplus::MethodEnv::nextvalue
EXTRN	?nextname@MethodEnv@avmplus@@QBEHHH@Z:PROC	; avmplus::MethodEnv::nextname
EXTRN	?finddef@MethodEnv@avmplus@@QBEPAVScriptObject@2@PAVMultiname@2@@Z:PROC ; avmplus::MethodEnv::finddef
EXTRN	?checkfilter@MethodEnv@avmplus@@QAEXH@Z:PROC	; avmplus::MethodEnv::checkfilter
EXTRN	?getdescendants@MethodEnv@avmplus@@QAEHHPAVMultiname@2@@Z:PROC ; avmplus::MethodEnv::getdescendants
EXTRN	?initproperty@MethodEnv@avmplus@@QBEXHPAVMultiname@2@HPAVVTable@2@@Z:PROC ; avmplus::MethodEnv::initproperty
EXTRN	?setproperty@Toplevel@avmplus@@QBEXHPAVMultiname@2@HPAVVTable@2@@Z:PROC ; avmplus::Toplevel::setproperty
EXTRN	?getproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@PAVVTable@2@@Z:PROC ; avmplus::Toplevel::getproperty
EXTRN	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z:PROC ; avmplus::Toplevel::toVTable
EXTRN	?findproperty@MethodEnv@avmplus@@QAEHPAVScopeChain@2@PAHHPAVMultiname@2@_N1@Z:PROC ; avmplus::MethodEnv::findproperty
EXTRN	?newarray@ArrayClass@avmplus@@QAEPAVArrayObject@2@PAHH@Z:PROC ; avmplus::ArrayClass::newarray
EXTRN	?op_newobject@MethodEnv@avmplus@@QBEPAVScriptObject@2@PAHH@Z:PROC ; avmplus::MethodEnv::op_newobject
EXTRN	?compare@AvmCore@avmplus@@QAEHHH@Z:PROC		; avmplus::AvmCore::compare
EXTRN	?stricteq@AvmCore@avmplus@@QAEHHH@Z:PROC	; avmplus::AvmCore::stricteq
EXTRN	?eq@AvmCore@avmplus@@QAEHHH@Z:PROC		; avmplus::AvmCore::eq
EXTRN	?mod@MathUtils@avmplus@@SANNN@Z:PROC		; avmplus::MathUtils::mod
EXTRN	?add2@Toplevel@avmplus@@QAEHHH@Z:PROC		; avmplus::Toplevel::add2
EXTRN	?increment_i@AvmCore@avmplus@@QAEXPAHH@Z:PROC	; avmplus::AvmCore::increment_i
EXTRN	?increment_d@AvmCore@avmplus@@QAEXPAHH@Z:PROC	; avmplus::AvmCore::increment_d
EXTRN	?_typeof@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::_typeof
EXTRN	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z:PROC	; avmplus::AvmCore::doubleToAtom
EXTRN	?number@AvmCore@avmplus@@QBENH@Z:PROC		; avmplus::AvmCore::number
EXTRN	?nullcheck@MethodEnv@avmplus@@QAEXH@Z:PROC	; avmplus::MethodEnv::nullcheck
EXTRN	?booleanAtom@AvmCore@avmplus@@QAEHH@Z:PROC	; avmplus::AvmCore::booleanAtom
EXTRN	?numberAtom@AvmCore@avmplus@@QAEHH@Z:PROC	; avmplus::AvmCore::numberAtom
EXTRN	?EscapeAttributeValue@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::EscapeAttributeValue
EXTRN	?ToXMLString@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::ToXMLString
EXTRN	?string@AvmCore@avmplus@@QAEPAVString@2@H@Z:PROC ; avmplus::AvmCore::string
EXTRN	?findExceptionHandler@AvmCore@avmplus@@QAEPAVExceptionHandler@2@PAVMethodInfo@2@HPAVException@2@@Z:PROC ; avmplus::AvmCore::findExceptionHandler
EXTRN	?beginCatch@ExceptionFrame@avmplus@@QAEXXZ:PROC	; avmplus::ExceptionFrame::beginCatch
EXTRN	?beginTry@ExceptionFrame@avmplus@@QAEXPAVAvmCore@2@@Z:PROC ; avmplus::ExceptionFrame::beginTry
EXTRN	?createArguments@MethodEnv@avmplus@@QAEPAVArrayObject@2@PAHH@Z:PROC ; avmplus::MethodEnv::createArguments
EXTRN	?createRest@MethodEnv@avmplus@@QAEPAVArrayObject@2@PAHH@Z:PROC ; avmplus::MethodEnv::createRest
EXTRN	?boxArgs@AbstractFunction@avmplus@@QAEXHPAIPAH@Z:PROC ; avmplus::AbstractFunction::boxArgs
EXTRN	?translate@Translator@avmplus@@QAEXPAVMethodEnv@2@@Z:PROC ; avmplus::Translator::translate
EXTRN	??0Translator@avmplus@@QAE@PAPAX@Z:PROC		; avmplus::Translator::Translator
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__setjmp3:PROC
EXTRN	__alloca_probe_16:PROC
;	COMDAT ?opcode_labels@?L@??interp@avmplus@@YAHPAVMethodEnv@2@HPAI@Z@4PAPAXA
; File c:\src\redux\core\exception.h
_BSS	SEGMENT
_BSS	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
; File c:\src\redux\core\interpreter.cpp
CONST	ENDS
_TEXT	SEGMENT
__ef$39597 = -2008					; size = 80
$T41944 = -1928						; size = 8
$T41924 = -1920						; size = 8
$T41904 = -1912						; size = 8
$T41444 = -1904						; size = 8
_exception$40572 = -1896				; size = 4
$T41373 = -1892						; size = 4
$T41334 = -1888						; size = 4
$T41434 = -1884						; size = 4
_booleanNotMask$ = -1880				; size = 4
$T41515 = -1876						; size = 4
$T41314 = -1872						; size = 4
_lop$39812 = -1868					; size = 4
$T41307 = -1864						; size = 4
_key$40281 = -1860					; size = 4
$T41303 = -1856						; size = 4
_rhs$40071 = -1852					; size = 4
$T41295 = -1848						; size = 4
_lop$39893 = -1844					; size = 4
$T41290 = -1840						; size = 4
_result$39742 = -1836					; size = 4
$T41285 = -1832						; size = 4
_obj$40294 = -1828					; size = 4
_n$39563 = -1824					; size = 4
$T41558 = -1820						; size = 4
_atomv$ = -1816						; size = 4
_handler$40574 = -1812					; size = 4
$T41280 = -1808						; size = 4
$T41261 = -1804						; size = 4
$T41276 = -1800						; size = 4
_result$39957 = -1796					; size = 4
_max_scope_depth$ = -1792				; size = 4
_lop$39842 = -1788					; size = 4
_init_scope_depth$ = -1784				; size = 4
_rp$39781 = -1780					; size = 4
$T41200 = -1776						; size = 4
$T41400 = -1772						; size = 4
$T41201 = -1768						; size = 4
_value$40298 = -1764					; size = 4
$T41197 = -1760						; size = 4
$T41700 = -1756						; size = 4
$T41265 = -1752						; size = 4
_a$41581 = -1748					; size = 4
$T41503 = -1744						; size = 4
_argc$40267 = -1740					; size = 4
$T41497 = -1736						; size = 4
$T41509 = -1732						; size = 4
$T41485 = -1728						; size = 4
$T41473 = -1724						; size = 4
$T41491 = -1720						; size = 4
_sp$39256 = -1716					; size = 4
$T41479 = -1712						; size = 4
$T42631 = -1708						; size = 4
_offset$40097 = -1704					; size = 4
$T42632 = -1700						; size = 4
_lhs$40052 = -1696					; size = 4
$T42626 = -1692						; size = 4
_obj$41451 = -1688					; size = 4
$T42627 = -1684						; size = 4
$T41425 = -1680						; size = 4
$T42621 = -1676						; size = 4
_lop$39911 = -1672					; size = 4
_rhs$40546 = -1668					; size = 4
_result$39861 = -1664					; size = 4
_lhs$40545 = -1660					; size = 4
_lop$39827 = -1656					; size = 4
_rhs$40542 = -1652					; size = 4
_lhs$39796 = -1648					; size = 4
_lhs$40541 = -1644					; size = 4
_rp$39766 = -1640					; size = 4
$T42612 = -1636						; size = 4
_lhs$39696 = -1632					; size = 4
$T42617 = -1628						; size = 4
$T41387 = -1624						; size = 4
$T42602 = -1620						; size = 4
_a$41766 = -1616					; size = 4
$T42607 = -1612						; size = 4
$T41740 = -1608						; size = 4
$T42597 = -1604						; size = 4
$T41698 = -1600						; size = 4
$T42593 = -1596						; size = 4
_a$41655 = -1592					; size = 4
$T42589 = -1588						; size = 4
$T41625 = -1584						; size = 4
_t$40515 = -1580					; size = 4
_obj$40272 = -1576					; size = 4
_catch_index$40514 = -1572				; size = 4
$T41527 = -1568						; size = 4
$T42585 = -1564						; size = 4
$T41519 = -1560						; size = 4
$T42568 = -1556						; size = 4
_rhs$40209 = -1552					; size = 4
_scope_index$40498 = -1548				; size = 4
_rhs$40194 = -1544					; size = 4
_scope_index$40495 = -1540				; size = 4
_rhs$40179 = -1536					; size = 4
$T42560 = -1532						; size = 4
_rhs$40164 = -1528					; size = 4
$T42561 = -1524						; size = 4
_rhs$40149 = -1520					; size = 4
_rhs$40492 = -1516					; size = 4
_rhs$40134 = -1512					; size = 4
_lhs$40491 = -1508					; size = 4
_rhs$40119 = -1504					; size = 4
$T42552 = -1500						; size = 4
_rhs$40104 = -1496					; size = 4
$T42553 = -1492						; size = 4
_lhs$40088 = -1488					; size = 4
_itraits$40488 = -1484					; size = 4
_offset$40061 = -1480					; size = 4
_a$42537 = -1476					; size = 4
_rhs$40035 = -1472					; size = 4
$T42548 = -1468						; size = 4
$T41256 = -1464						; size = 4
$T42517 = -1460						; size = 4
_base$40000 = -1456					; size = 4
_a$42496 = -1452					; size = 4
$T41429 = -1448						; size = 4
$T42507 = -1444						; size = 4
$T41420 = -1440						; size = 4
_rhs$40474 = -1436					; size = 4
_result$39915 = -1432					; size = 4
_lhs$40473 = -1428					; size = 4
_result$39897 = -1424					; size = 4
_a$42462 = -1420					; size = 4
_rop$39877 = -1416					; size = 4
$T42473 = -1412						; size = 4
_lop$39857 = -1408					; size = 4
$T42442 = -1404						; size = 4
_rp$39839 = -1400					; size = 4
$T42438 = -1396						; size = 4
_rp$39824 = -1392					; size = 4
_argc$40467 = -1388					; size = 4
_result$39800 = -1384					; size = 4
_valueAtom$40460 = -1380				; size = 4
_lop$39784 = -1376					; size = 4
_a$42418 = -1372					; size = 4
_lop$39769 = -1368					; size = 4
_index$40458 = -1364					; size = 4
_lop$39754 = -1360					; size = 4
_objAtom$40455 = -1356					; size = 4
$T41415 = -1352						; size = 4
_objAtom$40453 = -1348					; size = 4
$T41408 = -1344						; size = 4
_a$42381 = -1340					; size = 4
$T41396 = -1336						; size = 4
$T42392 = -1332						; size = 4
$T41382 = -1328						; size = 4
_tempAtom$40446 = -1324					; size = 4
_line$39629 = -1320					; size = 4
_argc$40444 = -1316					; size = 4
$T41777 = -1312						; size = 4
_a$42344 = -1308					; size = 4
_a$41729 = -1304					; size = 4
$T42355 = -1300						; size = 4
_obj$40291 = -1296					; size = 4
_tempAtom$40438 = -1292					; size = 4
_key$40293 = -1288					; size = 4
_argc$40436 = -1284					; size = 4
$T41699 = -1280						; size = 4
_a$42307 = -1276					; size = 4
_obj$40287 = -1272					; size = 4
$T42318 = -1268						; size = 4
$T41666 = -1264						; size = 4
_tempAtom$40432 = -1260					; size = 4
$T41624 = -1256						; size = 4
_argc$40431 = -1252					; size = 4
$T41626 = -1248						; size = 4
_tempAtom$40426 = -1244					; size = 4
$T41592 = -1240						; size = 4
_argc$40424 = -1236					; size = 4
_a$41547 = -1232					; size = 4
_a$42270 = -1228					; size = 4
_tempAtom$40268 = -1224					; size = 4
$T42281 = -1220						; size = 4
$T41523 = -1216						; size = 4
_base$40419 = -1212					; size = 4
_tempAtom$40264 = -1208					; size = 4
_a$42233 = -1204					; size = 4
_argc$40263 = -1200					; size = 4
$T42244 = -1196						; size = 4
_offset$40217 = -1192					; size = 4
_atomv$40414 = -1188					; size = 4
_lhs$40208 = -1184					; size = 4
_a$42196 = -1180					; size = 4
_offset$40202 = -1176					; size = 4
$T42207 = -1172						; size = 4
_lhs$40193 = -1168					; size = 4
_base$40407 = -1164					; size = 4
_offset$40187 = -1160					; size = 4
_a$42159 = -1156					; size = 4
_lhs$40178 = -1152					; size = 4
$T42170 = -1148						; size = 4
_offset$40172 = -1144					; size = 4
_tempAtom$40402 = -1140					; size = 4
_lhs$40163 = -1136					; size = 4
_f$40401 = -1132					; size = 4
_offset$40157 = -1128					; size = 4
_vtable$40397 = -1124					; size = 4
_lhs$40148 = -1120					; size = 4
_disp_id$40394 = -1116					; size = 4
_offset$40142 = -1112					; size = 4
_tempAtom$40391 = -1108					; size = 4
_lhs$40133 = -1104					; size = 4
_f$40390 = -1100					; size = 4
_offset$40127 = -1096					; size = 4
$T42139 = -1092						; size = 4
_lhs$40118 = -1088					; size = 4
_argc$40389 = -1084					; size = 4
_offset$40112 = -1080					; size = 4
$T42135 = -1076						; size = 4
_lhs$40103 = -1072					; size = 4
_base$40384 = -1068					; size = 4
_rhs$40089 = -1064					; size = 4
_cinit$40383 = -1060					; size = 4
_offset$40079 = -1056					; size = 4
_class_index$40382 = -1052				; size = 4
_lhs$40070 = -1048					; size = 4
$T42128 = -1044						; size = 4
_rhs$40053 = -1040					; size = 4
_body$40379 = -1036					; size = 4
_offset$40043 = -1032					; size = 4
_tempAtom$40376 = -1028					; size = 4
_lhs$40034 = -1024					; size = 4
_argc$40375 = -1020					; size = 4
$T41461 = -1016						; size = 4
_tempAtom$40372 = -1012					; size = 4
_default_offset$40002 = -1008				; size = 4
_argc$40371 = -1004					; size = 4
$T41455 = -1000						; size = 4
$T42118 = -996						; size = 4
$T41435 = -992						; size = 4
$T42105 = -988						; size = 4
$T41430 = -984						; size = 4
$T42097 = -980						; size = 4
_result$39974 = -976					; size = 4
$T42088 = -972						; size = 4
$T41424 = -968						; size = 4
_op$40363 = -964					; size = 4
$T41419 = -960						; size = 4
_slot_id$40362 = -956					; size = 4
_result$39945 = -952					; size = 4
$T42077 = -948						; size = 4
_rop$39913 = -944					; size = 4
$T42064 = -940						; size = 4
_rhs$39909 = -936					; size = 4
$T42057 = -932						; size = 4
_rop$39895 = -928					; size = 4
$T42049 = -924						; size = 4
_result$39879 = -920					; size = 4
$T42040 = -916						; size = 4
_lop$39875 = -912					; size = 4
_o$40354 = -908						; size = 4
_rop$39859 = -904					; size = 4
_lhs$40351 = -900					; size = 4
_result$39844 = -896					; size = 4
_key$40347 = -892					; size = 4
_lhs$39840 = -888					; size = 4
$T42018 = -884						; size = 4
_result$39829 = -880					; size = 4
$T42019 = -876						; size = 4
_lhs$39825 = -872					; size = 4
$T42020 = -868						; size = 4
_result$39814 = -864					; size = 4
_a$41975 = -860						; size = 4
_lhs$39810 = -856					; size = 4
$T41986 = -852						; size = 4
_lop$39798 = -848					; size = 4
_objectReg$40335 = -844					; size = 4
_result$39786 = -840					; size = 4
_obj$41953 = -836					; size = 4
_lhs$39782 = -832					; size = 4
_rhs$40332 = -828					; size = 4
_result$39771 = -824					; size = 4
_lhs$40331 = -820					; size = 4
_lhs$39767 = -816					; size = 4
_obj$41933 = -812					; size = 4
_result$39756 = -808					; size = 4
_rhs$40328 = -804					; size = 4
_lhs$39752 = -800					; size = 4
_lhs$40327 = -796					; size = 4
_lop$39740 = -792					; size = 4
_obj$41913 = -788					; size = 4
_v$39708 = -784						; size = 4
_rhs$40324 = -780					; size = 4
_lhs$39689 = -776					; size = 4
_lhs$40323 = -772					; size = 4
$T41404 = -768						; size = 4
$T41892 = -764						; size = 4
_tempAtom$39673 = -760					; size = 4
_a$41877 = -756						; size = 4
$T41391 = -752						; size = 4
$T41888 = -748						; size = 4
$T41386 = -744						; size = 4
_a$41840 = -740						; size = 4
$T41377 = -736						; size = 4
$T41851 = -732						; size = 4
_index$39633 = -728					; size = 4
_a$41803 = -724						; size = 4
_line$39625 = -720					; size = 4
$T41814 = -716						; size = 4
$T41467 = -712						; size = 4
_u$40568 = -708						; size = 8
tv7656 = -700						; size = 8
_case_count$40004 = -696				; size = 4
_multiname$40470 = -692					; size = 16
_multiname$40477 = -676					; size = 16
_multiname$40320 = -660					; size = 16
_multiname$40487 = -644					; size = 16
_val$39706 = -628					; size = 4
_rhs$39943 = -624					; size = 4
_cpool_ns$ = -620					; size = 4
_offset$40025 = -616					; size = 4
_cpool_double$ = -612					; size = 4
_lhs$40253 = -608					; size = 4
_offset$39637 = -604					; size = 4
_rhs$39982 = -600					; size = 4
__ee$39598 = -596					; size = 4
$T41935 = -592						; size = 4
_initialScopeDepth$ = -588				; size = 4
_rhs$40234 = -584					; size = 4
__setjmpVal$39599 = -580				; size = 4
_rhs$39992 = -576					; size = 4
_t$39525 = -572						; size = 4
_rhs$39965 = -568					; size = 4
_p$39567 = -564						; size = 4
_lhs$39854 = -560					; size = 4
_i$39561 = -556						; size = 4
_obj$40302 = -552					; size = 4
_o$39562 = -548						; size = 4
_rhs$40244 = -544					; size = 4
_i$39553 = -540						; size = 4
_lhs$40223 = -536					; size = 4
_n$39554 = -532						; size = 4
_index$40001 = -528					; size = 4
_max_stack$ = -524					; size = 4
_rhs$39987 = -520					; size = 4
_local_count$ = -516					; size = 4
_lhs$39971 = -512					; size = 4
_pos$ = -508						; size = 4
_rhs$39955 = -504					; size = 4
_val$40534 = -500					; size = 4
_name$40271 = -496					; size = 16
_val$40529 = -480					; size = 4
_lhs$39738 = -476					; size = 4
_val$40525 = -472					; size = 4
$T41915 = -468						; size = 4
_val$40521 = -464					; size = 4
_obj$40300 = -460					; size = 4
_s$40507 = -456						; size = 4
_rhs$40254 = -452					; size = 4
_s$40503 = -448						; size = 4
_lhs$40243 = -444					; size = 4
_val$40483 = -440					; size = 4
_lhs$40233 = -436					; size = 4
_objAtom$40464 = -432					; size = 4
_rhs$40224 = -428					; size = 4
_objAtom$40462 = -424					; size = 4
_offset$40014 = -420					; size = 4
_argc$40418 = -416					; size = 4
_lhs$39991 = -412					; size = 4
_base$40413 = -408					; size = 4
_lhs$39986 = -404					; size = 4
_argc$40412 = -400					; size = 4
_lhs$39981 = -396					; size = 4
_argc$40406 = -392					; size = 4
_rhs$39972 = -388					; size = 4
_argc$40395 = -384					; size = 4
_lhs$39964 = -380					; size = 4
_atomv$40396 = -376					; size = 4
_lhs$39954 = -372					; size = 4
_lhs$39935 = -368					; size = 4
_lhs$39942 = -364					; size = 4
_rhs$39927 = -360					; size = 4
_rhs$39936 = -356					; size = 4
_rhs$39891 = -352					; size = 4
_lhs$39872 = -348					; size = 4
_method_id$40388 = -344					; size = 4
_lhs$39908 = -340					; size = 4
_global$40366 = -336					; size = 4
_lhs$39890 = -332					; size = 4
_slot_id$40353 = -328					; size = 4
_rhs$39873 = -324					; size = 4
_rhs$40352 = -320					; size = 4
_rhs$39855 = -316					; size = 4
_indexReg$40336 = -312					; size = 4
$T41955 = -308						; size = 4
_lhs$39926 = -304					; size = 4
_multiname$40411 = -300					; size = 16
_multiname$40417 = -284					; size = 16
_multiname$40405 = -268					; size = 16
_multiname$40316 = -252					; size = 16
_multiname$40312 = -236					; size = 16
_multiname$40341 = -220					; size = 16
_multiname$40297 = -204					; size = 16
_name$40423 = -188					; size = 16
_name$40459 = -172					; size = 16
_name$40305 = -156					; size = 16
_name$40451 = -140					; size = 16
_multiname$40284 = -124					; size = 16
_name$40443 = -108					; size = 16
_name$40435 = -92					; size = 16
_multiname$40275 = -76					; size = 16
_bval$40009 = -60					; size = 4
_objAtom$40337 = -56					; size = 4
_arguments_argc$ = -52					; size = 4
_atomv$40408 = -48					; size = 4
_cpool_string$ = -44					; size = 4
_bval$40020 = -40					; size = 4
_atomv$40448 = -36					; size = 4
_index$40338 = -32					; size = 4
_atomv$40440 = -28					; size = 4
_value$40285 = -24					; size = 4
_atomv$40428 = -20					; size = 4
_atomv$40420 = -16					; size = 4
_bval$39719 = -12					; size = 4
_savedCodeContext$ = -8					; size = 4
_res$40348 = -1						; size = 1
tv5291 = 0						; size = 4
_dxns$ = 4						; size = 4
_global$40359 = 8					; size = 4
_max_scope$ = 12					; size = 4
tv6921 = 16						; size = 8
tv6919 = 16						; size = 8
tv6917 = 16						; size = 8
tv7658 = 20						; size = 4
tv5219 = 20						; size = 4
_outer_depth$ = 24					; size = 4
tv3531 = 28						; size = 4
_dxnsAddrSave$ = 28					; size = 4
_withBase$ = 32						; size = 4
_info$ = 36						; size = 4
_scope$ = 40						; size = 4
_scopeDepth$ = 44					; size = 4
_result$40090 = 48					; size = 1
_result$40135 = 49					; size = 1
_result$40036 = 50					; size = 1
_result$40150 = 51					; size = 1
_result$40054 = 52					; size = 1
_result$40165 = 53					; size = 1
_result$40105 = 54					; size = 1
_interruptable$ = 55					; size = 1
_result$40072 = 59					; size = 1
_result$40195 = 60					; size = 1
_result$40210 = 61					; size = 1
_result$40180 = 62					; size = 1
_result$40120 = 63					; size = 1
_scopeBase$ = 64					; size = 4
_framep$ = 68						; size = 4
_pool$ = 72						; size = 4
_toplevel$ = 76						; size = 4
_dxnsAddr$ = 80						; size = 4
_expc$ = 84						; size = 4
_code_start$ = 88					; size = 4
_pc$ = 92						; size = 4
_sp$ = 96						; size = 4
tv7661 = 98						; size = 2
_core$ = 100						; size = 4
__$ArrayPad$ = 104					; size = 4
_env$ = 116						; size = 4
_argc$ = 120						; size = 4
_ap$ = 124						; size = 4
?interp@avmplus@@YAHPAVMethodEnv@1@HPAI@Z PROC		; avmplus::interp

; 139  :     {

	push	ebp
	lea	ebp, DWORD PTR [esp-108]
	sub	esp, 2116				; 00000844H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 140  : 		MethodInfo* info = (MethodInfo*)(AbstractFunction*) env->method;

	mov	edx, DWORD PTR _env$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx+4]

; 141  : 		AvmCore *core = info->core();

	mov	eax, DWORD PTR [esi+8]
	push	edi
	lea	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T41256[ebp], eax
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T41261[ebp], eax
	mov	DWORD PTR _core$[ebp], eax

; 142  : 
; 143  : 		if (core->minstack)

	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	mov	DWORD PTR _info$[ebp], esi
	mov	DWORD PTR tv5219[ebp], edi
	je	SHORT $LN448@interp

; 144  : 		{
; 145  : 			// Take the address of a local variable to get
; 146  : 			// stack pointer
; 147  : 			uintptr sp = (uintptr)&core;

	lea	ecx, DWORD PTR _core$[ebp]

; 148  : 			if (sp < core->minstack)

	cmp	ecx, eax
	mov	DWORD PTR _sp$39256[ebp], ecx
	jae	SHORT $LN448@interp

; 149  : 			{
; 150  : 				env->vtable->traits->core->stackOverflow(env);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T41265[ebp], eax
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	edx, DWORD PTR [eax+28]
	call	edx
$LN448@interp:

; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		#ifdef AVMPLUS_VERBOSE
; 155  : 		if (info->pool->verbose)
; 156  : 			core->console << "interp " << info << '\n';
; 157  : 		#endif
; 158  : 
; 159  : #ifdef AVMPLUS_WORD_CODE
; 160  : 		const uint32* pos = info->word_code.body_pos;

	mov	eax, DWORD PTR [esi+56]

; 161  : 		if (pos == NULL) {

	test	eax, eax
	mov	DWORD PTR _pos$[ebp], eax
	jne	$LN443@interp

; 162  : #  ifdef AVMPLUS_DIRECT_THREADED
; 163  : #    if defined GNUC_THREADING
; 164  : #      define III(idx, lbl) &&lbl,
; 165  : #      define XXX(idx) &&L_illegal_op,
; 166  : 			static void* opcode_labels[] = {
; 167  : #    elif defined MSVC_X86_ASM_THREADING || defined MSVC_X86_REWRITE_THREADING
; 168  : 	    static void* opcode_labels[300];  // FIXME: need better way of computing the size of that table
; 169  :         if (opcode_labels[0] == 0) {

	cmp	DWORD PTR ?opcode_labels@?L@??interp@avmplus@@YAHPAVMethodEnv@2@HPAI@Z@4PAPAXA, eax
	jne	$LN446@interp

; 170  : #      define XXX(idx) III(idx, L_illegal_op)
; 171  : #      ifdef MSVC_X86_ASM_THREADING
; 172  : #        define III(idx, lbl) __asm { \
; 173  : 	           __asm mov eax, offset opcode_labels \
; 174  : 	  	       __asm mov ebx, offset lbl \
; 175  : 		       __asm mov [eax+4*idx], ebx \
; 176  : 		     }
; 177  : #       else
; 178  : 		  extern bool LLLLABEL(int);
; 179  : #         define III(a,b) extern void LLLLABEL ## _ ## a ## _ ## b(); LLLLABEL ## _ ## a ## _ ## b();
; 180  : #       endif
; 181  : #    endif // threading discipline
; 182  : 			 XXX(0x00)


; 183  : 			 III(0x01, L_bkpt)


; 184  : 			 XXX(0x02) /* OP_nop */


; 185  : 			 III(0x03, L_throw)


; 186  : 			 III(0x04, L_getsuper)


; 187  : 			 III(0x05, L_setsuper)


; 188  : 			 III(0x06, L_dxns)


; 189  : 			 III(0x07, L_dxnslate)


; 190  : 			 III(0x08, L_kill)


; 191  : 			 XXX(0x09) /* OP_label */


; 192  : 			 XXX(0x0A)


; 193  : 			 XXX(0x0B)


; 194  : 			 III(0x0C, L_ifnlt)


; 195  : 			 III(0x0D, L_ifnle)


; 196  : 			 III(0x0E, L_ifngt)


; 197  : 			 III(0x0F, L_ifnge)


; 198  : 			 III(0x10, L_jump)


; 199  : 			 III(0x11, L_iftrue)


; 200  : 			 III(0x12, L_iffalse)


; 201  : 			 III(0x13, L_ifeq)


; 202  : 			 III(0x14, L_ifne)


; 203  : 			 III(0x15, L_iflt)


; 204  : 			 III(0x16, L_ifle)


; 205  : 			 III(0x17, L_ifgt)


; 206  : 			 III(0x18, L_ifge)


; 207  : 			 III(0x19, L_ifstricteq)


; 208  : 			 III(0x1A, L_ifstrictne)


; 209  : 			 III(0x1B, L_lookupswitch)


; 210  : 			 III(0x1C, L_pushwith)


; 211  : 			 III(0x1D, L_popscope)


; 212  : 			 III(0x1E, L_nextname)


; 213  : 			 III(0x1F, L_hasnext)


; 214  : 			 III(0x20, L_pushnull)


; 215  : 			 III(0x21, L_pushundefined)


; 216  : 			 XXX(0x22)


; 217  : 			 III(0x23, L_nextvalue)


; 218  : 			 XXX(0x24) /* OP_pushbyte */


; 219  : 			 XXX(0x25) /* OP_pushshort */


; 220  : 			 III(0x26, L_pushtrue)


; 221  : 			 III(0x27, L_pushfalse)


; 222  : 			 III(0x28, L_pushnan)


; 223  : 			 III(0x29, L_pop)


; 224  : 			 III(0x2A, L_dup)


; 225  : 			 III(0x2B, L_swap)


; 226  : 			 III(0x2C, L_pushstring)


; 227  : 			 XXX(0x2D) /* OP_pushint */


; 228  : 			 XXX(0x2E) /* OP_pushuint */


; 229  : 			 III(0x2F, L_pushdouble)


; 230  : 			 III(0x30, L_pushscope)


; 231  : 			 III(0x31, L_pushnamespace)


; 232  : 			 III(0x32, L_hasnext2)


; 233  : 			 XXX(0x33)


; 234  : 			 XXX(0x34)


; 235  : 			 XXX(0x35)


; 236  : 			 XXX(0x36)


; 237  : 			 XXX(0x37)


; 238  : 			 XXX(0x38)


; 239  : 			 XXX(0x39)


; 240  : 			 XXX(0x3A)


; 241  : 			 XXX(0x3B)


; 242  : 			 XXX(0x3C)


; 243  : 			 XXX(0x3D)


; 244  : 			 XXX(0x3E)


; 245  : 			 XXX(0x3F)


; 246  : 			 III(0x40, L_newfunction)


; 247  : 			 III(0x41, L_call)


; 248  : 			 III(0x42, L_construct)


; 249  : 			 III(0x43, L_callmethod)


; 250  : 			 III(0x44, L_callstatic)


; 251  : 			 III(0x45, L_callsuper)


; 252  : 			 III(0x46, L_callproperty)


; 253  : 			 III(0x47, L_returnvoid)


; 254  : 			 III(0x48, L_returnvalue)


; 255  : 			 III(0x49, L_constructsuper)


; 256  : 			 III(0x4A, L_constructprop)


; 257  : 			 XXX(0x4B) /* OP_callsuperid */


; 258  : 			 III(0x4C, L_callproplex)


; 259  : 			 XXX(0x4D) /* OP_callinterface */


; 260  : 			 III(0x4E, L_callsupervoid)


; 261  : 			 III(0x4F, L_callpropvoid)


; 262  : 			 XXX(0x50)


; 263  : 			 XXX(0x51)


; 264  : 			 XXX(0x52)


; 265  : 			 III(0x53, L_applytype)


; 266  : 			 XXX(0x54)


; 267  : 			 III(0x55, L_newobject)


; 268  : 			 III(0x56, L_newarray)


; 269  : 			 III(0x57, L_newactivation)


; 270  : 			 III(0x58, L_newclass)


; 271  : 			 III(0x59, L_getdescendants)


; 272  : 			 III(0x5A, L_newcatch)


; 273  : 			 XXX(0x5B)


; 274  : 			 XXX(0x5C)


; 275  : 			 III(0x5D, L_findpropstrict)


; 276  : 			 III(0x5E, L_findproperty)


; 277  : 			 III(0x5F, L_finddef)


; 278  : 			 III(0x60, L_getlex)


; 279  : 			 III(0x61, L_setproperty)


; 280  : 			 III(0x62, L_getlocal)


; 281  : 			 III(0x63, L_setlocal)


; 282  : 			 III(0x64, L_getglobalscope)


; 283  : 			 III(0x65, L_getscopeobject)


; 284  : 			 III(0x66, L_getproperty)


; 285  : 			 III(0x67, L_getouterscope)


; 286  : 			 III(0x68, L_initproperty)


; 287  : 			 XXX(0x69)


; 288  : 			 III(0x6A, L_deleteproperty)


; 289  : 			 XXX(0x6B)


; 290  : 			 III(0x6C, L_getslot)


; 291  : 			 III(0x6D, L_setslot)


; 292  : 			 III(0x6E, L_getglobalslot)


; 293  : 			 III(0x6F, L_setglobalslot)


; 294  : 			 III(0x70, L_convert_s)


; 295  : 			 III(0x71, L_esc_xelem)


; 296  : 			 III(0x72, L_esc_xattr)


; 297  : 			 III(0x73, L_convert_i)


; 298  : 			 III(0x74, L_convert_u)


; 299  : 			 III(0x75, L_convert_d)


; 300  : 			 III(0x76, L_convert_b)


; 301  : 			 III(0x77, L_convert_o)


; 302  : 			 III(0x78, L_checkfilter)


; 303  : 			 XXX(0x79)


; 304  : 			 XXX(0x7A)


; 305  : 			 XXX(0x7B)


; 306  : 			 XXX(0x7C)


; 307  : 			 XXX(0x7D)


; 308  : 			 XXX(0x7E)


; 309  : 			 XXX(0x7F)


; 310  : 			 III(0x80, L_coerce)


; 311  : 			 III(0x81, L_coerce_b)


; 312  : 			 III(0x82, L_coerce_a)


; 313  : 			 III(0x83, L_coerce_i)


; 314  : 			 III(0x84, L_coerce_d)


; 315  : 			 III(0x85, L_coerce_s)


; 316  : 			 III(0x86, L_astype)


; 317  : 			 III(0x87, L_astypelate)


; 318  : 			 III(0x88, L_coerce_u)


; 319  : 			 III(0x89, L_coerce_o)


; 320  : 			 XXX(0x8A)


; 321  : 			 XXX(0x8B)


; 322  : 			 XXX(0x8C)


; 323  : 			 XXX(0x8D)


; 324  : 			 XXX(0x8E)


; 325  : 			 XXX(0x8F)


; 326  : 			 III(0x90, L_negate)


; 327  : 			 III(0x91, L_increment)


; 328  : 			 III(0x92, L_inclocal)


; 329  : 			 III(0x93, L_decrement)


; 330  : 			 III(0x94, L_declocal)


; 331  : 			 III(0x95, L_typeof)


; 332  : 			 III(0x96, L_not)


; 333  : 			 III(0x97, L_bitnot)


; 334  : 			 XXX(0x98)


; 335  : 			 XXX(0x99)


; 336  : 			 XXX(0x9A) /* OP_concat */


; 337  : 			 XXX(0x9B) /* OP_add_d */


; 338  : 			 XXX(0x9C)


; 339  : 			 XXX(0x9D)


; 340  : 			 XXX(0x9E)


; 341  : 			 XXX(0x9F)


; 342  : 			 III(0xA0, L_add)


; 343  : 			 III(0xA1, L_subtract)


; 344  : 			 III(0xA2, L_multiply)


; 345  : 			 III(0xA3, L_divide)


; 346  : 			 III(0xA4, L_modulo)


; 347  : 			 III(0xA5, L_lshift)


; 348  : 			 III(0xA6, L_rshift)


; 349  : 			 III(0xA7, L_urshift)


; 350  : 			 III(0xA8, L_bitand)


; 351  : 			 III(0xA9, L_bitor)


; 352  : 			 III(0xAA, L_bitxor)


; 353  : 			 III(0xAB, L_equals)


; 354  : 			 III(0xAC, L_strictequals)


; 355  : 			 III(0xAD, L_lessthan)


; 356  : 			 III(0xAE, L_lessequals)


; 357  : 			 III(0xAF, L_greaterthan)


; 358  : 			 III(0xB0, L_greaterequals)


; 359  : 			 III(0xB1, L_instanceof)


; 360  : 			 III(0xB2, L_istype)


; 361  : 			 III(0xB3, L_istypelate)


; 362  : 			 III(0xB4, L_in)


; 363  : 			 XXX(0xB5)


; 364  : 			 XXX(0xB6)


; 365  : 			 XXX(0xB7)


; 366  : 			 XXX(0xB8)


; 367  : 			 XXX(0xB9)


; 368  : 			 XXX(0xBA)


; 369  : 			 XXX(0xBB)


; 370  : 			 XXX(0xBC)


; 371  : 			 XXX(0xBD)


; 372  : 			 XXX(0xBE)


; 373  : 			 XXX(0xBF)


; 374  : 			 III(0xC0, L_increment_i)


; 375  : 			 III(0xC1, L_decrement_i)


; 376  : 			 III(0xC2, L_inclocal_i)


; 377  : 			 III(0xC3, L_declocal_i)


; 378  : 			 III(0xC4, L_negate_i)


; 379  : 			 III(0xC5, L_add_i)


; 380  : 			 III(0xC6, L_subtract_i)


; 381  : 			 III(0xC7, L_multiply_i)


; 382  : 			 XXX(0xC8)


; 383  : 			 XXX(0xC9)


; 384  : 			 XXX(0xCA)


; 385  : 			 XXX(0xCB)


; 386  : 			 XXX(0xCC)


; 387  : 			 XXX(0xCD)


; 388  : 			 XXX(0xCE)


; 389  : 			 XXX(0xCF)


; 390  : 			 III(0xD0, L_getlocal0)


; 391  : 			 III(0xD1, L_getlocal1)


; 392  : 			 III(0xD2, L_getlocal2)


; 393  : 			 III(0xD3, L_getlocal3)


; 394  : 			 III(0xD4, L_setlocal0)


; 395  : 			 III(0xD5, L_setlocal1)


; 396  : 			 III(0xD6, L_setlocal2)


; 397  : 			 III(0xD7, L_setlocal3)


; 398  : 			 XXX(0xD8)


; 399  : 			 XXX(0xD9)


; 400  : 			 XXX(0xDA)


; 401  : 			 XXX(0xDB)


; 402  : 			 XXX(0xDC)


; 403  : 			 XXX(0xDD)


; 404  : 			 XXX(0xDE)


; 405  : 			 XXX(0xDF)


; 406  : 			 XXX(0xE0)


; 407  : 			 XXX(0xE1)


; 408  : 			 XXX(0xE2)


; 409  : 			 XXX(0xE3)


; 410  : 			 XXX(0xE4)


; 411  : 			 XXX(0xE5)


; 412  : 			 XXX(0xE6)


; 413  : 			 XXX(0xE7)


; 414  : 			 XXX(0xE8)


; 415  : 			 XXX(0xE9)


; 416  : 			 XXX(0xEA)


; 417  : 			 XXX(0xEB)


; 418  : 			 XXX(0xEC)


; 419  : 			 XXX(0xED)


; 420  : 			 XXX(0xEE) /* OP_abs_jump */


; 421  : 			 XXX(0xEF) /* OP_debug */


; 422  : 			 III(0xF0, L_debugline)


; 423  : 			 III(0xF1, L_debugfile)


; 424  : 			 III(0xF2, L_bkptline)


; 425  : 			 XXX(0xF3)  /* OP_timestamp */


; 426  : 			 XXX(0xF4)


; 427  : 			 XXX(0xF5)


; 428  : 			 XXX(0xF6)


; 429  : 			 XXX(0xF7)


; 430  : 			 XXX(0xF8)


; 431  : 			 XXX(0xF9)


; 432  : 			 XXX(0xFA)


; 433  : 			 XXX(0xFB)


; 434  : 			 XXX(0xFC)


; 435  : 			 XXX(0xFD)


; 436  : 			 XXX(0xFE)


; 437  : 			 XXX(0xFF)  /* OP_ext */


; 438  : 			 XXX(0x100)


; 439  : 			 III(0x101, L_ext_pushbits)


; 440  : 			 III(0x102, L_ext_push_doublebits)

$LN446@interp:

; 441  : #    if defined GNUC_THREADING
; 442  : 			};
; 443  : 			AvmAssert(opcode_labels[0x18] == &&L_ifge);
; 444  : 			AvmAssert(opcode_labels[0x97] == &&L_bitnot);
; 445  : 			AvmAssert(opcode_labels[0xF0] == &&L_debugline);
; 446  : 			AvmAssert(opcode_labels[257] == &&L_ext_pushbits);
; 447  : #    elif defined MSVC_X86_ASM_THREADING || defined MSVC_X86_REWRITE_THREADING
; 448  : 			} // conditional run-time initialization of jump table
; 449  : #    endif // threading discipline
; 450  : 			Translator *t = new Translator(opcode_labels);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	mov	DWORD PTR $T41197[ebp], eax
	je	SHORT $LN452@interp
	push	OFFSET ?opcode_labels@?L@??interp@avmplus@@YAHPAVMethodEnv@2@HPAI@Z@4PAPAXA
	mov	ecx, eax
	call	??0Translator@avmplus@@QAE@PAPAX@Z	; avmplus::Translator::Translator
	mov	ebx, eax
	jmp	SHORT $LN1469@interp
$LN452@interp:
	xor	ebx, ebx
$LN1469@interp:

; 451  : #  else  // !AVMPLUS_DIRECT_THREADED
; 452  : 			Translator *t = new Translator();
; 453  : #  endif // AVMPLUS_DIRECT_THREADED
; 454  : 			
; 455  : 			t->translate(env);

	mov	eax, DWORD PTR _env$[ebp]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _t$39525[ebp], ebx
	call	?translate@Translator@avmplus@@QAEXPAVMethodEnv@2@@Z ; avmplus::Translator::translate

; 456  : 			delete t;

	test	ebx, ebx
	mov	DWORD PTR $T41201[ebp], ebx
	mov	DWORD PTR $T41200[ebp], ebx
	je	SHORT $LN454@interp
	mov	ecx, ebx
	call	??1Translator@avmplus@@QAE@XZ		; avmplus::Translator::~Translator
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN454@interp:

; 457  : 			pos = info->word_code.body_pos;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR _pos$[ebp], eax
$LN443@interp:

; 458  : 			AvmAssert(pos != NULL);
; 459  : 		} // pos == 0
; 460  : 		const uint32* volatile code_start = pos;
; 461  : 		int max_stack = info->word_code.max_stack;

	mov	ecx, DWORD PTR [esi+64]

; 462  : 		int local_count = info->word_code.local_count;

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR _code_start$[ebp], eax

; 463  : 		int init_scope_depth = info->word_code.init_scope_depth;

	mov	eax, DWORD PTR [esi+72]

; 464  : 		int max_scope_depth = info->word_code.max_scope_depth;

	mov	esi, DWORD PTR [esi+76]
	mov	DWORD PTR _init_scope_depth$[ebp], eax
	mov	DWORD PTR _max_scope_depth$[ebp], esi

; 465  : #else // !AVMPLUS_WORD_CODE
; 466  : 		const byte* pos = info->body_pos;
; 467  : 		int max_stack = AvmCore::readU30(pos);
; 468  : 		int local_count = AvmCore::readU30(pos);
; 469  : 		int init_scope_depth = AvmCore::readU30(pos);
; 470  : 		int max_scope_depth = AvmCore::readU30(pos);
; 471  : 		AvmCore::readU30(pos); // code_length
; 472  : 		const byte * volatile code_start = pos;
; 473  : #endif // AVMPLUS_WORD_CODE
; 474  : 		int volatile max_scope = MethodInfo::maxScopeDepth(info, max_scope_depth - init_scope_depth);

	sub	esi, eax
	mov	DWORD PTR _max_stack$[ebp], ecx
	mov	DWORD PTR _local_count$[ebp], edx
	mov	DWORD PTR _max_scope$[ebp], esi

; 475  : 
; 476  : 		// these should have been checked in AbcParser
; 477  : 		AvmAssert(local_count+max_scope+max_stack > 0);
; 478  : 		Atom* framep = (Atom*)alloca(sizeof(Atom)*(local_count + max_scope + max_stack));

	mov	eax, DWORD PTR _max_scope$[ebp]
	mov	esi, DWORD PTR _local_count$[ebp]
	add	eax, esi
	add	eax, DWORD PTR _max_stack$[ebp]
	add	eax, eax
	add	eax, eax
	call	__alloca_probe_16

; 479  : 		Atom* scopeBase = framep + local_count;
; 480  : 		Atom* withBase = NULL;
; 481  : 
; 482  : #ifdef DEBUGGER
; 483  : 		env->invocationCount++;
; 484  : 		CallStackNode callStackNode(env, info, framep, 0, argc, ap, 0 /* later changed to 'pc' */);
; 485  : 		// don't allow entry into the debugger until we have setup the frame
; 486  : #endif
; 487  : 
; 488  : 		CodeContextAtom savedCodeContext = core->codeContextAtom;

	mov	ecx, DWORD PTR _core$[ebp]
	mov	edx, DWORD PTR [ecx+844]
	mov	ebx, esp
	lea	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR _scopeBase$[ebp], eax

; 489  : 		if (info->pool->domain->base != NULL) {

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR $T41276[ebp], eax
	mov	eax, DWORD PTR [eax+152]
	cmp	DWORD PTR [eax+8], 0
	mov	DWORD PTR _framep$[ebp], ebx
	mov	DWORD PTR _withBase$[ebp], 0
	mov	DWORD PTR _savedCodeContext$[ebp], edx
	mov	DWORD PTR $T41280[ebp], eax
	je	SHORT $LN439@interp

; 490  : 			core->codeContextAtom = (CodeContextAtom)env | CONTEXT_ENV;

	mov	eax, DWORD PTR _env$[ebp]
	mov	DWORD PTR [ecx+844], eax
$LN439@interp:

; 491  : 		}
; 492  : 
; 493  : 		Atom* atomv = (Atom*)ap;

	mov	eax, DWORD PTR _ap$[ebp]

; 494  : 		info->boxArgs(argc, ap, atomv);

	mov	edi, DWORD PTR _argc$[ebp]
	mov	esi, DWORD PTR _info$[ebp]
	push	eax
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _atomv$[ebp], eax
	call	?boxArgs@AbstractFunction@avmplus@@QAEXHPAIPAH@Z ; avmplus::AbstractFunction::boxArgs

; 495  : 
; 496  : 		// 1. copy instance and args to local frame
; 497  : 		for (int i=0, n = argc < info->param_count ? argc : info->param_count; i <= n; i++)

	mov	ecx, DWORD PTR [esi+12]
	cmp	edi, ecx
	mov	DWORD PTR _i$39553[ebp], 0
	jge	SHORT $LN456@interp
	mov	ecx, edi
$LN456@interp:
	test	ecx, ecx
	mov	DWORD PTR _n$39554[ebp], ecx
	jl	SHORT $LN436@interp
	mov	edx, DWORD PTR _ap$[ebp]
	sub	edx, ebx
	add	ecx, 1
	mov	eax, ebx
	mov	DWORD PTR _i$39553[ebp], ecx
	npad	1
$LL438@interp:

; 498  : 		{
; 499  : 			framep[i] = atomv[i];

	mov	edi, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], edi
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL438@interp

; 495  : 
; 496  : 		// 1. copy instance and args to local frame
; 497  : 		for (int i=0, n = argc < info->param_count ? argc : info->param_count; i <= n; i++)

	mov	edi, DWORD PTR _argc$[ebp]
$LN436@interp:

; 500  : 		}
; 501  : 
; 502  : 		// Store original value of argc for createRest and createArguments.
; 503  : 		// argc may be changed by the optional parameter check below.
; 504  : 		int arguments_argc = argc;
; 505  : 
; 506  : 		// set optional param values.  these not aliased to arguments[] since arguments[]
; 507  : 		// only present with traditional prototype functions (no optional args)
; 508  : 		if (info->flags & AbstractFunction::HAS_OPTIONAL)

	test	BYTE PTR [esi+24], 8
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _arguments_argc$[ebp], edi
	mov	DWORD PTR tv5291[ebp], eax
	je	SHORT $LN434@interp

; 509  : 		{
; 510  : 			if (argc < info->param_count)

	cmp	edi, DWORD PTR [esi+12]
	jge	SHORT $LN434@interp

; 511  : 			{
; 512  : 				// initialize default values
; 513  : 				for (int i=argc+1, o=argc + info->optional_count - info->param_count, n=info->param_count; i <= n; i++, o++)

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, edx
	lea	eax, DWORD PTR [edi+1]
	add	ecx, edi
	mov	edi, edx
	cmp	eax, edi
	mov	DWORD PTR _i$39561[ebp], eax
	mov	DWORD PTR _o$39562[ebp], ecx
	mov	DWORD PTR _n$39563[ebp], edi
	jg	SHORT $LN431@interp
	npad	7
$LL433@interp:

; 514  : 				{
; 515  : 					framep[i] = info->getDefaultValue(o);

	mov	edx, DWORD PTR [esi+48]
	mov	DWORD PTR $T41285[ebp], edx
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ebx+eax*4], edx
	add	eax, 1
	add	ecx, 1
	cmp	eax, edi
	mov	DWORD PTR $T41290[ebp], edx
	jle	SHORT $LL433@interp
	mov	DWORD PTR _o$39562[ebp], ecx
	mov	DWORD PTR _i$39561[ebp], eax
$LN431@interp:

; 516  : 				}
; 517  : 				argc = info->param_count;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _argc$[ebp], ecx
$LN434@interp:

; 518  : 			}
; 519  : 		}
; 520  : 
; 521  : 		// 4. set remaining locals to undefined.  Don't have to init scope or stack because
; 522  : 		// our conservative GC scan knows how to ignore garbage.
; 523  : 		for (Atom *p = framep + 1 + info->param_count; p < scopeBase; p++)

	mov	edx, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [ebx+edx*4+4]
	cmp	edx, DWORD PTR _scopeBase$[ebp]
	mov	DWORD PTR _p$39567[ebp], edx
	jae	SHORT $LN430@interp
	mov	eax, DWORD PTR _scopeBase$[ebp]
	sub	eax, edx
	sub	eax, 1
	shr	eax, 2
	add	eax, 1
	mov	ecx, eax
	mov	DWORD PTR tv3531[ebp], eax
	mov	eax, 4
	mov	edi, edx
	rep stosd
	mov	eax, DWORD PTR tv3531[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _p$39567[ebp], ecx
$LN430@interp:

; 524  : 		{
; 525  : 			*p = undefinedAtom;
; 526  : 		}
; 527  : 
; 528  : 		Toplevel *const toplevel = env->toplevel();

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+8]

; 529  : 
; 530  : 		// 2. capture arguments or rest array.
; 531  : 		if (info->flags & AbstractFunction::NEED_REST)

	mov	ecx, DWORD PTR tv5291[ebp]
	mov	DWORD PTR $T41295[ebp], eax
	mov	DWORD PTR _toplevel$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	test	al, 4
	je	SHORT $LN427@interp

; 532  : 		{
; 533  : 			framep[info->param_count+1] = env->createRest(atomv,arguments_argc)->atom();

	mov	edx, DWORD PTR _arguments_argc$[ebp]
	mov	eax, DWORD PTR _ap$[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	push	edx
	push	eax
	call	?createRest@MethodEnv@avmplus@@QAEPAVArrayObject@2@PAHH@Z ; avmplus::MethodEnv::createRest
	mov	DWORD PTR $T41303[ebp], eax
	jmp	SHORT $LN1470@interp
$LN427@interp:

; 534  : 		}
; 535  : 		else if (info->flags & AbstractFunction::NEED_ARGUMENTS)

	test	al, 1
	je	SHORT $LN425@interp

; 536  : 		{
; 537  : 			// create arguments using atomv[1..argc].
; 538  : 			// Even tho E3 says create an Object, E4 says create an Array so thats what we will do.
; 539  : 			framep[info->param_count+1] = env->createArguments(atomv, arguments_argc)->atom();

	mov	edx, DWORD PTR _arguments_argc$[ebp]
	mov	eax, DWORD PTR _ap$[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	push	edx
	push	eax
	call	?createArguments@MethodEnv@avmplus@@QAEPAVArrayObject@2@PAHH@Z ; avmplus::MethodEnv::createArguments
	mov	DWORD PTR $T41307[ebp], eax
$LN1470@interp:
	mov	ecx, DWORD PTR [esi+12]
	or	eax, 1
	mov	DWORD PTR [ebx+ecx*4+4], eax
$LN425@interp:

; 540  : 		}
; 541  : 		
; 542  : 		// 3. create the activation object, if necessary
; 543  : 
; 544  : 		// init the scope chain by copying it from the captured scope
; 545  : 		ScopeChain* scope = env->vtable->scope;

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+20]

; 546  : 		Namespace *dxns = scope->defaultXmlNamespace;

	mov	edx, DWORD PTR [eax+4]

; 547  : 		Namespace **dxnsAddr;
; 548  : 		Namespace *const*dxnsAddrSave = NULL;
; 549  : 
; 550  : 		if(info->setsDxns()) {

	mov	esi, DWORD PTR tv5291[ebp]
	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dxns$[ebp], edx
	mov	DWORD PTR $T41314[ebp], edx
	xor	edx, edx
	test	BYTE PTR [esi], 64			; 00000040H
	mov	DWORD PTR _scope$[ebp], eax
	mov	DWORD PTR _dxnsAddrSave$[ebp], edx
	je	SHORT $LN424@interp

; 551  : 			dxnsAddrSave = core->dxnsAddr;

	mov	ecx, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR [ecx+216]
	mov	DWORD PTR _dxnsAddrSave$[ebp], ecx

; 552  : 			dxnsAddr = &dxns;

	lea	ecx, DWORD PTR _dxns$[ebp]
$LN424@interp:

; 553  : 		} else {
; 554  : 			dxnsAddr = scope->getDefaultNamespaceAddr();
; 555  : 		}
; 556  : 
; 557  : 		int outer_depth = scope->getSize();

	cmp	DWORD PTR [eax], edx
	mov	DWORD PTR _dxnsAddr$[ebp], ecx
	je	SHORT $LN537@interp
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _outer_depth$[ebp], eax
	jmp	SHORT $LN536@interp
$LN537@interp:
	mov	DWORD PTR _outer_depth$[ebp], edx
$LN536@interp:

; 558  : 		int scopeDepth = 0;
; 559  : 	
; 560  : 		// make sure scope chain depth is right before entering.
; 561  : 		volatile int initialScopeDepth = scopeDepth;
; 562  : 
; 563  : 		PoolObject *pool = info->pool;

	mov	ecx, DWORD PTR tv5219[ebp]
	mov	eax, DWORD PTR [ecx]

; 564  : 		const List<Stringp, LIST_RCObjects>& cpool_string = pool->cpool_string;

	lea	edx, DWORD PTR [eax+56]

; 565  : #ifndef AVMPLUS_WORD_CODE
; 566  :         const List<int,LIST_NonGCObjects>& cpool_int = pool->cpool_int;
; 567  :         const List<uint32,LIST_NonGCObjects>& cpool_uint = pool->cpool_uint;
; 568  : #endif // !AVMPLUS_WORD_CODE
; 569  :         const List<double*, LIST_GCObjects>& cpool_double = pool->cpool_double;

	lea	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pool$[ebp], eax
	xor	ebx, ebx

; 570  : 		const List<Namespace*, LIST_RCObjects>& cpool_ns = pool->cpool_ns;

	add	eax, 72					; 00000048H
	mov	DWORD PTR _cpool_ns$[ebp], eax
	mov	DWORD PTR _scopeDepth$[ebp], ebx
	mov	DWORD PTR _initialScopeDepth$[ebp], ebx
	mov	DWORD PTR _cpool_string$[ebp], edx

; 571  : 
; 572  : 		Atom *sp = scopeBase + max_scope - 1;

	mov	edx, DWORD PTR _max_scope$[ebp]
	mov	eax, DWORD PTR _scopeBase$[ebp]

; 573  : 
; 574  : 		#ifdef DEBUGGER
; 575  : 		Debugger* debugger = core->debugger;
; 576  : 		if (core->callStack)
; 577  : 			core->callStack->framep = framep;
; 578  : 
; 579  : 		// notify the debugger that we are entering a new frame.
; 580  : 		env->debugEnter(argc, ap, NULL, local_count, NULL, framep, 0);  // call it but make sure that callStackNode is not re-init'd
; 581  : 		#endif
; 582  : 
; 583  : #ifdef AVMPLUS_WORD_CODE
; 584  : 		const uint32* pc = code_start;

	mov	edi, DWORD PTR _code_start$[ebp]
	mov	DWORD PTR _cpool_double$[ebp], ecx
	lea	ecx, DWORD PTR [eax+edx*4-4]

; 585  : #else
; 586  : 		const byte* pc = code_start;
; 587  : #endif
; 588  : 		sintptr volatile expc=0;
; 589  : 
; 590  : 		#ifdef DEBUGGER
; 591  : 		callStackNode.eip = &expc;
; 592  : 		callStackNode.scopeDepth = &scopeDepth;
; 593  : 		#endif
; 594  : 
; 595  : 		// Mask that can be XOR'd to flip a boolean atom
; 596  : 		const int booleanNotMask  = trueAtom^falseAtom;
; 597  : 
; 598  : 		// whether this sequence is interruptable or not.
; 599  : 		bool interruptable = (info->flags & AbstractFunction::NON_INTERRUPTABLE) ? false : true;

	mov	edx, esi
	mov	eax, DWORD PTR [edx]
	shr	eax, 17					; 00000011H
	mov	DWORD PTR _sp$[ebp], ecx

; 600  : 
; 601  : 		core->branchCheck(env, interruptable, -1);

	mov	ecx, DWORD PTR _core$[ebp]
	not	al
	and	al, 1
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _expc$[ebp], ebx
	mov	DWORD PTR _booleanNotMask$[ebp], 8
	mov	BYTE PTR _interruptable$[ebp], al
	mov	DWORD PTR $T41334[ebp], ecx
	je	SHORT $LN1409@interp
	cmp	DWORD PTR [ecx+220], ebx
	je	SHORT $LN1409@interp
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	call	edx
	mov	ecx, DWORD PTR _core$[ebp]
$LN1409@interp:
	mov	esi, DWORD PTR _sp$[ebp]
	npad	9
$MainLoop$39596:

; 602  : 
; 603  : 		// in case a callee modified core->dxnsAddr, restore it
; 604  : 		#define restore_dxns() core->dxnsAddr = dxnsAddr
; 605  : 
; 606  : 		// when we're leaving this call frame
; 607  : 		#define restore_caller_dxns() if(info->setsDxns()) core->dxnsAddr = dxnsAddrSave
; 608  : 
; 609  : 		// NEXT dispatches the next instruction.
; 610  : 		//
; 611  : 		// U30ARG picks up a variable-length unsigned integer argument from the instruction
; 612  : 		// stream and advances the PC.
; 613  : 		//
; 614  : 		// U8ARG picks up a fixed-length unsigned byte argument from the instruction stream
; 615  : 		// and advances the PC.
; 616  : 		//
; 617  : 		// S24ARG picks up a fixed-length signed integer argument from the instruction stream
; 618  : 		// and advances the PC.
; 619  : 		//
; 620  : 		// SAVE_EXPC and variants saves the address of the current opcode in the local 'expc'.
; 621  : 		// Used in the case of exceptions.
; 622  : 
; 623  : #ifdef AVMPLUS_WORD_CODE
; 624  : 
; 625  : #  if defined AVMPLUS_DIRECT_THREADED
; 626  : #    if defined GNUC_THREADING
; 627  : #      define INSTR(op)       L_##op:
; 628  : #      define NEXT            goto *(*pc++)
; 629  : #    elif defined MSVC_X86_REWRITE_THREADING
; 630  : #      define INSTR(op)       case OP_##op: L_ ## op: 
; 631  : #      define NEXT            continue
; 632  : #    elif defined MSVC_X86_ASM_THREADING
; 633  : #      define NEXT __asm { \
; 634  : 				__asm mov ebx, pc \
; 635  : 				__asm mov eax, [ebx] \
; 636  : 				__asm add ebx, 4 \
; 637  : 				__asm mov pc, ebx \
; 638  : 				__asm jmp eax \
; 639  : 		   }
; 640  : #    endif // threading discipline
; 641  : #  else // AVMPLUS_DIRECT_THREADED
; 642  : #    define INSTR(op)       case OP_##op:
; 643  : #    define NEXT            continue
; 644  : #  endif
; 645  : 		
; 646  : #  define U30ARG          (*pc++)
; 647  : #  define U8ARG           (*pc++)
; 648  : #  define S24ARG          (int32)(*pc++)
; 649  : #  define SAVE_EXPC       expc = pc-1-code_start
; 650  : #  define SAVE_EXPC_S24   expc = pc-2-code_start
; 651  : 
; 652  : #else // !AVMPLUS_WORD_CODE
; 653  : 
; 654  : #  if defined AVMPLUS_VERBOSE
; 655  : #    define INSTR(op) case OP_##op: \
; 656  :                         if (pool->verbose) {\
; 657  : 							showState(info, code_start, pc-1,  framep, sp, scopeDepth, scopeBase, max_scope); \
; 658  : 						}
; 659  : #  else
; 660  : #    define INSTR(op) case OP_##op:
; 661  : #  endif
; 662  : 
; 663  : #  define NEXT            continue
; 664  : #  define U30ARG          (readU30(pc))
; 665  : #  define U8ARG           (*pc++)
; 666  : #  define S24ARG          (pc+=3, readS24(pc-3))
; 667  : #  define SAVE_EXPC	      expc = pc-1-code_start
; 668  : #  define SAVE_EXPC_S24   expc = pc-4-code_start
; 669  : 
; 670  : #endif // AVMPLUS_WORD_CODE
; 671  : 		
; 672  : 	MainLoop:
; 673  : #ifdef AVMPLUS_WORD_CODE
; 674  : 		TRY_UNLESS(core, !info->word_code.exceptions, kCatchAction_SearchForActionScriptExceptionHandler) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR __ef$39597[ebp], ebx
	cmp	DWORD PTR [eax+80], ebx
	mov	DWORD PTR __setjmpVal$39599[ebp], ebx
	je	$LN421@interp
	push	ecx
	lea	ecx, DWORD PTR __ef$39597[ebp]
	call	?beginTry@ExceptionFrame@avmplus@@QAEXPAVAvmCore@2@@Z ; avmplus::ExceptionFrame::beginTry
	lea	ecx, DWORD PTR __ef$39597[ebp+8]
	push	ebx
	push	ecx
	call	__setjmp3
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, DWORD PTR [ecx+852]
	add	esp, 8
	cmp	eax, ebx
	mov	DWORD PTR __setjmpVal$39599[ebp], eax
	mov	DWORD PTR __ee$39598[ebp], esi
	je	$LN1411@interp

; 2489 : 			}
; 2490 : 
; 2491 : #  ifndef AVMPLUS_DIRECT_THREADED
; 2492 : 			} // switch
; 2493 : 			} // INSTR(ext)
; 2494 : #  endif
; 2495 : 
; 2496 : #endif
; 2497 : #if defined SWITCH_DISPATCH
; 2498 : 			} // switch
; 2499 : 			// illegal instruction or accidental break
; 2500 : 			goto L_illegal_op;
; 2501 : 		} // for
; 2502 : #else
; 2503 : 			goto L_illegal_op;
; 2504 : #endif
; 2505 : 
; 2506 : 		}  // TRY
; 2507 : 
; 2508 : 		CATCH (Exception *exception)

	lea	ecx, DWORD PTR __ef$39597[ebp]
	call	?beginCatch@ExceptionFrame@avmplus@@QAEXXZ ; avmplus::ExceptionFrame::beginCatch

; 2509 : 		{
; 2510 : 			restore_caller_dxns();

	mov	edx, DWORD PTR _info$[ebp]
	test	BYTE PTR [edx+24], 64			; 00000040H
	mov	DWORD PTR _exception$40572[ebp], esi
	je	SHORT $LN4@interp
	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddrSave$[ebp]
	mov	DWORD PTR [eax+216], ecx
$LN4@interp:

; 2511 : 			// find handler; rethrow if no handler.
; 2512 : 			ExceptionHandler *handler = core->findExceptionHandler(info, expc, exception);

	mov	edx, DWORD PTR _expc$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	push	edx
	push	eax
	call	?findExceptionHandler@AvmCore@avmplus@@QAEPAVExceptionHandler@2@PAVMethodInfo@2@HPAVException@2@@Z ; avmplus::AvmCore::findExceptionHandler

; 2513 : 			restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [ecx+216], edx

; 2514 : 			// handler found in current method
; 2515 : 			pc = code_start + handler->target;

	mov	ecx, DWORD PTR _code_start$[ebp]

; 2516 : 			scopeDepth = initialScopeDepth; // ISSUE with() { try {} }

	mov	edx, DWORD PTR _initialScopeDepth$[ebp]
	mov	DWORD PTR _handler$40574[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	add	eax, eax
	add	eax, eax
	add	ecx, eax

; 2517 : 			sp = scopeBase + max_scope - 1;

	mov	eax, DWORD PTR _max_scope$[ebp]
	mov	DWORD PTR _pc$[ebp], ecx
	mov	ecx, DWORD PTR _scopeBase$[ebp]
	lea	esi, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _scopeDepth$[ebp], edx

; 2518 : 			*(++sp) = exception->atom;

	mov	edx, DWORD PTR __ee$39598[ebp]
	mov	eax, DWORD PTR [edx]
	add	esi, 4

; 2519 : 			goto MainLoop;

	lea	ecx, DWORD PTR __ef$39597[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], eax
	call	?endTry@ExceptionFrame@avmplus@@QAEXXZ	; avmplus::ExceptionFrame::endTry
	mov	ecx, DWORD PTR _core$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	jmp	$MainLoop$39596
$LN1411@interp:
	mov	esi, DWORD PTR _sp$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
$LN421@interp:
	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [ecx+216], edx
$LL420@interp:
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	cmp	eax, 511				; 000001ffH
	mov	DWORD PTR _pc$[ebp], edi
	ja	$LN500@interp

; 675  : #else
; 676  : 		TRY_UNLESS(core, !info->exceptions, kCatchAction_SearchForActionScriptExceptionHandler) {
; 677  : #endif
; 678  : 			
; 679  : 		restore_dxns();
; 680  : 
; 681  : 		// the verifier ensures we don't fall off the end of a method.  so
; 682  : 		// we dont have to check the end pointer here.
; 683  : #if defined DIRECT_DISPATCH
; 684  : 
; 685  : 		NEXT;
; 686  : 
; 687  : #endif // DIRECT_DISPATCH
; 688  : 
; 689  : #if defined SWITCH_DISPATCH
; 690  : 			
; 691  :         for (;;)
; 692  :         {
; 693  : #  if defined AVMPLUS_WORD_CODE && !defined AVMPLUS_DIRECT_THREADED
; 694  : 			// See comments around INSTR(ext) below.
; 695  : 			AvmAssert((*pc & 65535) == ((*pc >> 16) & 65535));
; 696  : 			switch ((*pc++) & 255)
; 697  : #  else
; 698  :             switch (*pc++)

	je	$L_ext_pushbits$40557
	sub	eax, 1
	cmp	eax, 241				; 000000f1H
	ja	$LN11@interp
	movzx	eax, BYTE PTR $LN1408@interp[eax]
	jmp	DWORD PTR $LN1534@interp[eax*4]
$L_coerce_a$39620:

; 736  : 			}
; 737  : 
; 738  : #ifndef AVMPLUS_WORD_CODE
; 739  :             INSTR(nop) {
; 740  : 				// FIXME: In the direct threaded translation these should probably
; 741  : 				// not be in the instruction stream at all.
; 742  :                 NEXT;
; 743  : 			}
; 744  : #endif
; 745  : 					
; 746  : #ifndef AVMPLUS_WORD_CODE
; 747  :             INSTR(label) {
; 748  : 				// FIXME: In the direct threaded translation these should probably
; 749  : 				// not be in the instruction stream at all.
; 750  :                 NEXT;
; 751  : 			}
; 752  : #endif
; 753  : 					
; 754  : #ifndef AVMPLUS_WORD_CODE
; 755  : 			INSTR(timestamp) {
; 756  : 				// FIXME: In the direct threaded translation these should probably
; 757  : 				// not be in the instruction stream at all.
; 758  :                 NEXT;
; 759  : 			}
; 760  : #endif
; 761  : 					
; 762  : 			INSTR(coerce_a) { // no-op since interpreter only uses atoms
; 763  : #ifdef MSVC_X86_REWRITE_THREADING
; 764  : 				SAVE_EXPC;    // need to do _something_ or the label disappears completely

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 765  : #endif
; 766  :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	SHORT $LL420@interp
$L_bkpt$39622:

; 767  : 			}
; 768  : 
; 769  : 			INSTR(bkpt) {
; 770  : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2408 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]

; 2409 : 				NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	DWORD PTR [edx+216], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	SHORT $LL420@interp
$L_debugline$39624:

; 771  : 				#ifdef DEBUGGER
; 772  : 				if (debugger)
; 773  : 				{
; 774  : 					debugger->enterDebugger();
; 775  : 				}
; 776  : 				#endif
; 777  : 				restore_dxns();
; 778  : 				NEXT;
; 779  : 			}
; 780  : 
; 781  : 			INSTR(debugline) {
; 782  : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 783  : 				int line = U30ARG;

	mov	eax, DWORD PTR [edi]

; 2409 : 				NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _core$[ebp]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR _line$39625[ebp], eax
	add	edi, 4
	mov	DWORD PTR [ecx+216], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_bkptline$39628:

; 784  : 			    #ifdef DEBUGGER
; 785  : 				if (debugger)
; 786  : 				{
; 787  : 					debugger->debugLine(line);
; 788  : 				}
; 789  : 				#else
; 790  : 				(void)line;
; 791  : 				#endif
; 792  : 				restore_dxns();
; 793  : 				NEXT;
; 794  : 			}
; 795  : 
; 796  : 			INSTR(bkptline) {
; 797  : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 798  : 				int line = U30ARG;

	mov	edx, DWORD PTR [edi]

; 2409 : 				NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _core$[ebp]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR _line$39629[ebp], edx
	add	edi, 4
	mov	DWORD PTR [eax+216], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_debugfile$39632:

; 799  : 			    #ifdef DEBUGGER
; 800  : 				if (debugger)
; 801  : 				{
; 802  : 					debugger->debugLine(line);
; 803  : 					debugger->enterDebugger();
; 804  : 				}
; 805  : 				#else
; 806  : 				(void)line;
; 807  : 				#endif
; 808  : 				restore_dxns();
; 809  : 				NEXT;
; 810  : 			}
; 811  : 
; 812  : #ifndef AVMPLUS_WORD_CODE
; 813  : 			INSTR(debug) {
; 814  : 				pc += AvmCore::calculateInstructionWidth(pc-1) - 1;
; 815  : 				NEXT;
; 816  : 			}
; 817  : #endif
; 818  : 
; 819  : 			INSTR(debugfile) {
; 820  : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 821  : 				int index = U30ARG;

	mov	ecx, DWORD PTR [edi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR _index$39633[ebp], ecx

; 822  : 				#ifdef DEBUGGER
; 823  : 				if (debugger)
; 824  : 				{
; 825  : 					debugger->debugFile(pool->getString(index));
; 826  : 				}
; 827  : 				#else
; 828  : 				(void)index;
; 829  : 				#endif
; 830  : 				restore_dxns();
; 831  : 				NEXT;

	jmp	$LN1471@interp
$L_jump$39636:

; 832  : 			}
; 833  : 
; 834  : 			INSTR(jump) {
; 835  : 				int offset = S24ARG;

	mov	eax, DWORD PTR [edi]
	add	edi, 4

; 836  : 				if (offset < 0) {

	test	eax, eax
	mov	DWORD PTR _offset$39637[ebp], eax
	mov	DWORD PTR _pc$[ebp], edi
	jge	SHORT $LN406@interp

; 837  : 					SAVE_EXPC_S24;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx

; 838  : 				    core->branchCheck(env, interruptable, offset);

	mov	ecx, DWORD PTR _core$[ebp]
	sub	edx, 8
	sar	edx, 2
	cmp	BYTE PTR _interruptable$[ebp], 0
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR $T41373[ebp], ecx
	je	SHORT $LN564@interp
	cmp	DWORD PTR [ecx+220], 0
	je	SHORT $LN564@interp
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	call	eax
	mov	ecx, DWORD PTR _core$[ebp]
$LN564@interp:

; 839  : 					restore_dxns();

	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR _offset$39637[ebp]
	mov	DWORD PTR [ecx+216], edx
$LN406@interp:

; 840  : 				}
; 841  : 				pc += offset;

	lea	edi, DWORD PTR [edi+eax*4]

; 842  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushnull$39641:

; 843  : 			}
; 844  : 
; 845  :             INSTR(pushnull) {
; 846  : 				sp++;

	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 847  :                 sp[0] = nullObjectAtom;

	mov	DWORD PTR [esi], 1

; 848  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushundefined$39643:

; 849  : 			}
; 850  : 
; 851  :             INSTR(pushundefined) {
; 852  : 				sp++;

	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 853  :                 sp[0] = undefinedAtom;

	mov	DWORD PTR [esi], 4

; 854  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushstring$39645:

; 855  : 			}
; 856  : 
; 857  :             INSTR(pushstring) {
; 858  : 				sp++;
; 859  :                 sp[0] = cpool_string[U30ARG]->atom();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _cpool_string$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T41377[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	add	esi, 4
	mov	DWORD PTR $T41382[ebp], eax
	add	edi, 4
	or	eax, 2
	mov	DWORD PTR _sp$[ebp], esi

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushdouble$39647:

; 860  :                 NEXT;
; 861  : 			}
; 862  : 
; 863  : #ifndef AVMPLUS_WORD_CODE
; 864  :             INSTR(pushint) {
; 865  : 				// FIXME
; 866  : 				// Here we want the translator to direct threaded code
; 867  : 				// to specialize the operation into a plain 'pushword' that
; 868  : 				// simply pushes the following word (it could be tagged
; 869  : 				// already) or a 'pushdouble'
; 870  : 				sp++;
; 871  :                 sp[0] = core->intToAtom(cpool_int[U30ARG]);
; 872  :                 NEXT;
; 873  : 			}
; 874  : #endif
; 875  : 					
; 876  : #ifndef AVMPLUS_WORD_CODE
; 877  :             INSTR(pushuint) {
; 878  : 				// FIXME
; 879  : 				// Here we want the translator to direct threaded code
; 880  : 				// to specialize the operation into a plain 'pushword' that
; 881  : 				// simply pushes the following word (it could be tagged
; 882  : 				// already) or a 'pushdouble'
; 883  : 				sp++;
; 884  :                 sp[0] = core->uintToAtom(cpool_uint[U30ARG]);
; 885  :                 NEXT;
; 886  : 			}
; 887  : #endif
; 888  : 					
; 889  :             INSTR(pushdouble) {
; 890  : 				sp++;
; 891  :                 sp[0] = kDoubleType|(uintptr)cpool_double[U30ARG];

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _cpool_double$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T41386[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	add	esi, 4
	mov	DWORD PTR $T41387[ebp], eax
	or	eax, 7
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], eax
	add	edi, 4

; 892  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushnamespace$39650:

; 893  : 			}
; 894  : 
; 895  :             INSTR(pushnamespace) {
; 896  :                 sp++;
; 897  :                 sp[0] = cpool_ns[U30ARG]->atom();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _cpool_ns$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T41391[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	add	esi, 4
	mov	DWORD PTR $T41396[ebp], eax
	add	edi, 4
	or	eax, 3
	mov	DWORD PTR _sp$[ebp], esi

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlocal$39652:

; 898  :                 NEXT;
; 899  : 			}
; 900  : 
; 901  :             INSTR(getlocal) {
; 902  :                 sp++;
; 903  : 				sp[0] = framep[U30ARG];

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _framep$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], edx
	add	edi, 4

; 904  : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlocal0$39654:

; 905  : 			}
; 906  : 
; 907  :             INSTR(getlocal0) {
; 908  :                 *(++sp) = framep[0];

	mov	eax, DWORD PTR _framep$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], ecx

; 909  : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlocal1$39656:

; 910  : 			}
; 911  : 
; 912  : 			INSTR(getlocal1) {
; 913  :                 *(++sp) = framep[1];

	mov	edx, DWORD PTR _framep$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlocal2$39658:

; 914  : 				NEXT;
; 915  : 			}
; 916  : 				
; 917  : 			INSTR(getlocal2) {
; 918  :                 *(++sp) = framep[2];

	mov	ecx, DWORD PTR _framep$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], edx

; 919  : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlocal3$39660:

; 920  : 			}
; 921  : 
; 922  : 			INSTR(getlocal3) {
; 923  :                 *(++sp) = framep[3];

	mov	eax, DWORD PTR _framep$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], ecx

; 924  : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushtrue$39662:

; 925  : 			}
; 926  : 
; 927  :             INSTR(pushtrue) {
; 928  :                 sp++;

	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 929  : 				sp[0] = trueAtom;

	mov	DWORD PTR [esi], 13			; 0000000dH

; 930  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushfalse$39664:

; 931  : 			}
; 932  : 
; 933  :             INSTR(pushfalse) {
; 934  : 				sp++;

	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 935  :                 sp[0] = falseAtom;

	mov	DWORD PTR [esi], 5

; 936  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushnan$39666:

; 937  : 			}
; 938  : 
; 939  : 			INSTR(pushnan) {
; 940  : 				sp++;
; 941  : 				sp[0] = core->kNaN;

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR [edx+328]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_dup$39670:

; 942  : 				NEXT;
; 943  : 			}
; 944  : 
; 945  :             INSTR(pop) {
; 946  :                 sp--;
; 947  :                 NEXT;
; 948  : 			}
; 949  : 
; 950  :             INSTR(dup) {
; 951  : 				sp++;
; 952  : 				sp[0] = sp[-1];

	mov	ecx, DWORD PTR [esi]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], ecx

; 953  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_swap$39672:

; 954  : 			}
; 955  : 
; 956  :             INSTR(swap) {
; 957  :                 Atom tempAtom = sp[0];

	mov	eax, DWORD PTR [esi]

; 958  :                 sp[0] = sp[-1];

	mov	edx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR _tempAtom$39673[ebp], eax

; 959  :                 sp[-1] = tempAtom;

	mov	DWORD PTR [esi-4], eax

; 960  :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_convert_s$39675:

; 961  : 			}
; 962  : 
; 963  :             INSTR(convert_s) {
; 964  : 				if ((sp[0] & 7) != kStringType) {

	mov	eax, DWORD PTR [esi]
	and	al, 7
	cmp	al, 2
	je	$LL420@interp

; 965  : 					SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 966  : 				    sp[0] = core->string(sp[0])->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _core$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	call	?string@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::string
	mov	DWORD PTR $T41400[ebp], eax
	or	eax, 2

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_esc_xelem$39678:

; 967  : 					restore_dxns();
; 968  : 				}
; 969  :                 NEXT;
; 970  : 			}
; 971  : 
; 972  : 			INSTR(esc_xelem) { // ToXMLString will call EscapeElementValue
; 973  : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 974  : 				sp[0] = core->ToXMLString(sp[0])->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?ToXMLString@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::ToXMLString

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR $T41404[ebp], eax
	or	eax, 2
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_esc_xattr$39680:

; 975  : 				restore_dxns();
; 976  : 				NEXT;
; 977  : 			}
; 978  : 
; 979  : 			INSTR(esc_xattr) {
; 980  : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 981  : 				sp[0] = core->EscapeAttributeValue(sp[0])->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	?EscapeAttributeValue@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::EscapeAttributeValue
	mov	DWORD PTR $T41408[ebp], eax
	or	eax, 2

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_convert_d$39685:

; 982  : 				restore_dxns();
; 983  : 				NEXT;
; 984  : 			}
; 985  : 
; 986  : #define coerce_d_impl() \
; 987  : 	if (!IS_DOUBLE(sp[0])) { \
; 988  : 		SAVE_EXPC; \
; 989  : 		sp[0] = core->numberAtom(sp[0]); \
; 990  : 		restore_dxns(); \
; 991  : 	}
; 992  : 
; 993  :             INSTR(coerce_d) {
; 994  : 				coerce_d_impl();
; 995  : 				NEXT;
; 996  : 			}
; 997  : 
; 998  :             INSTR(convert_d) {
; 999  : 				coerce_d_impl();

	mov	ecx, DWORD PTR [esi]
	and	ecx, 7
	cmp	cl, 7
$L_coerce_d$39682:
	je	$LL420@interp
	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	?numberAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::numberAtom

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_convert_b$39688:

; 1000 :                 NEXT;
; 1001 : 			}
; 1002 : 
; 1003 : #define coerce_b_impl() \
; 1004 : 	Atom lhs = sp[0]; \
; 1005 : 	if (IS_BOOLEAN(lhs)) \
; 1006 : 		; \
; 1007 : 	else if (IS_INTEGER(lhs)) \
; 1008 : 		sp[0] = lhs == kIntegerType ? falseAtom : trueAtom; \
; 1009 : 	else \
; 1010 : 		sp[0] = core->booleanAtom(lhs);
; 1011 : 
; 1012 :             INSTR(convert_b) {
; 1013 : 				coerce_b_impl();

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	and	eax, 7
	cmp	eax, 5
	mov	DWORD PTR _lhs$39689[ebp], ecx
	je	$LL420@interp
	cmp	eax, 6
	jne	SHORT $LN373@interp
	xor	edx, edx
	cmp	ecx, eax
	setne	dl
	lea	edx, DWORD PTR [edx*8+5]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_coerce_b$39695:

; 1014 : 				NEXT;
; 1015 : 			}
; 1016 : 
; 1017 :             INSTR(coerce_b) {
; 1018 : 				coerce_b_impl();

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	and	eax, 7
	cmp	eax, 5
	mov	DWORD PTR _lhs$39696[ebp], ecx
	je	$LL420@interp
	cmp	eax, 6
	jne	SHORT $LN373@interp
	xor	eax, eax
	cmp	ecx, 6
	setne	al
	lea	eax, DWORD PTR [eax*8+5]

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN373@interp:

; 1014 : 				NEXT;
; 1015 : 			}
; 1016 : 
; 1017 :             INSTR(coerce_b) {
; 1018 : 				coerce_b_impl();

	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?booleanAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::booleanAtom

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_convert_o$39702:

; 1019 :                 NEXT;
; 1020 : 			}
; 1021 : 
; 1022 :             INSTR(convert_o) {
; 1023 : 				if (AvmCore::isNullOrUndefined(sp[0])) {

	cmp	DWORD PTR [esi], 4
	ja	$LL420@interp

; 1024 : 					SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1025 : 				    env->nullcheck(sp[0]);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _env$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 1026 : 				}
; 1027 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_negate$39705:

; 1028 : 			}
; 1029 : 
; 1030 :             INSTR(negate) {
; 1031 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]

; 1032 : 				if (IS_INTEGER(val) && val != MAKE_INTEGER(0)) {

	mov	ecx, eax
	and	ecx, 7
	cmp	cl, 6
	mov	DWORD PTR _val$39706[ebp], eax
	jne	SHORT $LN367@interp
	cmp	eax, 6
	je	SHORT $LN367@interp

; 1033 : 					int32 v = -(val >> 3);

	sar	eax, 3
	neg	eax

; 1034 : 					if (FITS_IN_INTEGER(v)) {

	lea	ecx, DWORD PTR [eax*8]
	mov	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	mov	DWORD PTR _v$39708[ebp], eax
	jne	SHORT $LN367@interp

; 1035 : 						sp[0] = MAKE_INTEGER(v);

	or	ecx, 6
	mov	DWORD PTR [esi], ecx

; 1036 : 						NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN367@interp:

; 1037 : 					}
; 1038 : 				}
; 1039 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1040 : 				sp[0] = core->doubleToAtom(-core->number(val));

	mov	edx, DWORD PTR _val$39706[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fchs
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom

; 1041 : 				restore_dxns();
; 1042 :                 NEXT;

	jmp	$LN1475@interp
$L_negate_i$39712:

; 1043 : 			}
; 1044 : 
; 1045 : 			INSTR(negate_i) {
; 1046 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1047 :                 sp[0] = core->intToAtom(-core->integer(sp[0]));

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	neg	eax
	push	eax
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_kill$39714:

; 1048 : 				restore_dxns();
; 1049 :                 NEXT;
; 1050 : 			}
; 1051 : 
; 1052 : 			INSTR(kill) {
; 1053 : 				framep[U30ARG] = undefinedAtom;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _framep$[ebp]
	mov	DWORD PTR [edx+ecx*4], 4
	add	edi, 4

; 1054 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_typeof$39716:

; 1055 : 			}
; 1056 : 
; 1057 :             INSTR(typeof) {
; 1058 : 				*sp = core->_typeof(*sp)->atom();

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?_typeof@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::_typeof
	mov	DWORD PTR $T41415[ebp], eax
	or	eax, 2

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_not$39718:

; 1059 :                 NEXT;
; 1060 : 			}
; 1061 : 
; 1062 :             INSTR(not) {
; 1063 : 				Atom bval = sp[0];

	mov	eax, DWORD PTR [esi]

; 1064 : 				if (IS_BOOLEAN(bval))

	mov	ecx, eax
	and	ecx, 7
	cmp	ecx, 5
	mov	DWORD PTR _bval$39719[ebp], eax
	je	SHORT $LN359@interp

; 1065 : 					;
; 1066 : 				else if (IS_INTEGER(bval))

	cmp	ecx, 6
	jne	SHORT $LN360@interp

; 1067 : 					bval = bval == kIntegerType ? falseAtom : trueAtom;

	xor	ecx, ecx
	cmp	eax, 6
	setne	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	eax, ecx

; 1068 : 				else
; 1069 : 					bval = core->booleanAtom(bval);

	mov	DWORD PTR _bval$39719[ebp], eax

; 1070 :                 sp[0] = bval ^ booleanNotMask;

	xor	eax, 8

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN360@interp:

; 1068 : 				else
; 1069 : 					bval = core->booleanAtom(bval);

	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?booleanAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::booleanAtom
	mov	DWORD PTR _bval$39719[ebp], eax
$LN359@interp:

; 1070 :                 sp[0] = bval ^ booleanNotMask;

	xor	eax, 8

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_bitnot$39725:

; 1071 :                 NEXT;
; 1072 : 			}
; 1073 : 
; 1074 : 			INSTR(bitnot) {
; 1075 : 				// OPTIMIZEME
; 1076 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1077 : 				*sp = core->intToAtom(~core->integer(*sp));

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	not	eax
	push	eax
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setlocal$39727:

; 1078 : 				restore_dxns();
; 1079 :                 NEXT;
; 1080 : 			}
; 1081 : 
; 1082 :             INSTR(setlocal) {
; 1083 :                 framep[U30ARG] = *(sp--);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _framep$[ebp]
	add	edi, 4

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [eax+ecx*4], edx
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setlocal0$39729:

; 1084 :                 NEXT;
; 1085 : 			}
; 1086 : 
; 1087 :             INSTR(setlocal0) {
; 1088 :                 framep[0] = *(sp--);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _framep$[ebp]

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setlocal1$39731:

; 1089 : 				NEXT;
; 1090 : 			}
; 1091 : 
; 1092 :             INSTR(setlocal1) {
; 1093 :                 framep[1] = *(sp--);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _framep$[ebp]

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setlocal2$39733:

; 1094 : 				NEXT;
; 1095 : 			}
; 1096 : 
; 1097 :             INSTR(setlocal2) {
; 1098 :                 framep[2] = *(sp--);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _framep$[ebp]

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setlocal3$39735:

; 1099 : 				NEXT;
; 1100 : 			}
; 1101 : 
; 1102 :             INSTR(setlocal3) {
; 1103 :                 framep[3] = *(sp--);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _framep$[ebp]

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_increment$39737:

; 1104 :                 NEXT;
; 1105 : 			}	
; 1106 : 
; 1107 : // Add lhs and rhs if they are both fixnums and computation does not overflow,
; 1108 : // or if they are both flonums.  On success, store the result in dest, and NEXT.
; 1109 : 
; 1110 : #define FAST_ADD_MAYBE(lhs,rhs,dest) \
; 1111 : 	if (IS_BOTH_INTEGER(lhs, rhs)) { \
; 1112 : 		uint32 lop = (uint32)lhs ^ kIntegerType, rop = (uint32)rhs ^ kIntegerType; \
; 1113 : 		uint32 result = lop + rop; \
; 1114 : 		if ((int32)(lop ^ rop) < 0 || (int32)(result ^ lop) >= 0) { \
; 1115 : 			dest = result | kIntegerType; \
; 1116 : 			NEXT; \
; 1117 : 		} \
; 1118 : 	} \
; 1119 : 	else if (IS_BOTH_DOUBLE(lhs, rhs)) { \
; 1120 : 		dest = core->doubleToAtom(DOUBLE_VALUE(lhs) + DOUBLE_VALUE(rhs)); \
; 1121 : 		NEXT; \
; 1122 : 	}
; 1123 : 
; 1124 : // Add 1 to lhs if it is a fixnum and computation does not overflow, or
; 1125 : // if lhs is a flonum.  On success, store the result in dest, and NEXT.
; 1126 : 					
; 1127 : #define FAST_INC_MAYBE(lhs,dest) \
; 1128 : 	if (IS_INTEGER(lhs)) { \
; 1129 : 		uint32 lop = (uint32)lhs ^ kIntegerType; \
; 1130 : 		uint32 result = lop + (1 << 3); \
; 1131 : 		if ((int32)lop < 0 || (int32)(result ^ lop) >= 0) { \
; 1132 : 			dest = result | kIntegerType; \
; 1133 : 			NEXT; \
; 1134 : 		} \
; 1135 : 	} \
; 1136 :     else if (IS_DOUBLE(lhs)) { \
; 1137 : 		dest = core->doubleToAtom(DOUBLE_VALUE(lhs) + 1.0); \
; 1138 : 		NEXT; \
; 1139 : 	}
; 1140 : 					
; 1141 : // Subtract rhs from lhs if they are both fixnums and computation does not overflow.
; 1142 : // On success, store the result in dest, and NEXT.
; 1143 : #define FAST_SUB_MAYBE(lhs,rhs,dest) \
; 1144 : 	if (IS_BOTH_INTEGER(lhs, rhs)) { \
; 1145 : 		uint32 lop = (uint32)lhs ^ kIntegerType, rop = (uint32)rhs ^ kIntegerType; \
; 1146 : 		uint32 result = lop - rop; \
; 1147 : 		if ((int32)(lop ^ rop) >= 0 || (int32)(result ^ lop) >= 0) { \
; 1148 : 			dest = result | kIntegerType; \
; 1149 : 			NEXT; \
; 1150 : 		} \
; 1151 : 	} \
; 1152 : 	else if (IS_BOTH_DOUBLE(lhs, rhs)) { \
; 1153 : 		dest = core->doubleToAtom(DOUBLE_VALUE(lhs) + DOUBLE_VALUE(rhs)); \
; 1154 : 		NEXT; \
; 1155 : 	}
; 1156 : 
; 1157 : // Subtract 1 from lhs if lhs is a fixnum and computation does not overflow.
; 1158 : // On success, store the result in dest, and NEXT.
; 1159 : #define FAST_DEC_MAYBE(lhs,dest) \
; 1160 : 	if (IS_INTEGER(lhs)) { \
; 1161 : 		uint32 lop = (uint32)lhs ^ kIntegerType; \
; 1162 : 		uint32 result = lop - (1 << 3); \
; 1163 : 		if ((int32)lop >= 0 || (int32)(result ^ lop) >= 0) { \
; 1164 : 			dest = result | kIntegerType; \
; 1165 : 			NEXT; \
; 1166 : 		} \
; 1167 : 	} \
; 1168 :     else if (IS_DOUBLE(lhs)) { \
; 1169 : 		dest = core->doubleToAtom(DOUBLE_VALUE(lhs) - 1.0); \
; 1170 : 		NEXT; \
; 1171 : 	}
; 1172 : 
; 1173 :             INSTR(increment) {
; 1174 : 				Atom lhs = *sp;

	mov	eax, DWORD PTR [esi]

; 1175 : 				FAST_INC_MAYBE(lhs,sp[0]);

	mov	ecx, eax
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _lhs$39738[ebp], eax
	jne	SHORT $LN351@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lop$39740[ebp], eax
	mov	DWORD PTR _result$39742[ebp], ecx
	jl	SHORT $LN349@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN347@interp
$LN349@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN351@interp:
	cmp	ecx, 7
	jne	SHORT $LN347@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	fadd	QWORD PTR __real@3ff0000000000000
	jmp	$LN1488@interp
$LN347@interp:

; 1176 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1177 : 				*sp = core->numberAtom(lhs);

	mov	edx, DWORD PTR _lhs$39738[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?numberAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::numberAtom
	mov	esi, DWORD PTR _sp$[ebp]

; 1178 : 				core->increment_d(sp, 1);

	push	1
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_d@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_d

; 2373 : 					restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_increment_i$39751:

; 1179 : 				restore_dxns();
; 1180 :                 NEXT;
; 1181 : 			}
; 1182 : 
; 1183 :             INSTR(increment_i) {
; 1184 : 				Atom lhs = *sp;

	mov	eax, DWORD PTR [esi]

; 1185 : 				FAST_INC_MAYBE(lhs,sp[0]);

	mov	ecx, eax
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _lhs$39752[ebp], eax
	jne	SHORT $LN345@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lop$39754[ebp], eax
	mov	DWORD PTR _result$39756[ebp], ecx
	jl	SHORT $LN343@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN341@interp
$LN343@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN345@interp:
	cmp	ecx, 7
	jne	SHORT $LN341@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	fadd	QWORD PTR __real@3ff0000000000000
	jmp	$LN1488@interp
$LN341@interp:

; 1186 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1187 : 				core->increment_i(sp, 1);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	push	1
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_i@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_i

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_inclocal$39765:

; 1188 : 				restore_dxns();
; 1189 :                 NEXT;
; 1190 : 			}
; 1191 : 
; 1192 : 			INSTR(inclocal) {
; 1193 : 				SAVE_EXPC;  // because U30ARG prevents it from being done after FAST_INC_MAYBE.  Clean up for threaded code.

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1194 : 				Atom* rp = framep+U30ARG;

	mov	eax, DWORD PTR [edi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _framep$[ebp]
	sub	edx, 4
	lea	esi, DWORD PTR [ecx+eax*4]
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx

; 1195 : 				Atom lhs = *rp;

	mov	edx, DWORD PTR [esi]
	mov	eax, edx

; 1196 : 				FAST_INC_MAYBE(lhs,*rp);

	mov	ecx, eax
	add	edi, 4
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _rp$39766[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _lhs$39767[ebp], eax
	jne	SHORT $LN339@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lop$39769[ebp], eax
	mov	DWORD PTR _result$39771[ebp], ecx
	jl	SHORT $LN337@interp
	mov	ebx, ecx
	xor	ebx, eax
	jl	SHORT $LN335@interp
$LN337@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN339@interp:

; 1196 : 				FAST_INC_MAYBE(lhs,*rp);

	cmp	ecx, 7
	jne	SHORT $LN335@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _core$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN335@interp:

; 1197 : 				*rp = core->numberAtom(*rp);

	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?numberAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::numberAtom

; 1198 : 				core->increment_d(rp, 1);

	push	1
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_d@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_d

; 1199 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [edx+216], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_inclocal_i$39780:

; 1200 : 				NEXT;
; 1201 : 			}
; 1202 : 
; 1203 :             INSTR(inclocal_i) {
; 1204 : 				SAVE_EXPC;  // because U30ARG prevents it from being done after FAST_INC_MAYBE.  Clean up for threaded code.

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1205 : 				Atom* rp = framep+U30ARG;

	mov	eax, DWORD PTR [edi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _framep$[ebp]
	lea	esi, DWORD PTR [ecx+eax*4]

; 1206 : 				Atom lhs = *rp;

	mov	eax, DWORD PTR [esi]
	sub	edx, 4

; 1207 : 				FAST_INC_MAYBE(lhs,*rp);

	mov	ecx, eax
	sar	edx, 2
	add	edi, 4
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _rp$39781[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _lhs$39782[ebp], eax
	jne	SHORT $LN333@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lop$39784[ebp], eax
	mov	DWORD PTR _result$39786[ebp], ecx
	jl	SHORT $LN331@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN329@interp
$LN331@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN333@interp:

; 1207 : 				FAST_INC_MAYBE(lhs,*rp);

	cmp	ecx, 7
	jne	SHORT $LN329@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _core$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN329@interp:

; 1208 : 				core->increment_i(rp, 1);

	push	1

; 1209 : 				restore_dxns();
; 1210 : 				NEXT;

	jmp	$LN1490@interp
$L_decrement$39795:

; 1211 : 			}
; 1212 : 
; 1213 :             INSTR(decrement) {
; 1214 : 				Atom lhs = *sp;

	mov	eax, DWORD PTR [esi]

; 1215 : 				FAST_DEC_MAYBE(lhs,sp[0]);

	mov	ecx, eax
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _lhs$39796[ebp], eax
	jne	SHORT $LN327@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax-8]
	mov	DWORD PTR _lop$39798[ebp], eax
	mov	DWORD PTR _result$39800[ebp], ecx
	jge	SHORT $LN325@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN323@interp
$LN325@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN327@interp:
	cmp	ecx, 7
	jne	SHORT $LN323@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	fsub	QWORD PTR __real@3ff0000000000000
	jmp	$LN1488@interp
$LN323@interp:

; 1216 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1217 : 				*sp = core->numberAtom(*sp);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?numberAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::numberAtom

; 1218 : 				core->increment_d(sp, -1);

	push	-1
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_d@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_d

; 2373 : 					restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_decrement_i$39809:

; 1219 : 				restore_dxns();
; 1220 :                 NEXT;
; 1221 : 			}
; 1222 : 
; 1223 :             INSTR(decrement_i) {
; 1224 : 				Atom lhs = *sp;

	mov	eax, DWORD PTR [esi]

; 1225 : 				FAST_DEC_MAYBE(lhs,sp[0]);

	mov	ecx, eax
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _lhs$39810[ebp], eax
	jne	SHORT $LN321@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax-8]
	mov	DWORD PTR _lop$39812[ebp], eax
	mov	DWORD PTR _result$39814[ebp], ecx
	jge	SHORT $LN319@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN317@interp
$LN319@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN321@interp:
	cmp	ecx, 7
	jne	SHORT $LN317@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	fsub	QWORD PTR __real@3ff0000000000000
	jmp	$LN1488@interp
$LN317@interp:

; 1226 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1227 : 				core->increment_i(sp, -1);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	push	-1
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_i@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_i

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_declocal$39823:

; 1228 : 				restore_dxns();
; 1229 :                 NEXT;
; 1230 : 			}
; 1231 : 
; 1232 : 			INSTR(declocal) {
; 1233 : 				SAVE_EXPC;  // because U30ARG prevents it from being done after FAST_DEC_MAYBE.  Clean up for threaded code.

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1234 : 				Atom* rp = framep+U30ARG;

	mov	eax, DWORD PTR [edi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _framep$[ebp]
	sub	edx, 4
	lea	esi, DWORD PTR [ecx+eax*4]
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx

; 1235 : 				Atom lhs = *rp;

	mov	edx, DWORD PTR [esi]
	mov	eax, edx

; 1236 : 				FAST_DEC_MAYBE(lhs,*rp);

	mov	ecx, eax
	add	edi, 4
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _rp$39824[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _lhs$39825[ebp], eax
	jne	SHORT $LN315@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax-8]
	mov	DWORD PTR _lop$39827[ebp], eax
	mov	DWORD PTR _result$39829[ebp], ecx
	jge	SHORT $LN313@interp
	mov	ebx, ecx
	xor	ebx, eax
	jl	SHORT $LN311@interp
$LN313@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN315@interp:
	cmp	ecx, 7
	jne	SHORT $LN311@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _core$[ebp]
	fsub	QWORD PTR __real@3ff0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN311@interp:

; 1237 : 				*rp = core->numberAtom(*rp);

	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?numberAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::numberAtom

; 1238 : 				core->increment_d(rp, -1);

	push	-1
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_d@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_d

; 1239 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]

; 1240 : 				NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [edx+216], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_declocal_i$39838:

; 1241 : 			}
; 1242 : 
; 1243 : 			INSTR(declocal_i) {
; 1244 : 				SAVE_EXPC;  // because U30ARG prevents it from being done after FAST_DEC_MAYBE.  Clean up for threaded code.

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1245 : 				Atom* rp = framep+U30ARG;

	mov	eax, DWORD PTR [edi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _framep$[ebp]
	lea	esi, DWORD PTR [ecx+eax*4]

; 1246 : 				Atom lhs = *rp;

	mov	eax, DWORD PTR [esi]
	sub	edx, 4

; 1247 : 				FAST_DEC_MAYBE(lhs,*rp);

	mov	ecx, eax
	sar	edx, 2
	add	edi, 4
	and	ecx, 7
	cmp	ecx, 6
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _rp$39839[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _lhs$39840[ebp], eax
	jne	SHORT $LN309@interp
	xor	eax, ecx
	lea	ecx, DWORD PTR [eax-8]
	mov	DWORD PTR _lop$39842[ebp], eax
	mov	DWORD PTR _result$39844[ebp], ecx
	jge	SHORT $LN307@interp
	mov	edx, ecx
	xor	edx, eax
	jl	SHORT $LN305@interp
$LN307@interp:
	or	ecx, 6
	mov	DWORD PTR [esi], ecx
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN309@interp:
	cmp	ecx, 7
	jne	SHORT $LN305@interp
	xor	eax, ecx
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _core$[ebp]
	fsub	QWORD PTR __real@3ff0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN305@interp:

; 1248 : 				core->increment_i(rp, -1);

	push	-1
$LN1490@interp:
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?increment_i@AvmCore@avmplus@@QAEXPAHH@Z ; avmplus::AvmCore::increment_i

; 1249 : 				restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]

; 1250 :                 NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [eax+216], ecx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_add$39853:

; 1251 : 			}
; 1252 : 
; 1253 :             INSTR(add) {
; 1254 : 				Atom lhs = sp[-1], rhs=sp[0];

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]

; 1255 : 				sp--;
; 1256 : 				FAST_ADD_MAYBE(lhs,rhs,sp[0]);

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39854[ebp], eax
	mov	DWORD PTR _rhs$39855[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN303@interp
	xor	eax, 6
	xor	ecx, 6
	lea	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _rop$39859[ebp], ecx
	xor	ecx, eax
	mov	DWORD PTR _lop$39857[ebp], eax
	mov	DWORD PTR _result$39861[ebp], edx
	jl	SHORT $LN301@interp
	mov	ecx, edx
	xor	ecx, eax
	jl	SHORT $LN299@interp
$LN301@interp:
	or	edx, 6
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN303@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN299@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fadd	QWORD PTR [eax]
	jmp	$LN1488@interp
$LN299@interp:

; 1257 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1258 :                 sp[0] = toplevel->add2(lhs, rhs);

	mov	edx, DWORD PTR _rhs$39855[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _lhs$39854[ebp]
	sub	ecx, 4
	sar	ecx, 2
	push	edx
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	call	?add2@Toplevel@avmplus@@QAEHHH@Z	; avmplus::Toplevel::add2

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_add_i$39871:

; 1259 : 				restore_dxns();
; 1260 :                 NEXT;
; 1261 : 			}
; 1262 : 
; 1263 : 			INSTR(add_i) {
; 1264 : 				Atom lhs = sp[-1], rhs=sp[0];

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]

; 1265 : 				sp--;
; 1266 : 				FAST_ADD_MAYBE(lhs,rhs,sp[0]);

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39872[ebp], eax
	mov	DWORD PTR _rhs$39873[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN297@interp
	xor	eax, 6
	xor	ecx, 6
	lea	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _rop$39877[ebp], ecx
	xor	ecx, eax
	mov	DWORD PTR _lop$39875[ebp], eax
	mov	DWORD PTR _result$39879[ebp], edx
	jl	SHORT $LN295@interp
	mov	ecx, edx
	xor	ecx, eax
	jl	SHORT $LN293@interp
$LN295@interp:
	or	edx, 6
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN297@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN293@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fadd	QWORD PTR [eax]
	jmp	$LN1488@interp
$LN293@interp:

; 1267 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1268 : 				sp[0] = core->intToAtom(core->integer(lhs) + core->integer(rhs));

	mov	edx, DWORD PTR _rhs$39873[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39872[ebp]
	push	eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	add	esi, eax
	push	esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_subtract$39889:

; 1269 : 				restore_dxns();
; 1270 :                 NEXT;
; 1271 : 			}
; 1272 : 
; 1273 :             INSTR(subtract) {
; 1274 : 				Atom lhs = sp[-1], rhs=sp[0];

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]

; 1275 : 				sp--;
; 1276 : 				FAST_SUB_MAYBE(lhs,rhs,sp[0]);

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39890[ebp], eax
	mov	DWORD PTR _rhs$39891[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN291@interp
	xor	eax, 6
	xor	ecx, 6
	mov	edx, eax
	sub	edx, ecx
	mov	DWORD PTR _rop$39895[ebp], ecx
	xor	ecx, eax
	mov	DWORD PTR _lop$39893[ebp], eax
	mov	DWORD PTR _result$39897[ebp], edx
	jge	SHORT $LN289@interp
	mov	ecx, edx
	xor	ecx, eax
	jl	SHORT $LN287@interp
$LN289@interp:
	or	edx, 6
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN291@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN287@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fadd	QWORD PTR [eax]
	jmp	$LN1488@interp
$LN287@interp:

; 1277 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1278 :                 sp[0] = core->doubleToAtom(core->number(lhs) - core->number(rhs));

	mov	edx, DWORD PTR _lhs$39890[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fstp	QWORD PTR tv6917[ebp]
	mov	eax, DWORD PTR _rhs$39891[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fsubr	QWORD PTR tv6917[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_subtract_i$39907:

; 1279 : 				restore_dxns();
; 1280 :                 NEXT;
; 1281 : 			}
; 1282 : 
; 1283 :             INSTR(subtract_i) {
; 1284 : 				Atom lhs = sp[-1], rhs=sp[0];

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]

; 1285 : 				sp--;
; 1286 : 				FAST_SUB_MAYBE(lhs,rhs,sp[0]);

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39908[ebp], eax
	mov	DWORD PTR _rhs$39909[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN285@interp
	xor	eax, 6
	xor	ecx, 6
	mov	edx, eax
	sub	edx, ecx
	mov	DWORD PTR _rop$39913[ebp], ecx
	xor	ecx, eax
	mov	DWORD PTR _lop$39911[ebp], eax
	mov	DWORD PTR _result$39915[ebp], edx
	jge	SHORT $LN283@interp
	mov	ecx, edx
	xor	ecx, eax
	jl	SHORT $LN281@interp
$LN283@interp:
	or	edx, 6
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN285@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN281@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fadd	QWORD PTR [eax]
	jmp	$LN1488@interp
$LN281@interp:

; 1287 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1288 : 				sp[0] = core->intToAtom(core->integer(lhs) - core->integer(lhs));

	mov	esi, DWORD PTR _lhs$39908[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	push	esi
	mov	ebx, eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	sub	ebx, eax
	push	ebx
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom
	mov	esi, DWORD PTR _sp$[ebp]

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_multiply$39925:

; 1289 : 				restore_dxns();
; 1290 :                 NEXT;
; 1291 : 			}
; 1292 : 
; 1293 :             INSTR(multiply) {
; 1294 : 				// OPTIMIZEME? for small integer
; 1295 : 				Atom lhs = sp[-1], rhs = sp[0];

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi-4]

; 1296 : 				sp--;
; 1297 : 				if (IS_BOTH_DOUBLE(lhs, rhs)) {

	mov	edx, ecx
	not	edx
	add	esi, -4					; fffffffcH
	or	edx, eax
	test	dl, 7
	mov	DWORD PTR _lhs$39926[ebp], eax
	mov	DWORD PTR _rhs$39927[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN279@interp

; 1298 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) * DOUBLE_VALUE(rhs));

	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fmul	QWORD PTR [eax]

; 1299 : 					NEXT;

	jmp	$LN1488@interp
$LN279@interp:

; 1300 : 				}
; 1301 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1302 :                 sp[0] = core->doubleToAtom(core->number(lhs) * core->number(rhs));

	mov	edx, DWORD PTR _rhs$39927[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fstp	QWORD PTR tv6919[ebp]
	mov	eax, DWORD PTR _lhs$39926[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fmul	QWORD PTR tv6919[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_multiply_i$39932:

; 1303 : 				restore_dxns();
; 1304 :                 NEXT;
; 1305 : 			}
; 1306 : 
; 1307 : 			INSTR(multiply_i) {
; 1308 : 				// OPTIMIZEME? for small integer
; 1309 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax

; 1310 :                 sp[-1] = core->intToAtom(core->integer(sp[-1]) * core->integer(sp[0]));

	mov	eax, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	lea	esi, DWORD PTR [eax-4]
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	imul	ebx, eax
	mov	ecx, DWORD PTR _core$[ebp]
	push	ebx
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _sp$[ebp], esi

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_divide$39934:

; 1311 :                 sp--;
; 1312 : 				restore_dxns();
; 1313 :                 NEXT;
; 1314 : 			}
; 1315 : 
; 1316 :             INSTR(divide) {
; 1317 : 				Atom lhs = sp[-1], rhs = sp[0];

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi-4]

; 1318 : 				sp--;
; 1319 : 				if (IS_BOTH_DOUBLE(lhs, rhs)) {

	mov	edx, ecx
	not	edx
	add	esi, -4					; fffffffcH
	or	edx, eax
	test	dl, 7
	mov	DWORD PTR _lhs$39935[ebp], eax
	mov	DWORD PTR _rhs$39936[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN276@interp

; 1320 : 					sp[0] = core->doubleToAtom(DOUBLE_VALUE(lhs) / DOUBLE_VALUE(rhs));

	xor	eax, 7
	fld	QWORD PTR [eax]
	xor	ecx, 7
	fdiv	QWORD PTR [ecx]
$LN1488@interp:
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax

; 1321 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN276@interp:

; 1322 : 				}
; 1323 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1324 : 				sp[0] = core->doubleToAtom(core->number(lhs) / core->number(rhs));

	mov	edx, DWORD PTR _lhs$39935[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fstp	QWORD PTR tv6921[ebp]
	mov	eax, DWORD PTR _rhs$39936[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	fdivr	QWORD PTR tv6921[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_modulo$39941:

; 1325 : 				restore_dxns();
; 1326 :                 NEXT;
; 1327 : 			}
; 1328 : 
; 1329 :             INSTR(modulo) {
; 1330 : 				Atom lhs = sp[-1], rhs = sp[0];

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]

; 1331 : 				sp--;
; 1332 : 				if (IS_BOTH_INTEGER(lhs, rhs) && rhs != kIntegerType) {

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39942[ebp], eax
	mov	DWORD PTR _rhs$39943[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN274@interp
	cmp	ecx, 6
	je	SHORT $LN274@interp

; 1333 : 					int result = (lhs >> 3) % (rhs >> 3);  // can this overflow somehow? 

	sar	eax, 3
	sar	ecx, 3
	cdq
	idiv	ecx

; 1334 : 					if (FITS_IN_INTEGER(result)) {

	lea	eax, DWORD PTR [edx*8]
	mov	ecx, eax
	sar	ecx, 3
	cmp	ecx, edx
	mov	DWORD PTR _result$39945[ebp], edx
	jne	SHORT $LN271@interp

; 1335 : 						sp[0] = MAKE_INTEGER(result);

	or	eax, 6
	mov	DWORD PTR [esi], eax

; 1336 : 						NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN274@interp:

; 1337 : 					}
; 1338 : 				}
; 1339 : 				else if (IS_BOTH_DOUBLE(lhs, rhs)) {

	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN271@interp

; 1340 : 					sp[0] = core->doubleToAtom(MathUtils::mod(DOUBLE_VALUE(lhs), DOUBLE_VALUE(rhs)));

	xor	ecx, 7
	fld	QWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	xor	eax, 7
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esp]
	call	?mod@MathUtils@avmplus@@SANNN@Z		; avmplus::MathUtils::mod
	mov	ecx, DWORD PTR _core$[ebp]
	fstp	QWORD PTR [esp+8]
	add	esp, 8
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax

; 1341 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN271@interp:

; 1342 : 				}
; 1343 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1344 : 				sp[0] = core->doubleToAtom(MathUtils::mod(core->number(lhs), core->number(rhs)));

	mov	edx, DWORD PTR _rhs$39943[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	mov	eax, DWORD PTR _lhs$39942[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	?number@AvmCore@avmplus@@QBENH@Z	; avmplus::AvmCore::number
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?mod@MathUtils@avmplus@@SANNN@Z		; avmplus::MathUtils::mod
	mov	ecx, DWORD PTR _core$[ebp]
	fstp	QWORD PTR [esp+8]
	add	esp, 8
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_lshift$39953:

; 1345 : 				restore_dxns();
; 1346 : 				NEXT;
; 1347 : 			}
; 1348 : 
; 1349 :             INSTR(lshift) {
; 1350 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR [esi-4]

; 1351 : 				Atom rhs = sp[0];

	mov	ecx, DWORD PTR [esi]

; 1352 : 				sp--;
; 1353 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39954[ebp], eax
	mov	DWORD PTR _rhs$39955[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN268@interp

; 1354 : 					int32 result = INTEGER_VALUE(lhs) << (INTEGER_VALUE(rhs) & 0x1F);

	sar	ecx, 3
	and	ecx, 31					; 0000001fH
	sar	eax, 3
	shl	eax, cl

; 1355 : 					if (FITS_IN_INTEGER(result)) {

	lea	ecx, DWORD PTR [eax*8]
	mov	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	mov	DWORD PTR _result$39957[ebp], eax
	jne	SHORT $LN268@interp

; 1356 : 						sp[0] = MAKE_INTEGER(result);

	or	ecx, 6
	mov	DWORD PTR [esi], ecx

; 1357 : 						NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN268@interp:

; 1358 : 					}
; 1359 : 				}
; 1360 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1361 : 				sp[0] = core->intToAtom( core->integer(lhs) << (core->toUInt32(rhs)&0x1F) );

	mov	edx, DWORD PTR _rhs$39955[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	mov	DWORD PTR $T41419[ebp], ecx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39954[ebp]
	push	eax
	mov	DWORD PTR $T41420[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	shl	eax, cl
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_rshift$39963:

; 1362 : 				restore_dxns();
; 1363 :                 NEXT;
; 1364 : 			}
; 1365 : 
; 1366 :             INSTR(rshift) {
; 1367 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR [esi-4]

; 1368 : 				Atom rhs = sp[0];

	mov	ecx, DWORD PTR [esi]

; 1369 : 				sp--;
; 1370 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39964[ebp], eax
	mov	DWORD PTR _rhs$39965[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN266@interp

; 1371 : 					sp[0] = MAKE_INTEGER(INTEGER_VALUE(lhs) >> (INTEGER_VALUE(rhs) & 0x1F));

	sar	eax, 3
	sar	ecx, 3
	and	ecx, 31					; 0000001fH
	sar	eax, cl
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, 6
	mov	DWORD PTR [esi], eax

; 1372 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN266@interp:

; 1373 : 				}
; 1374 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1375 : 				sp[0] = core->intToAtom( core->integer(lhs) >> (core->toUInt32(rhs)&0x1F) );

	mov	edx, DWORD PTR _rhs$39965[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	mov	DWORD PTR $T41424[ebp], ecx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39964[ebp]
	push	eax
	mov	DWORD PTR $T41425[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	sar	eax, cl
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_urshift$39970:

; 1376 : 				restore_dxns();
; 1377 :                 NEXT;
; 1378 : 			}
; 1379 : 
; 1380 :             INSTR(urshift) {
; 1381 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR [esi-4]

; 1382 : 				Atom rhs = sp[0];

	mov	ecx, DWORD PTR [esi]

; 1383 : 				sp--;
; 1384 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39971[ebp], eax
	mov	DWORD PTR _rhs$39972[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN263@interp

; 1385 : 					uint32 result = ((uint32)INTEGER_VALUE(lhs) >> (INTEGER_VALUE(rhs) & 0x1F));

	sar	ecx, 3
	and	ecx, 31					; 0000001fH
	sar	eax, 3
	shr	eax, cl

; 1386 : 					if ((result & 0xF0000000U) == 0) {

	test	eax, -268435456				; f0000000H
	mov	DWORD PTR _result$39974[ebp], eax
	jne	SHORT $LN263@interp

; 1387 : 						sp[0] = MAKE_INTEGER(result);

	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, 6
	mov	DWORD PTR [esi], eax

; 1388 : 						NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN263@interp:

; 1389 : 					}
; 1390 : 				}
; 1391 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1392 :                 sp[0] = core->uintToAtom( core->toUInt32(lhs) >> (core->toUInt32(rhs)&0x1F) );

	mov	eax, DWORD PTR _lhs$39971[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _core$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR $T41429[ebp], ecx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	edx, DWORD PTR _rhs$39972[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	push	edx
	mov	DWORD PTR $T41430[ebp], esi
	mov	DWORD PTR $T41434[ebp], ecx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, eax
	and	ecx, 31					; 0000001fH
	shr	esi, cl
	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR $T41435[ebp], eax
	push	esi
	call	?uintToAtom@AvmCore@avmplus@@QAEHI@Z	; avmplus::AvmCore::uintToAtom
	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 1393 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_bitand$39980:

; 1394 : 			}
; 1395 : 
; 1396 :             INSTR(bitand) {
; 1397 : 				Atom lhs = sp[-1];

	mov	ecx, DWORD PTR [esi-4]

; 1398 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [esi]

; 1399 : 				sp--;
; 1400 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, eax
	mov	ebx, ecx
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39981[ebp], ecx
	mov	DWORD PTR _rhs$39982[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN261@interp

; 1401 : 					sp[0] = lhs & rhs;

	and	eax, ecx
	mov	DWORD PTR [esi], eax

; 1402 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN261@interp:

; 1403 : 				}
; 1404 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1405 : 				sp[0] = core->intToAtom(core->integer(lhs) & core->integer(rhs));

	mov	edx, DWORD PTR _rhs$39982[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39981[ebp]
	push	eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	and	esi, eax
	push	esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_bitor$39985:

; 1406 : 				restore_dxns();
; 1407 : 				NEXT;
; 1408 : 			}
; 1409 : 
; 1410 :             INSTR(bitor) {
; 1411 : 				Atom lhs = sp[-1];

	mov	ecx, DWORD PTR [esi-4]

; 1412 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [esi]

; 1413 : 				sp--;
; 1414 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, eax
	mov	ebx, ecx
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39986[ebp], ecx
	mov	DWORD PTR _rhs$39987[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN259@interp

; 1415 : 					sp[0] = lhs | rhs;

	or	eax, ecx
	mov	DWORD PTR [esi], eax

; 1416 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN259@interp:

; 1417 : 				}
; 1418 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1419 :                 sp[0] = core->intToAtom(core->integer(lhs) | core->integer(rhs));

	mov	edx, DWORD PTR _rhs$39987[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39986[ebp]
	push	eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	or	esi, eax
	push	esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_bitxor$39990:

; 1420 : 				restore_dxns();
; 1421 :                 NEXT;
; 1422 : 			}
; 1423 : 
; 1424 :             INSTR(bitxor) {
; 1425 : 				Atom lhs = sp[-1];

	mov	ecx, DWORD PTR [esi-4]

; 1426 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [esi]

; 1427 : 				sp--;
; 1428 : 				if (IS_BOTH_INTEGER(lhs,rhs)) {

	mov	edx, eax
	mov	ebx, ecx
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$39991[ebp], ecx
	mov	DWORD PTR _rhs$39992[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN257@interp

; 1429 : 					sp[0] = (lhs ^ rhs) | kIntegerType;

	xor	eax, ecx
	or	eax, 6
	mov	DWORD PTR [esi], eax

; 1430 : 					NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN257@interp:

; 1431 : 				}
; 1432 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1433 : 				sp[0] = core->intToAtom(core->integer(lhs) ^ core->integer(rhs));

	mov	edx, DWORD PTR _rhs$39992[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _lhs$39991[ebp]
	push	eax
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	ecx, DWORD PTR _core$[ebp]
	xor	esi, eax
	push	esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_equals$39995:

; 1434 : 				restore_dxns();
; 1435 :                 NEXT;
; 1436 : 			}
; 1437 : 
; 1438 :             INSTR(equals) {
; 1439 : 				// OPTIMIZEME?
; 1440 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax

; 1441 : 				sp[-1] = core->eq(sp[-1], sp[0]);

	mov	eax, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 4
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edx
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?eq@AvmCore@avmplus@@QAEHHH@Z		; avmplus::AvmCore::eq

; 2014 : 
; 2015 : 				*(sp -= argc) = tempAtom;

	mov	DWORD PTR [esi], eax

; 2016 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _sp$[ebp], esi

; 2017 : 				NEXT;

	jmp	$LN421@interp
$L_strictequals$39997:

; 1442 :                 sp--;
; 1443 : 				restore_dxns();
; 1444 :                 NEXT;
; 1445 : 			}
; 1446 : 
; 1447 :             INSTR(strictequals) {
; 1448 : 				// OPTIMIZEME?
; 1449 :                 sp[-1] = core->stricteq(sp[-1], sp[0]);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?stricteq@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::stricteq
	mov	DWORD PTR [esi-4], eax
	add	esi, -4					; fffffffcH

; 2118 : 				sp--;

	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_lookupswitch$39999:

; 1450 :                 sp--;
; 1451 :                 NEXT;
; 1452 : 			}
; 1453 : 				
; 1454 : 			INSTR(lookupswitch) {
; 1455 : #ifdef AVMPLUS_WORD_CODE
; 1456 : 				const uint32* base = pc-1;
; 1457 : 				uint32 index = AvmCore::integer_u(*(sp--));

	mov	eax, DWORD PTR [esi]
	mov	edx, eax
	and	edx, 7
	cmp	dl, 6
	lea	ebx, DWORD PTR [edi-4]
	mov	DWORD PTR _base$40000[ebp], ebx
	mov	DWORD PTR $T41455[ebp], eax
	jne	SHORT $LN602@interp
	sar	eax, 3
	jmp	SHORT $LN1493@interp
$LN602@interp:
	and	eax, -8					; fffffff8H
	fnstcw	WORD PTR tv7661[ebp]
	fld	QWORD PTR [eax]
	mov	DWORD PTR _obj$41451[ebp], eax
	movzx	eax, WORD PTR tv7661[ebp]
	fst	QWORD PTR $T41444[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv7658[ebp], eax
	fldcw	WORD PTR tv7658[ebp]
	fistp	QWORD PTR tv7656[ebp]
	mov	eax, DWORD PTR tv7656[ebp]
	fldcw	WORD PTR tv7661[ebp]
$LN1493@interp:

; 1458 : 				uint32 default_offset = S24ARG;

	mov	edx, DWORD PTR [edi]

; 1459 : 				uint32 case_count = U30ARG;

	mov	ecx, DWORD PTR [edi+4]
	add	edi, 4
	sub	esi, 4
	add	edi, 4

; 1460 : 				if (index <= case_count)

	cmp	eax, ecx
	mov	DWORD PTR _index$40001[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _default_offset$40002[ebp], edx
	mov	DWORD PTR _case_count$40004[ebp], ecx
	ja	SHORT $LN253@interp

; 1461 : 					pc = base + pc[index];

	mov	eax, DWORD PTR [edi+eax*4]
	lea	edi, DWORD PTR [ebx+eax*4]

; 1462 : 				else

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN253@interp:

; 1463 : 					pc = base + default_offset;

	lea	edi, DWORD PTR [ebx+edx*4]

; 1464 : #else
; 1465 : 				const byte* base = pc-1;
; 1466 : 				// safe to assume int since verifier checks for int
; 1467 : 				uint32 index = AvmCore::integer_u(*(sp--));
; 1468 : 				const byte* switch_pc = pc+3;
; 1469 : 				uint32 case_count = readU30(switch_pc) + 1;
; 1470 :                 pc = base+readS24( index < case_count ? (switch_pc + 3*index) : pc );
; 1471 : #endif
; 1472 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_iftrue$40008:

; 1473 : 			}
; 1474 : 
; 1475 :             INSTR(iftrue) {
; 1476 : 				Atom bval = *(sp--);

	mov	eax, DWORD PTR [esi]

; 1477 : 				if (IS_BOOLEAN(bval))

	mov	ecx, eax
	sub	esi, 4
	and	ecx, 7
	cmp	ecx, 5
	mov	DWORD PTR _bval$40009[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	je	SHORT $LN247@interp

; 1478 : 					;
; 1479 : 				else if (IS_INTEGER(bval))

	cmp	ecx, 6
	jne	SHORT $LN248@interp

; 1480 : 					bval = bval == kIntegerType ? falseAtom : trueAtom;

	xor	ecx, ecx
	cmp	eax, 6
	setne	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	eax, ecx

; 1481 : 				else

	jmp	SHORT $LN1494@interp
$LN248@interp:

; 1482 : 					bval = core->booleanAtom(bval);  // does not throw or change the XML namespace

	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?booleanAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::booleanAtom
$LN1494@interp:
	mov	DWORD PTR _bval$40009[ebp], eax
$LN247@interp:

; 1483 : 				int offset = S24ARG;

	mov	ecx, DWORD PTR [edi]
	add	edi, 4

; 1484 : 				if (bval & booleanNotMask)

	test	al, 8
	mov	DWORD PTR _offset$40014[ebp], ecx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LL420@interp

; 1485 : 				{
; 1486 : 					if (offset < 0) {

	test	ecx, ecx
	jge	SHORT $LN605@interp

; 1487 : 						SAVE_EXPC_S24;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1488 : 						core->branchCheck(env, interruptable, offset);

	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 8
	sar	eax, 2
	cmp	BYTE PTR _interruptable$[ebp], 0
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR $T41461[ebp], ecx
	je	SHORT $LN1412@interp
	cmp	DWORD PTR [ecx+220], 0
	je	SHORT $LN1412@interp
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	call	edx
$LN1412@interp:
	mov	esi, DWORD PTR _sp$[ebp]
$LN605@interp:

; 1489 : 					}
; 1490 :                     pc += offset;

	mov	eax, DWORD PTR _offset$40014[ebp]
	lea	edi, DWORD PTR [edi+eax*4]

; 1491 : 				}
; 1492 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_iffalse$40019:

; 1493 : 			}
; 1494 : 
; 1495 :             INSTR(iffalse) {
; 1496 : 				Atom bval = *(sp--);

	mov	eax, DWORD PTR [esi]

; 1497 : 				if (IS_BOOLEAN(bval))

	mov	ecx, eax
	sub	esi, 4
	and	ecx, 7
	cmp	ecx, 5
	mov	DWORD PTR _bval$40020[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	je	SHORT $LN240@interp

; 1498 : 					;
; 1499 : 				else if (IS_INTEGER(bval))

	cmp	ecx, 6
	jne	SHORT $LN241@interp

; 1500 : 					bval = bval == kIntegerType ? falseAtom : trueAtom;

	xor	ecx, ecx
	cmp	eax, 6
	setne	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	eax, ecx

; 1501 : 				else

	jmp	SHORT $LN1495@interp
$LN241@interp:

; 1502 : 					bval = core->booleanAtom(bval);  // does not throw or change the XML namespace

	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?booleanAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::booleanAtom
$LN1495@interp:
	mov	DWORD PTR _bval$40020[ebp], eax
$LN240@interp:

; 1503 : 				int offset = S24ARG;

	mov	ecx, DWORD PTR [edi]
	add	edi, 4

; 1504 : 				if (!(bval & booleanNotMask))

	test	al, 8
	mov	DWORD PTR _offset$40025[ebp], ecx
	mov	DWORD PTR _pc$[ebp], edi
	jne	$LL420@interp

; 1505 : 				{
; 1506 : 					if (offset < 0) {

	test	ecx, ecx
	jge	SHORT $LN609@interp

; 1507 : 						SAVE_EXPC_S24;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1508 : 						core->branchCheck(env, interruptable, offset);

	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 8
	sar	eax, 2
	cmp	BYTE PTR _interruptable$[ebp], 0
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR $T41467[ebp], ecx
	je	SHORT $LN1413@interp
	cmp	DWORD PTR [ecx+220], 0
	je	SHORT $LN1413@interp
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	call	edx
$LN1413@interp:
	mov	esi, DWORD PTR _sp$[ebp]
$LN609@interp:

; 1509 : 					}
; 1510 :                     pc += offset;

	mov	eax, DWORD PTR _offset$40025[ebp]
	lea	edi, DWORD PTR [edi+eax*4]

; 1511 : 				}
; 1512 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_ifeq$40030:

; 1513 : 			}
; 1514 : 
; 1515 : #define IFEQ(intcmp, comparator, truish) \
; 1516 : 	do { \
; 1517 : 		SAVE_EXPC; \
; 1518 : 		Atom lhs = sp[-1], rhs=sp[0]; \
; 1519 : 		bool result; \
; 1520 : 		if (IS_BOTH_INTEGER(lhs, rhs)) \
; 1521 : 			result = lhs intcmp rhs; \
; 1522 : 		else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1523 : 			result = DOUBLE_VALUE(lhs) intcmp DOUBLE_VALUE(rhs); \
; 1524 : 		else \
; 1525 : 			result = core->comparator(lhs, rhs) == truish; \
; 1526 : 		sp -= 2; \
; 1527 : 		int offset = S24ARG; \
; 1528 : 		if (result) \
; 1529 : 		{ \
; 1530 : 			if (offset < 0) \
; 1531 : 				core->branchCheck(env, interruptable, offset); \
; 1532 : 			pc += offset; \
; 1533 : 		} \
; 1534 : 		restore_dxns(); \
; 1535 : 	} while(0)
; 1536 : 	
; 1537 : 		   INSTR(ifeq) {
; 1538 : 				IFEQ(==, eq, trueAtom);

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi-4]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40034[ebp], eax
	mov	DWORD PTR _rhs$40035[ebp], ecx
	jne	SHORT $LN233@interp
	mov	ebx, DWORD PTR [edi]
	cmp	eax, ecx
	sete	al
	mov	BYTE PTR _result$40036[ebp], al
	mov	DWORD PTR _offset$40043[ebp], ebx

; 1539 :                 NEXT;

	jmp	$LN1532@interp
$LN233@interp:

; 1513 : 			}
; 1514 : 
; 1515 : #define IFEQ(intcmp, comparator, truish) \
; 1516 : 	do { \
; 1517 : 		SAVE_EXPC; \
; 1518 : 		Atom lhs = sp[-1], rhs=sp[0]; \
; 1519 : 		bool result; \
; 1520 : 		if (IS_BOTH_INTEGER(lhs, rhs)) \
; 1521 : 			result = lhs intcmp rhs; \
; 1522 : 		else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1523 : 			result = DOUBLE_VALUE(lhs) intcmp DOUBLE_VALUE(rhs); \
; 1524 : 		else \
; 1525 : 			result = core->comparator(lhs, rhs) == truish; \
; 1526 : 		sp -= 2; \
; 1527 : 		int offset = S24ARG; \
; 1528 : 		if (result) \
; 1529 : 		{ \
; 1530 : 			if (offset < 0) \
; 1531 : 				core->branchCheck(env, interruptable, offset); \
; 1532 : 			pc += offset; \
; 1533 : 		} \
; 1534 : 		restore_dxns(); \
; 1535 : 	} while(0)
; 1536 : 	
; 1537 : 		   INSTR(ifeq) {
; 1538 : 				IFEQ(==, eq, trueAtom);

	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN231@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN458@interp
	mov	ebx, DWORD PTR [edi]
	mov	al, 1
	mov	BYTE PTR _result$40036[ebp], al
	mov	DWORD PTR _offset$40043[ebp], ebx

; 1539 :                 NEXT;

	jmp	$LN1532@interp
$LN458@interp:

; 1513 : 			}
; 1514 : 
; 1515 : #define IFEQ(intcmp, comparator, truish) \
; 1516 : 	do { \
; 1517 : 		SAVE_EXPC; \
; 1518 : 		Atom lhs = sp[-1], rhs=sp[0]; \
; 1519 : 		bool result; \
; 1520 : 		if (IS_BOTH_INTEGER(lhs, rhs)) \
; 1521 : 			result = lhs intcmp rhs; \
; 1522 : 		else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1523 : 			result = DOUBLE_VALUE(lhs) intcmp DOUBLE_VALUE(rhs); \
; 1524 : 		else \
; 1525 : 			result = core->comparator(lhs, rhs) == truish; \
; 1526 : 		sp -= 2; \
; 1527 : 		int offset = S24ARG; \
; 1528 : 		if (result) \
; 1529 : 		{ \
; 1530 : 			if (offset < 0) \
; 1531 : 				core->branchCheck(env, interruptable, offset); \
; 1532 : 			pc += offset; \
; 1533 : 		} \
; 1534 : 		restore_dxns(); \
; 1535 : 	} while(0)
; 1536 : 	
; 1537 : 		   INSTR(ifeq) {
; 1538 : 				IFEQ(==, eq, trueAtom);

	mov	ebx, DWORD PTR [edi]
	xor	al, al
	mov	BYTE PTR _result$40036[ebp], al
	mov	DWORD PTR _offset$40043[ebp], ebx

; 1539 :                 NEXT;

	jmp	$LN1532@interp
$LN231@interp:

; 1513 : 			}
; 1514 : 
; 1515 : #define IFEQ(intcmp, comparator, truish) \
; 1516 : 	do { \
; 1517 : 		SAVE_EXPC; \
; 1518 : 		Atom lhs = sp[-1], rhs=sp[0]; \
; 1519 : 		bool result; \
; 1520 : 		if (IS_BOTH_INTEGER(lhs, rhs)) \
; 1521 : 			result = lhs intcmp rhs; \
; 1522 : 		else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1523 : 			result = DOUBLE_VALUE(lhs) intcmp DOUBLE_VALUE(rhs); \
; 1524 : 		else \
; 1525 : 			result = core->comparator(lhs, rhs) == truish; \
; 1526 : 		sp -= 2; \
; 1527 : 		int offset = S24ARG; \
; 1528 : 		if (result) \
; 1529 : 		{ \
; 1530 : 			if (offset < 0) \
; 1531 : 				core->branchCheck(env, interruptable, offset); \
; 1532 : 			pc += offset; \
; 1533 : 		} \
; 1534 : 		restore_dxns(); \
; 1535 : 	} while(0)
; 1536 : 	
; 1537 : 		   INSTR(ifeq) {
; 1538 : 				IFEQ(==, eq, trueAtom);

	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?eq@AvmCore@avmplus@@QAEHHH@Z		; avmplus::AvmCore::eq
	mov	ebx, DWORD PTR [edi]
	cmp	eax, 13					; 0000000dH
	sete	al
	mov	BYTE PTR _result$40036[ebp], al
	mov	DWORD PTR _offset$40043[ebp], ebx

; 1539 :                 NEXT;

	jmp	$LN1532@interp
$L_ifne$40048:

; 1540 : 			}
; 1541 : 					
; 1542 : 			INSTR(ifne) {
; 1543 : 				IFEQ(!=, eq, falseAtom);

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi-4]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40052[ebp], eax
	mov	DWORD PTR _rhs$40053[ebp], ecx
	jne	SHORT $LN223@interp
	mov	ebx, DWORD PTR [edi]
	cmp	eax, ecx
	setne	al
	mov	BYTE PTR _result$40054[ebp], al
	mov	DWORD PTR _offset$40061[ebp], ebx

; 1544 :                 NEXT;

	jmp	$LN1532@interp
$LN223@interp:

; 1540 : 			}
; 1541 : 					
; 1542 : 			INSTR(ifne) {
; 1543 : 				IFEQ(!=, eq, falseAtom);

	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN221@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN460@interp
	mov	ebx, DWORD PTR [edi]
	mov	al, 1
	mov	BYTE PTR _result$40054[ebp], al
	mov	DWORD PTR _offset$40061[ebp], ebx

; 1544 :                 NEXT;

	jmp	$LN1532@interp
$LN460@interp:

; 1540 : 			}
; 1541 : 					
; 1542 : 			INSTR(ifne) {
; 1543 : 				IFEQ(!=, eq, falseAtom);

	mov	ebx, DWORD PTR [edi]
	xor	al, al
	mov	BYTE PTR _result$40054[ebp], al
	mov	DWORD PTR _offset$40061[ebp], ebx

; 1544 :                 NEXT;

	jmp	$LN1532@interp
$LN221@interp:

; 1540 : 			}
; 1541 : 					
; 1542 : 			INSTR(ifne) {
; 1543 : 				IFEQ(!=, eq, falseAtom);

	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?eq@AvmCore@avmplus@@QAEHHH@Z		; avmplus::AvmCore::eq
	mov	ebx, DWORD PTR [edi]
	cmp	eax, 5
	sete	al
	mov	BYTE PTR _result$40054[ebp], al
	mov	DWORD PTR _offset$40061[ebp], ebx

; 1544 :                 NEXT;

	jmp	$LN1532@interp
$L_ifstricteq$40066:

; 1545 : 			}
; 1546 : 
; 1547 : 		    INSTR(ifstricteq) {
; 1548 : 				IFEQ(==, stricteq, trueAtom);

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi-4]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40070[ebp], eax
	mov	DWORD PTR _rhs$40071[ebp], ecx
	jne	SHORT $LN213@interp
	mov	ebx, DWORD PTR [edi]
	cmp	eax, ecx
	sete	al
	mov	BYTE PTR _result$40072[ebp], al
	mov	DWORD PTR _offset$40079[ebp], ebx

; 1549 : 				NEXT;

	jmp	$LN1532@interp
$LN213@interp:

; 1545 : 			}
; 1546 : 
; 1547 : 		    INSTR(ifstricteq) {
; 1548 : 				IFEQ(==, stricteq, trueAtom);

	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN211@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN462@interp
	mov	ebx, DWORD PTR [edi]
	mov	al, 1
	mov	BYTE PTR _result$40072[ebp], al
	mov	DWORD PTR _offset$40079[ebp], ebx

; 1549 : 				NEXT;

	jmp	$LN1532@interp
$LN462@interp:

; 1545 : 			}
; 1546 : 
; 1547 : 		    INSTR(ifstricteq) {
; 1548 : 				IFEQ(==, stricteq, trueAtom);

	mov	ebx, DWORD PTR [edi]
	xor	al, al
	mov	BYTE PTR _result$40072[ebp], al
	mov	DWORD PTR _offset$40079[ebp], ebx

; 1549 : 				NEXT;

	jmp	$LN1532@interp
$LN211@interp:

; 1545 : 			}
; 1546 : 
; 1547 : 		    INSTR(ifstricteq) {
; 1548 : 				IFEQ(==, stricteq, trueAtom);

	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?stricteq@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::stricteq
	mov	ebx, DWORD PTR [edi]
	cmp	eax, 13					; 0000000dH
	sete	al
	mov	BYTE PTR _result$40072[ebp], al
	mov	DWORD PTR _offset$40079[ebp], ebx

; 1549 : 				NEXT;

	jmp	SHORT $LN1532@interp
$L_ifstrictne$40084:

; 1550 : 			}
; 1551 : 
; 1552 : 			INSTR(ifstrictne) {
; 1553 : 				IFEQ(!=, stricteq, falseAtom);

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi-4]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40088[ebp], eax
	mov	DWORD PTR _rhs$40089[ebp], ecx
	jne	SHORT $LN203@interp
	cmp	eax, ecx
	setne	al
	jmp	SHORT $LN1501@interp
$LN203@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN201@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN464@interp
	mov	al, 1
	jmp	SHORT $LN1501@interp
$LN464@interp:
	xor	al, al
	jmp	SHORT $LN1501@interp
$LN201@interp:
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?stricteq@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::stricteq
	cmp	eax, 5
	sete	al
$LN1501@interp:
	mov	ebx, DWORD PTR [edi]
	mov	BYTE PTR _result$40090[ebp], al
	mov	DWORD PTR _offset$40097[ebp], ebx
$LN1532@interp:
	sub	esi, 8
	add	edi, 4
	test	al, al
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1479@interp
	test	ebx, ebx
	jge	SHORT $LN198@interp
	mov	eax, DWORD PTR _interruptable$[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	push	ebx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?branchCheck@AvmCore@avmplus@@QAEXPAVMethodEnv@2@_NH@Z ; avmplus::AvmCore::branchCheck
$LN198@interp:

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_iflt$40102:

; 1554 : 				NEXT;
; 1555 : 			}
; 1556 : 
; 1557 : #define IFCMP(numeric_cmp, generic_cmp) \
; 1558 : 		SAVE_EXPC; \
; 1559 : 		Atom lhs = sp[-1], rhs=sp[0]; \
; 1560 : 		sp -= 2; \
; 1561 : 		bool result; \
; 1562 : 		if (IS_BOTH_INTEGER(lhs, rhs)) \
; 1563 : 			result = lhs numeric_cmp rhs; \
; 1564 : 		else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1565 : 			result = DOUBLE_VALUE(lhs) numeric_cmp DOUBLE_VALUE(rhs); \
; 1566 : 		else \
; 1567 : 			result = generic_cmp; \
; 1568 : 		int offset = S24ARG; \
; 1569 : 		if (result) \
; 1570 : 		{ \
; 1571 : 			if (offset < 0) \
; 1572 : 				core->branchCheck(env, interruptable, offset); \
; 1573 : 			pc += offset; \
; 1574 : 		} \
; 1575 : 		restore_dxns();
; 1576 : 
; 1577 : 			INSTR(iflt) {
; 1578 : 				IFCMP(<, core->compare(lhs,rhs) == trueAtom);

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi-4]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40103[ebp], eax
	mov	DWORD PTR _rhs$40104[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN196@interp
	cmp	eax, ecx
	setl	al
	jmp	SHORT $LN1502@interp
$LN196@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN194@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN466@interp
	mov	al, 1
	jmp	SHORT $LN1502@interp
$LN466@interp:
	xor	al, al
	jmp	SHORT $LN1502@interp
$LN194@interp:
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 13					; 0000000dH
	sete	al
$LN1502@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40105[ebp], al
	mov	DWORD PTR _offset$40112[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41473[ebp], ecx
	jmp	$LN1531@interp
$L_ifnlt$40117:

; 1579 :                 NEXT;
; 1580 : 			}
; 1581 : 
; 1582 : 			INSTR(ifnlt) {
; 1583 : 				IFCMP(>=, core->compare(lhs, rhs) != trueAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40118[ebp], eax
	mov	DWORD PTR _rhs$40119[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN189@interp
	cmp	eax, ecx
	setge	al
	jmp	SHORT $LN1503@interp
$LN189@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN187@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN468@interp
	mov	al, 1
	jmp	SHORT $LN1503@interp
$LN468@interp:
	xor	al, al
	jmp	SHORT $LN1503@interp
$LN187@interp:
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 13					; 0000000dH
	setne	al
$LN1503@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40120[ebp], al
	mov	DWORD PTR _offset$40127[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41479[ebp], ecx
	jmp	$LN1531@interp
$L_ifle$40132:

; 1584 :                 NEXT;
; 1585 : 			}
; 1586 : 
; 1587 : 			INSTR(ifle) {
; 1588 : 				IFCMP(<=, core->compare(rhs, lhs) == falseAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40133[ebp], eax
	mov	DWORD PTR _rhs$40134[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN182@interp
	cmp	eax, ecx
	setle	al
	jmp	SHORT $LN1504@interp
$LN182@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN180@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN470@interp
	mov	al, 1
	jmp	SHORT $LN1504@interp
$LN470@interp:
	xor	al, al
	jmp	SHORT $LN1504@interp
$LN180@interp:
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 5
	sete	al
$LN1504@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40135[ebp], al
	mov	DWORD PTR _offset$40142[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41485[ebp], ecx
	jmp	$LN1531@interp
$L_ifnle$40147:

; 1589 :                 NEXT;
; 1590 : 			}
; 1591 : 
; 1592 : 			INSTR(ifnle) {
; 1593 : 				IFCMP(>, core->compare(rhs, lhs) != falseAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40148[ebp], eax
	mov	DWORD PTR _rhs$40149[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN175@interp
	cmp	eax, ecx
	setg	al
	jmp	SHORT $LN1505@interp
$LN175@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN173@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN472@interp
	mov	al, 1
	jmp	SHORT $LN1505@interp
$LN472@interp:
	xor	al, al
	jmp	SHORT $LN1505@interp
$LN173@interp:
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 5
	setne	al
$LN1505@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40150[ebp], al
	mov	DWORD PTR _offset$40157[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41491[ebp], ecx
	jmp	$LN1531@interp
$L_ifgt$40162:

; 1594 :                 NEXT;
; 1595 : 			}
; 1596 : 
; 1597 : 			INSTR(ifgt) {
; 1598 : 				IFCMP(>, core->compare(rhs, lhs) == trueAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40163[ebp], eax
	mov	DWORD PTR _rhs$40164[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN168@interp
	cmp	eax, ecx
	setg	al
	jmp	SHORT $LN1506@interp
$LN168@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN166@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN474@interp
	mov	al, 1
	jmp	SHORT $LN1506@interp
$LN474@interp:
	xor	al, al
	jmp	SHORT $LN1506@interp
$LN166@interp:
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 13					; 0000000dH
	sete	al
$LN1506@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40165[ebp], al
	mov	DWORD PTR _offset$40172[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41497[ebp], ecx
	jmp	$LN1531@interp
$L_ifngt$40177:

; 1599 :                 NEXT;
; 1600 : 			}
; 1601 : 
; 1602 : 			INSTR(ifngt) {
; 1603 : 				IFCMP(<=, core->compare(rhs, lhs) != trueAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40178[ebp], eax
	mov	DWORD PTR _rhs$40179[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN161@interp
	cmp	eax, ecx
	setle	al
	jmp	SHORT $LN1507@interp
$LN161@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN159@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN476@interp
	mov	al, 1
	jmp	SHORT $LN1507@interp
$LN476@interp:
	xor	al, al
	jmp	SHORT $LN1507@interp
$LN159@interp:
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 13					; 0000000dH
	setne	al
$LN1507@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40180[ebp], al
	mov	DWORD PTR _offset$40187[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41503[ebp], ecx
	jmp	$LN1531@interp
$L_ifge$40192:

; 1604 :                 NEXT;
; 1605 : 			}
; 1606 : 			
; 1607 : 			INSTR(ifge) {
; 1608 : 				IFCMP(>=, core->compare(lhs, rhs) == falseAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40193[ebp], eax
	mov	DWORD PTR _rhs$40194[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN154@interp
	cmp	eax, ecx
	setge	al
	jmp	SHORT $LN1508@interp
$LN154@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN152@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN478@interp
	mov	al, 1
	jmp	SHORT $LN1508@interp
$LN478@interp:
	xor	al, al
	jmp	SHORT $LN1508@interp
$LN152@interp:
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 5
	sete	al
$LN1508@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40195[ebp], al
	mov	DWORD PTR _offset$40202[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	$LN641@interp
	mov	DWORD PTR $T41509[ebp], ecx
	jmp	$LN1531@interp
$L_ifnge$40207:

; 1609 :                 NEXT;
; 1610 : 			}
; 1611 : 
; 1612 : 			INSTR(ifnge) {
; 1613 : 				IFCMP(<, core->compare(lhs, rhs) != falseAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [esi-4]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	sub	esi, 8
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40208[ebp], eax
	mov	DWORD PTR _rhs$40209[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN147@interp
	cmp	eax, ecx
	setl	al
	jmp	SHORT $LN1509@interp
$LN147@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN145@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN480@interp
	mov	al, 1
	jmp	SHORT $LN1509@interp
$LN480@interp:
	xor	al, al
	jmp	SHORT $LN1509@interp
$LN145@interp:
	push	ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	cmp	eax, 5
	setne	al
$LN1509@interp:
	mov	ebx, DWORD PTR [edi]
	add	edi, 4
	test	al, al
	mov	BYTE PTR _result$40210[ebp], al
	mov	DWORD PTR _offset$40217[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	je	$LN1429@interp
	test	ebx, ebx
	mov	ecx, DWORD PTR _core$[ebp]
	jge	SHORT $LN641@interp
	mov	DWORD PTR $T41515[ebp], ecx
$LN1531@interp:
	cmp	BYTE PTR _interruptable$[ebp], 0
	je	SHORT $LN641@interp
	cmp	DWORD PTR [ecx+220], 0
	je	SHORT $LN641@interp
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	call	eax
	mov	ecx, DWORD PTR _core$[ebp]
$LN641@interp:
	lea	edi, DWORD PTR [edi+ebx*4]
	jmp	$LN421@interp
$L_lessthan$40222:

; 1614 :                 NEXT;
; 1615 : 			}
; 1616 : 
; 1617 : #define CMP(numeric_cmp, generic_cmp) \
; 1618 : 	Atom lhs=sp[-1], rhs=sp[0]; \
; 1619 : 	sp--; \
; 1620 : 	if (IS_BOTH_INTEGER(lhs,rhs)) \
; 1621 : 		sp[0] = lhs numeric_cmp rhs ? trueAtom : falseAtom; \
; 1622 : 	else if (IS_BOTH_DOUBLE(lhs, rhs)) \
; 1623 : 		sp[0] = DOUBLE_VALUE(lhs) numeric_cmp DOUBLE_VALUE(rhs) ? trueAtom : falseAtom; \
; 1624 : 	else { \
; 1625 : 		SAVE_EXPC; \
; 1626 : 		sp[0] = generic_cmp ? trueAtom : falseAtom; \
; 1627 : 		restore_dxns(); \
; 1628 : 	}
; 1629 : 					
; 1630 :             INSTR(lessthan) {
; 1631 : 				CMP(<, core->compare(lhs, rhs) == trueAtom);

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40223[ebp], eax
	mov	DWORD PTR _rhs$40224[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN140@interp
	xor	edx, edx
	cmp	eax, ecx
	setl	dl
	lea	edx, DWORD PTR [edx*8+5]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN140@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN138@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN482@interp
	mov	eax, 13					; 0000000dH
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN482@interp:
	mov	eax, 5
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN138@interp:
	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _rhs$40224[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _lhs$40223[ebp]
	sub	ecx, 4
	sar	ecx, 2
	push	edx
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare

; 1642 :                 NEXT;
; 1643 : 			}
; 1644 : 					
; 1645 :             INSTR(greaterequals) {
; 1646 : 				CMP(>=, core->compare(lhs, rhs) == falseAtom);

	mov	esi, DWORD PTR _sp$[ebp]
	xor	ecx, ecx
	cmp	eax, 13					; 0000000dH

; 2327 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	sete	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_lessequals$40232:

; 1632 :                 NEXT;
; 1633 : 			}
; 1634 : 
; 1635 :             INSTR(lessequals) {
; 1636 : 				CMP(<=, core->compare(rhs,lhs) == falseAtom);

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40233[ebp], eax
	mov	DWORD PTR _rhs$40234[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN135@interp
	xor	edx, edx
	cmp	eax, ecx
	setle	dl
	lea	edx, DWORD PTR [edx*8+5]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN135@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN133@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	jne	$LN482@interp
	mov	eax, 13					; 0000000dH
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN133@interp:
	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _lhs$40233[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _rhs$40234[ebp]

; 1637 :                 NEXT;

	jmp	$LN1533@interp
$L_greaterthan$40242:

; 1638 : 			}
; 1639 : 
; 1640 :             INSTR(greaterthan) {
; 1641 : 				CMP(>, core->compare(rhs, lhs) == trueAtom);

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40243[ebp], eax
	mov	DWORD PTR _rhs$40244[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN130@interp
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	lea	edx, DWORD PTR [edx*8+5]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN130@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN128@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	$LN482@interp
	mov	eax, 13					; 0000000dH
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN128@interp:
	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _lhs$40243[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _rhs$40244[ebp]
	sub	ecx, 4
	sar	ecx, 2
	push	edx
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	mov	esi, DWORD PTR _sp$[ebp]
	xor	ecx, ecx
	cmp	eax, 13					; 0000000dH

; 2327 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	sete	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_greaterequals$40252:

; 1642 :                 NEXT;
; 1643 : 			}
; 1644 : 					
; 1645 :             INSTR(greaterequals) {
; 1646 : 				CMP(>=, core->compare(lhs, rhs) == falseAtom);

	mov	eax, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	ebx, eax
	xor	edx, -2					; fffffffeH
	xor	ebx, -2					; fffffffeH
	add	esi, -4					; fffffffcH
	or	edx, ebx
	test	dl, 7
	mov	DWORD PTR _lhs$40253[ebp], eax
	mov	DWORD PTR _rhs$40254[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN125@interp
	xor	edx, edx
	cmp	eax, ecx
	setge	dl
	lea	edx, DWORD PTR [edx*8+5]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN125@interp:
	mov	edx, ecx
	not	edx
	or	edx, eax
	test	dl, 7
	jne	SHORT $LN123@interp
	xor	ecx, 7
	fld	QWORD PTR [ecx]
	xor	eax, 7
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN482@interp
	mov	eax, 13					; 0000000dH
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN123@interp:
	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _rhs$40254[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _lhs$40253[ebp]
$LN1533@interp:
	sub	ecx, 4
	sar	ecx, 2
	push	edx
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?compare@AvmCore@avmplus@@QAEHHH@Z	; avmplus::AvmCore::compare
	mov	esi, DWORD PTR _sp$[ebp]
	xor	ecx, ecx
	cmp	eax, 5

; 2327 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	sete	cl
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_newobject$40262:

; 1647 :                 NEXT;
; 1648 : 			}
; 1649 : 					
; 1650 :             INSTR(newobject) {
; 1651 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1652 :                 int32 argc = U30ARG;

	mov	ebx, DWORD PTR [edi]

; 1653 :                 Atom tempAtom = env->op_newobject(sp, argc)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _env$[ebp]
	sub	edx, 4
	push	ebx
	sar	edx, 2
	add	edi, 4
	push	esi
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _argc$40263[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	call	?op_newobject@MethodEnv@avmplus@@QBEPAVScriptObject@2@PAHH@Z ; avmplus::MethodEnv::op_newobject

; 1654 :                 *(sp -= 2*argc-1) = tempAtom;

	lea	ecx, DWORD PTR [ebx*8]
	mov	edx, 4
	mov	DWORD PTR $T41519[ebp], eax
	or	eax, 1
	sub	edx, ecx

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	add	esi, edx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR _tempAtom$40264[ebp], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_newarray$40266:

; 1655 : 				restore_dxns();
; 1656 :                 NEXT;
; 1657 : 			}
; 1658 : 
; 1659 :             INSTR(newarray) {
; 1660 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1661 :                 int32 argc = U30ARG;
; 1662 :                 Atom tempAtom = toplevel->arrayClass->newarray(sp-argc+1, argc)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax*4]
	sub	esi, edx
	push	eax
	add	esi, 4
	add	edi, 4
	push	esi
	mov	DWORD PTR _argc$40267[ebp], eax
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR $T41523[ebp], ecx
	call	?newarray@ArrayClass@avmplus@@QAEPAVArrayObject@2@PAHH@Z ; avmplus::ArrayClass::newarray

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR $T41527[ebp], eax
	or	eax, 1
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR _tempAtom$40268[ebp], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getlex$40270:

; 1663 :                 *(sp -= argc-1) = tempAtom;
; 1664 : 				restore_dxns();
; 1665 :                 NEXT;
; 1666 : 			}
; 1667 : 
; 1668 : 			INSTR(getlex) {
; 1669 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1670 : 				// findpropstrict + getproperty
; 1671 : 				// stack in:  -
; 1672 : 				// stack out: value
; 1673 : 				Multiname name;

	lea	ecx, DWORD PTR _name$40271[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1674 : 				pool->parseMultiname(name, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41558[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41547[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40271[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1675 : 
; 1676 : 				// only non-runtime names are allowed.  but this still includes
; 1677 : 				// wildcard and attribute names.
; 1678 : 				Atom obj = env->findproperty(scope, scopeBase, scopeDepth, &name, true, withBase);

	mov	eax, DWORD PTR _withBase$[ebp]
	mov	edx, DWORD PTR _scopeDepth$[ebp]
	push	eax
	mov	eax, DWORD PTR _scopeBase$[ebp]
	push	1
	lea	ecx, DWORD PTR _name$40271[ebp]
	push	ecx
	mov	ecx, DWORD PTR _scope$[ebp]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	call	?findproperty@MethodEnv@avmplus@@QAEHPAVScopeChain@2@PAHHPAVMultiname@2@_N1@Z ; avmplus::MethodEnv::findproperty

; 1679 : 				*(++sp) = toplevel->getproperty(obj, &name, toplevel->toVTable(obj));

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	mov	ebx, eax
	add	esi, 4
	push	ebx
	mov	DWORD PTR _obj$40272[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	lea	edx, DWORD PTR _name$40271[ebp]
	push	edx
	push	ebx
	call	?getproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@PAVVTable@2@@Z ; avmplus::Toplevel::getproperty

; 1680 : 				restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1681 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _name$40271[ebp], eax
	mov	DWORD PTR _name$40271[ebp+4], eax
	mov	DWORD PTR _name$40271[ebp+8], eax
	mov	DWORD PTR _name$40271[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getproperty$40274:

; 1682 : 			}	
; 1683 : 
; 1684 : 			// get a property using a multiname ref
; 1685 :             INSTR(getproperty) {
; 1686 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1687 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40275[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1688 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41592[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41581[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40275[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1689 : 				if (!multiname.isRuntime())

	mov	al, BYTE PTR _multiname$40275[ebp]
	add	edi, 4
	test	al, 12					; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN117@interp

; 1690 : 				{
; 1691 : 					sp[0] = toplevel->getproperty(sp[0], &multiname, toplevel->toVTable(sp[0]));

	mov	esi, DWORD PTR _sp$[ebp]

; 1692 : 				}
; 1693 : 				else

	jmp	$LN1510@interp
$LN117@interp:

; 1694 : 				{
; 1695 : 					if(multiname.isRtns() || !core->isDictionaryLookup(*sp, *(sp-1))) {

	test	al, 4
	mov	ebx, DWORD PTR _sp$[ebp]
	jne	SHORT $LN114@interp
	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx-4]
	mov	DWORD PTR $T41624[ebp], ecx
	mov	ecx, eax
	lea	esi, DWORD PTR [ebx-4]
	and	cl, 7
	cmp	cl, 1
	mov	DWORD PTR $T41626[ebp], edx
	mov	DWORD PTR $T41625[ebp], eax
	jne	SHORT $LN691@interp
	cmp	eax, 4
	jb	SHORT $LN691@interp
	mov	eax, 1
	jmp	SHORT $LN692@interp
$LN691@interp:
	xor	eax, eax
$LN692@interp:
	test	al, al
	je	SHORT $LN687@interp
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?isDictionary@AvmCore@avmplus@@QAE_NH@Z	; avmplus::AvmCore::isDictionary
	test	al, al
	je	SHORT $LN687@interp
	mov	eax, 1
	jmp	SHORT $LN688@interp
$LN687@interp:
	xor	eax, eax
$LN688@interp:
	test	al, al
	je	SHORT $LN114@interp

; 1698 : 					} else {
; 1699 : 						Atom key = *(sp--);
; 1700 : 						sp[0] = AvmCore::atomToScriptObject(sp[0])->getAtomProperty(key);

	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [ebx]
	and	ecx, -8					; fffffff8H
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	push	ebx
	mov	DWORD PTR _key$40281[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	call	eax
	jmp	SHORT $LN1511@interp
$LN114@interp:

; 1696 : 						sp = initMultiname(env, multiname, sp);

	mov	edx, DWORD PTR _env$[ebp]
	push	0
	push	ebx
	lea	ecx, DWORD PTR _multiname$40275[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	mov	esi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sp$[ebp], esi
$LN1510@interp:

; 1697 : 						*sp = toplevel->getproperty(*sp, &multiname, toplevel->toVTable(*sp));

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR _toplevel$[ebp]
	push	eax
	mov	ecx, ebx
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	edx, DWORD PTR [esi]
	push	eax
	lea	ecx, DWORD PTR _multiname$40275[ebp]
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?getproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@PAVVTable@2@@Z ; avmplus::Toplevel::getproperty
$LN1511@interp:

; 1701 : 					}
; 1702 : 				}
; 1703 : 				restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1704 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40275[ebp], eax
	mov	DWORD PTR _multiname$40275[ebp+4], eax
	mov	DWORD PTR _multiname$40275[ebp+8], eax
	mov	DWORD PTR _multiname$40275[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setproperty$40283:

; 1705 : 			}
; 1706 : 
; 1707 : 			// set a property using a multiname ref
; 1708 : 			INSTR(setproperty) {
; 1709 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1710 : 				Multiname multiname; 

	lea	ecx, DWORD PTR _multiname$40284[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1711 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41666[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41655[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40284[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1712 : 				Atom value = *(sp--);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [esi]

; 1713 : 				if (!multiname.isRuntime())

	mov	al, BYTE PTR _multiname$40284[ebp]
	add	edi, 4
	sub	esi, 4
	test	al, 12					; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _value$40285[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN111@interp

; 1714 : 				{
; 1715 : 					Atom obj = *(sp--);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _obj$40287[ebp], ebx

; 1716 : 					toplevel->setproperty(obj, &multiname, value, toplevel->toVTable(obj));
; 1717 : 				}
; 1718 : 				else

	jmp	$LN1512@interp
$LN111@interp:

; 1719 : 				{
; 1720 : 					if(multiname.isRtns() || !core->isDictionaryLookup(*sp, *(sp-1))) {

	test	al, 4
	jne	SHORT $LN108@interp
	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi-4]
	mov	DWORD PTR $T41698[ebp], ecx
	mov	ecx, eax
	and	cl, 7
	cmp	cl, 1
	mov	DWORD PTR $T41700[ebp], edx
	mov	DWORD PTR $T41699[ebp], eax
	jne	SHORT $LN726@interp
	cmp	eax, 4
	jb	SHORT $LN726@interp
	mov	eax, 1
	jmp	SHORT $LN727@interp
$LN726@interp:
	xor	eax, eax
$LN727@interp:
	test	al, al
	je	SHORT $LN722@interp
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?isDictionary@AvmCore@avmplus@@QAE_NH@Z	; avmplus::AvmCore::isDictionary
	test	al, al
	je	SHORT $LN722@interp
	mov	eax, 1
	jmp	SHORT $LN723@interp
$LN722@interp:
	xor	eax, eax
$LN723@interp:
	test	al, al
	je	SHORT $LN108@interp

; 1724 : 					} else {
; 1725 : 						Atom key = *(sp--);

	mov	eax, DWORD PTR [esi]

; 1726 : 						Atom obj = *(sp--);

	mov	ecx, DWORD PTR [esi-4]
	add	esi, -4					; fffffffcH
	mov	DWORD PTR _obj$40294[ebp], ecx

; 1727 : 						AvmCore::atomToScriptObject(obj)->setAtomProperty(key, value);

	and	ecx, -8					; fffffff8H
	mov	edx, DWORD PTR [ecx]
	push	ebx
	mov	DWORD PTR _key$40293[ebp], eax
	sub	esi, 4
	push	eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _sp$[ebp], esi
	call	eax
	jmp	SHORT $LN107@interp
$LN108@interp:

; 1721 : 						sp = initMultiname(env, multiname, sp);

	mov	edx, DWORD PTR _env$[ebp]
	push	0
	push	esi
	lea	ecx, DWORD PTR _multiname$40284[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	mov	esi, eax

; 1722 : 						Atom obj = *(sp--);

	mov	ebx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _obj$40291[ebp], ebx
$LN1512@interp:

; 1723 : 						toplevel->setproperty(obj, &multiname, value, toplevel->toVTable(obj));

	mov	ecx, DWORD PTR _toplevel$[ebp]
	sub	esi, 4
	push	ebx
	mov	DWORD PTR _sp$[ebp], esi
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	push	eax
	mov	eax, DWORD PTR _value$40285[ebp]
	push	eax
	lea	ecx, DWORD PTR _multiname$40284[ebp]
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	ebx
	call	?setproperty@Toplevel@avmplus@@QBEXHPAVMultiname@2@HPAVVTable@2@@Z ; avmplus::Toplevel::setproperty
$LN107@interp:

; 1728 : 					}
; 1729 : 				}
; 1730 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 1731 :                 NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40284[ebp], eax
	mov	DWORD PTR _multiname$40284[ebp+4], eax
	mov	DWORD PTR _multiname$40284[ebp+8], eax
	mov	DWORD PTR _multiname$40284[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_initproperty$40296:

; 1732 : 			}
; 1733 : 
; 1734 : 			INSTR(initproperty) {
; 1735 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 1736 : 				Multiname multiname; 

	lea	ecx, DWORD PTR _multiname$40297[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1737 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41740[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41729[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40297[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1738 : 				Atom value = *(sp--);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [esi]
	add	edi, 4
	sub	esi, 4

; 1739 : 				if (!multiname.isRuntime())

	test	BYTE PTR _multiname$40297[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _value$40298[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN105@interp

; 1740 : 				{
; 1741 : 					Atom obj = *(sp--);

	mov	eax, DWORD PTR [esi]

; 1742 : 					env->initproperty(obj, &multiname, value, toplevel->toVTable(obj));

	mov	ecx, DWORD PTR _toplevel$[ebp]
	sub	esi, 4
	push	eax
	mov	DWORD PTR _obj$40300[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	ecx, DWORD PTR _obj$40300[ebp]
	push	eax
	push	ebx
	lea	eax, DWORD PTR _multiname$40297[ebp]
	push	eax
	push	ecx

; 1743 : 				}
; 1744 : 				else

	jmp	SHORT $LN1513@interp
$LN105@interp:

; 1745 : 				{
; 1746 : 					sp = initMultiname(env, multiname, sp);

	mov	eax, DWORD PTR _env$[ebp]
	push	0
	push	esi
	lea	edx, DWORD PTR _multiname$40297[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname

; 1747 : 					Atom obj = *(sp--);
; 1748 : 					env->initproperty(obj, &multiname, value, toplevel->toVTable(obj));

	mov	ecx, DWORD PTR _toplevel$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	sub	esi, 4
	push	eax
	mov	DWORD PTR _obj$40302[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	edx, DWORD PTR _obj$40302[ebp]
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _multiname$40297[ebp]
	push	ecx
	push	edx
$LN1513@interp:
	mov	ecx, DWORD PTR _env$[ebp]
	call	?initproperty@MethodEnv@avmplus@@QBEXHPAVMultiname@2@HPAVVTable@2@@Z ; avmplus::MethodEnv::initproperty

; 1749 : 				}
; 1750 : 				restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1751 :                 NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40297[ebp], eax
	mov	DWORD PTR _multiname$40297[ebp+4], eax
	mov	DWORD PTR _multiname$40297[ebp+8], eax
	mov	DWORD PTR _multiname$40297[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getdescendants$40304:

; 1752 : 			}
; 1753 : 
; 1754 : 			INSTR(getdescendants) {
; 1755 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1756 : 				Multiname name;

	lea	ecx, DWORD PTR _name$40305[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1757 : 				pool->parseMultiname(name, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41777[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41766[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40305[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	add	edi, 4

; 1758 : 				if (!name.isRuntime())

	test	BYTE PTR _name$40305[ebp], 12		; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi

; 1759 : 				{
; 1760 : 					sp[0] = env->getdescendants(sp[0], &name);

	lea	eax, DWORD PTR _name$40305[ebp]
	jne	SHORT $LN102@interp
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]

; 1761 : 				}
; 1762 : 				else

	jmp	SHORT $LN1514@interp
$LN102@interp:

; 1763 : 				{
; 1764 : 					sp = initMultiname(env, name, sp);

	mov	edx, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR _env$[ebp]
	push	0
	push	edx
	push	eax
	push	ebx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1765 : 					sp[0] = env->getdescendants(sp[0], &name);

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR _name$40305[ebp]
	push	ecx
	mov	DWORD PTR _sp$[ebp], esi
	push	edx
	mov	ecx, ebx
$LN1514@interp:
	call	?getdescendants@MethodEnv@avmplus@@QAEHHPAVMultiname@2@@Z ; avmplus::MethodEnv::getdescendants

; 1766 : 				}
; 1767 : 				restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1768 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _name$40305[ebp], eax
	mov	DWORD PTR _name$40305[ebp+4], eax
	mov	DWORD PTR _name$40305[ebp+8], eax
	mov	DWORD PTR _name$40305[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_checkfilter$40309:

; 1769 : 			}
; 1770 : 
; 1771 : 			INSTR(checkfilter) {
; 1772 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1773 : 				env->checkfilter(sp[0]);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	?checkfilter@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::checkfilter

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_findpropstrict$40311:

; 1774 : 				restore_dxns();
; 1775 : 				NEXT;
; 1776 : 			}
; 1777 : 
; 1778 : 			// search the scope chain for a given property and return the object
; 1779 : 			// that contains it.  the next instruction will usually be getpropname
; 1780 : 			// or setpropname.
; 1781 :             INSTR(findpropstrict) {
; 1782 : 				// stack in:  [ns [name]]
; 1783 : 				// stack out: obj
; 1784 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 1785 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40312[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1786 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41814[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41803[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40312[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	add	edi, 4

; 1787 : 				if (multiname.isRuntime())
; 1788 : 					sp = initMultiname(env, multiname, sp);

	xor	ebx, ebx
	test	BYTE PTR _multiname$40312[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	je	SHORT $LN1430@interp
	mov	eax, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR _env$[ebp]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _multiname$40312[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax
	jmp	SHORT $LN98@interp
$LN1430@interp:
	mov	esi, DWORD PTR _sp$[ebp]
$LN98@interp:

; 1789 : 				*(++sp) = env->findproperty(scope, scopeBase, scopeDepth, &multiname, true, withBase);

	mov	eax, DWORD PTR _withBase$[ebp]
	mov	edx, DWORD PTR _scopeDepth$[ebp]
	push	eax
	mov	eax, DWORD PTR _scopeBase$[ebp]
	push	1
	lea	ecx, DWORD PTR _multiname$40312[ebp]
	push	ecx
	mov	ecx, DWORD PTR _scope$[ebp]
	push	edx
	push	eax
	add	esi, 4
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	call	?findproperty@MethodEnv@avmplus@@QAEHPAVScopeChain@2@PAHHPAVMultiname@2@_N1@Z ; avmplus::MethodEnv::findproperty
	mov	DWORD PTR [esi], eax

; 1790 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 1791 : 				NEXT;

	mov	DWORD PTR _multiname$40312[ebp], ebx
	mov	DWORD PTR _multiname$40312[ebp+4], ebx
	mov	DWORD PTR _multiname$40312[ebp+8], ebx
	mov	DWORD PTR _multiname$40312[ebp+12], ebx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_findproperty$40315:

; 1792 : 			}
; 1793 : 
; 1794 :             INSTR(findproperty) {
; 1795 : 				// stack in:  [ns [name]]
; 1796 : 				// stack out: obj
; 1797 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 1798 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40316[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1799 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41851[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41840[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40316[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	add	edi, 4

; 1800 : 				if (multiname.isRuntime())
; 1801 : 					sp = initMultiname(env, multiname, sp);

	xor	ebx, ebx
	test	BYTE PTR _multiname$40316[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	je	SHORT $LN1431@interp
	mov	eax, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR _env$[ebp]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _multiname$40316[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax
	jmp	SHORT $LN96@interp
$LN1431@interp:
	mov	esi, DWORD PTR _sp$[ebp]
$LN96@interp:

; 1802 : 				*(++sp) = env->findproperty(scope, scopeBase, scopeDepth, &multiname, false, withBase);

	mov	eax, DWORD PTR _withBase$[ebp]
	mov	edx, DWORD PTR _scopeDepth$[ebp]
	push	eax
	mov	eax, DWORD PTR _scopeBase$[ebp]
	push	ebx
	lea	ecx, DWORD PTR _multiname$40316[ebp]
	push	ecx
	mov	ecx, DWORD PTR _scope$[ebp]
	push	edx
	push	eax
	add	esi, 4
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	call	?findproperty@MethodEnv@avmplus@@QAEHPAVScopeChain@2@PAHHPAVMultiname@2@_N1@Z ; avmplus::MethodEnv::findproperty
	mov	DWORD PTR [esi], eax

; 1803 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 1804 : 				NEXT;

	mov	DWORD PTR _multiname$40316[ebp], ebx
	mov	DWORD PTR _multiname$40316[ebp+4], ebx
	mov	DWORD PTR _multiname$40316[ebp+8], ebx
	mov	DWORD PTR _multiname$40316[ebp+12], ebx
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_finddef$40319:

; 1805 : 			}
; 1806 : 
; 1807 : 			INSTR(finddef) {
; 1808 : 				// stack in: 
; 1809 : 				// stack out: obj
; 1810 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 1811 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40320[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1812 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41888[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41877[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40320[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1813 : 				*(++sp) = env->finddef(&multiname)->atom();

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _multiname$40320[ebp]
	add	edi, 4
	add	esi, 4
	push	eax
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _sp$[ebp], esi
	call	?finddef@MethodEnv@avmplus@@QBEPAVScriptObject@2@PAVMultiname@2@@Z ; avmplus::MethodEnv::finddef

; 1814 : 				restore_dxns();

	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR $T41892[ebp], eax
	or	eax, 1
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]

; 1815 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR [ecx+216], edx
	mov	DWORD PTR _multiname$40320[ebp], eax
	mov	DWORD PTR _multiname$40320[ebp+4], eax
	mov	DWORD PTR _multiname$40320[ebp+8], eax
	mov	DWORD PTR _multiname$40320[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_nextname$40322:

; 1816 : 			}
; 1817 : 
; 1818 : 			INSTR(nextname) {
; 1819 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax

; 1820 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]

; 1821 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]
	sub	ecx, 4

; 1822 : 				sp--;
; 1823 : 				// verifier checks for int
; 1824 : 				sp[0] = env->nextname(lhs, AvmCore::integer_i(rhs));

	mov	edx, eax
	sar	ecx, 2
	and	edx, 7
	cmp	dl, 6
	mov	DWORD PTR _expc$[ebp], ecx
	mov	DWORD PTR _lhs$40323[ebp], ebx
	mov	DWORD PTR _rhs$40324[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN833@interp
	mov	ecx, DWORD PTR _env$[ebp]
	sar	eax, 3
	push	eax
	push	ebx
	mov	DWORD PTR $T41915[ebp], eax
	call	?nextname@MethodEnv@avmplus@@QBEHHH@Z	; avmplus::MethodEnv::nextname

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp

; 1822 : 				sp--;
; 1823 : 				// verifier checks for int
; 1824 : 				sp[0] = env->nextname(lhs, AvmCore::integer_i(rhs));

$LN833@interp:
	and	eax, -8					; fffffff8H
	fld	QWORD PTR [eax]
	sub	esp, 8
	fst	QWORD PTR $T41904[ebp]
	mov	DWORD PTR _obj$41913[ebp], eax
	fstp	QWORD PTR [esp]
	call	?real2int@MathUtils@avmplus@@SAHN@Z	; avmplus::MathUtils::real2int
	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 8
	push	eax
	push	ebx
	mov	DWORD PTR $T41915[ebp], eax
	call	?nextname@MethodEnv@avmplus@@QBEHHH@Z	; avmplus::MethodEnv::nextname

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_nextvalue$40326:

; 1825 : 				restore_dxns();
; 1826 : 				NEXT;
; 1827 : 			}
; 1828 : 
; 1829 : 			INSTR(nextvalue) {
; 1830 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax

; 1831 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]

; 1832 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]

; 1833 : 				sp--;
; 1834 : 				// verifier checks for int
; 1835 : 				sp[0] = env->nextvalue(lhs, AvmCore::integer_i(rhs));

	mov	ecx, eax
	and	ecx, 7
	cmp	cl, 6
	mov	DWORD PTR _lhs$40327[ebp], ebx
	mov	DWORD PTR _rhs$40328[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN842@interp
	mov	ecx, DWORD PTR _env$[ebp]
	sar	eax, 3
	push	eax
	push	ebx
	mov	DWORD PTR $T41935[ebp], eax
	call	?nextvalue@MethodEnv@avmplus@@QBEHHH@Z	; avmplus::MethodEnv::nextvalue

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp

; 1833 : 				sp--;
; 1834 : 				// verifier checks for int
; 1835 : 				sp[0] = env->nextvalue(lhs, AvmCore::integer_i(rhs));

$LN842@interp:
	and	eax, -8					; fffffff8H
	fld	QWORD PTR [eax]
	sub	esp, 8
	fst	QWORD PTR $T41924[ebp]
	mov	DWORD PTR _obj$41933[ebp], eax
	fstp	QWORD PTR [esp]
	call	?real2int@MathUtils@avmplus@@SAHN@Z	; avmplus::MathUtils::real2int
	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 8
	push	eax
	push	ebx
	mov	DWORD PTR $T41935[ebp], eax
	call	?nextvalue@MethodEnv@avmplus@@QBEHHH@Z	; avmplus::MethodEnv::nextvalue

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_hasnext$40330:

; 1836 : 				restore_dxns();
; 1837 : 				NEXT;
; 1838 : 			}
; 1839 : 				
; 1840 : 			INSTR(hasnext) {
; 1841 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]

; 1842 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ebx, DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]

; 1843 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4

; 1844 : 				sp--;
; 1845 : 				// verifier checks for int
; 1846 : 				sp[0] = core->intToAtom(env->hasnext(lhs, AvmCore::integer_i(rhs)));

	mov	ecx, eax
	sar	edx, 2
	and	ecx, 7
	cmp	cl, 6
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _lhs$40331[ebp], ebx
	mov	DWORD PTR _rhs$40332[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN851@interp
	sar	eax, 3
	jmp	SHORT $LN1517@interp
$LN851@interp:
	and	eax, -8					; fffffff8H
	fld	QWORD PTR [eax]
	sub	esp, 8
	fst	QWORD PTR $T41944[ebp]
	mov	DWORD PTR _obj$41953[ebp], eax
	fstp	QWORD PTR [esp]
	call	?real2int@MathUtils@avmplus@@SAHN@Z	; avmplus::MathUtils::real2int
	add	esp, 8
$LN1517@interp:
	mov	ecx, DWORD PTR _env$[ebp]
	push	eax
	push	ebx
	mov	DWORD PTR $T41955[ebp], eax
	call	?hasnext@MethodEnv@avmplus@@QBEHHH@Z	; avmplus::MethodEnv::hasnext
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	DWORD PTR [esi], eax

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_hasnext2$40334:

; 1847 : 				restore_dxns();
; 1848 : 				NEXT;
; 1849 : 			}
; 1850 : 
; 1851 : 			INSTR(hasnext2) {
; 1852 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1853 : 				int objectReg = U30ARG;

	mov	ebx, DWORD PTR [edi]

; 1854 : 				int indexReg  = U30ARG;
; 1855 : 				Atom objAtom = framep[objectReg];

	mov	eax, DWORD PTR _framep$[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [edi+4]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, DWORD PTR [eax+ebx*4]
	add	edi, 4
	mov	DWORD PTR _objAtom$40337[ebp], edx

; 1856 : 				int index = core->integer(framep[indexReg]);

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _indexReg$40336[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _objectReg$40335[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer

; 1857 : 				*(++sp) = env->hasnext2(objAtom, index) ? trueAtom : falseAtom;

	mov	esi, DWORD PTR _sp$[ebp]
	lea	ecx, DWORD PTR _index$40338[ebp]
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	lea	edx, DWORD PTR _objAtom$40337[ebp]
	add	esi, 4
	push	edx
	mov	DWORD PTR _index$40338[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?hasnext2@MethodEnv@avmplus@@QBEHAAH0@Z	; avmplus::MethodEnv::hasnext2

; 1858 : 				framep[objectReg] = objAtom;

	mov	ecx, DWORD PTR _framep$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 8
	add	eax, 5
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _objAtom$40337[ebp]
	mov	DWORD PTR [ecx+ebx*4], eax

; 1859 : 				framep[indexReg] = core->intToAtom(index);

	mov	edx, DWORD PTR _index$40338[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom
	mov	ecx, DWORD PTR _framep$[ebp]
	mov	edx, DWORD PTR _indexReg$40336[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2373 : 					restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_deleteproperty$40340:

; 1860 : 				restore_dxns();
; 1861 : 				NEXT;
; 1862 : 			}
; 1863 : 
; 1864 : 			// delete property using multiname
; 1865 : 			INSTR(deleteproperty) {
; 1866 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1867 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40341[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 1868 : 				pool->parseMultiname(multiname, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T41986[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$41975[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40341[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 1869 : 				if (!multiname.isRuntime())

	mov	al, BYTE PTR _multiname$40341[ebp]
	add	edi, 4
	test	al, 12					; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN89@interp

; 1870 : 				{
; 1871 : 					sp[0] = env->delproperty(sp[0], &multiname);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR _multiname$40341[ebp]
	push	eax
	push	ecx

; 1872 : 				}
; 1873 : 				else

	jmp	$LN1518@interp
$LN89@interp:

; 1874 : 				{
; 1875 : 					if(multiname.isRtns() || !core->isDictionaryLookup(*sp, *(sp-1))) {

	test	al, 4
	mov	ebx, DWORD PTR _sp$[ebp]
	jne	$LN86@interp
	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx-4]
	mov	DWORD PTR $T42018[ebp], ecx
	mov	ecx, eax
	lea	esi, DWORD PTR [ebx-4]
	and	cl, 7
	cmp	cl, 1
	mov	DWORD PTR $T42020[ebp], edx
	mov	DWORD PTR $T42019[ebp], eax
	jne	SHORT $LN878@interp
	cmp	eax, 4
	jb	SHORT $LN878@interp
	mov	eax, 1
	jmp	SHORT $LN879@interp
$LN878@interp:
	xor	eax, eax
$LN879@interp:
	test	al, al
	je	SHORT $LN874@interp
	mov	ecx, DWORD PTR _core$[ebp]
	push	edx
	call	?isDictionary@AvmCore@avmplus@@QAE_NH@Z	; avmplus::AvmCore::isDictionary
	test	al, al
	je	SHORT $LN874@interp
	mov	eax, 1
	jmp	SHORT $LN875@interp
$LN874@interp:
	xor	eax, eax
$LN875@interp:
	test	al, al
	je	SHORT $LN86@interp

; 1878 : 					} else {
; 1879 : 						Atom key = *(sp--);
; 1880 : 						bool res = AvmCore::atomToScriptObject(sp[0])->deleteAtomProperty(key);

	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [ebx]
	and	ecx, -8					; fffffff8H
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+40]
	push	ebx
	mov	DWORD PTR _key$40347[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	call	eax

; 1881 : 						sp[0] = res ? trueAtom : falseAtom;

	xor	ecx, ecx
	test	al, al
	setne	cl
	mov	BYTE PTR _res$40348[ebp], al
	lea	ecx, DWORD PTR [ecx*8+5]
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LN85@interp
$LN86@interp:

; 1876 : 						sp = initMultiname(env, multiname, sp, true);

	mov	eax, DWORD PTR _env$[ebp]
	push	1
	push	ebx
	lea	edx, DWORD PTR _multiname$40341[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1877 : 						sp[0] = env->delproperty(sp[0], &multiname);

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR _multiname$40341[ebp]
	push	ecx
	mov	DWORD PTR _sp$[ebp], esi
	push	edx
$LN1518@interp:
	mov	ecx, DWORD PTR _env$[ebp]
	call	?delproperty@MethodEnv@avmplus@@QBEHHPAVMultiname@2@@Z ; avmplus::MethodEnv::delproperty
	mov	DWORD PTR [esi], eax
$LN85@interp:

; 1882 : 					}
; 1883 : 				}
; 1884 : 				restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 1885 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40341[ebp], eax
	mov	DWORD PTR _multiname$40341[ebp+4], eax
	mov	DWORD PTR _multiname$40341[ebp+8], eax
	mov	DWORD PTR _multiname$40341[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setslot$40350:

; 1886 : 			}
; 1887 : 
; 1888 :             INSTR(setslot) {
; 1889 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1890 : 				Atom lhs = sp[-1];

	mov	esi, DWORD PTR _sp$[ebp]

; 1891 : 				Atom rhs = sp[0];

	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi-4]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _rhs$40352[ebp], ecx

; 1892 : 				sp -= 2;
; 1893 : 				env->nullcheck(lhs);

	mov	ecx, DWORD PTR _env$[ebp]
	sub	esi, 8
	push	ebx
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR _lhs$40351[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 1894 : 				int slot_id = U30ARG-1;

	mov	eax, DWORD PTR [edi]

; 1895 : 				ScriptObject* o = AvmCore::atomToScriptObject(lhs);

	and	ebx, -8					; fffffff8H

; 1896 : 				o->setSlotAtom(slot_id, toplevel->coerce(rhs, o->traits()->getSlotTraits(slot_id)));

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edx+24]
	sub	eax, 1
	mov	DWORD PTR $T42040[ebp], ecx
	mov	ecx, DWORD PTR [ecx+48]
	mov	DWORD PTR _slot_id$40353[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	push	eax
	mov	DWORD PTR $T42057[ebp], eax
	mov	eax, DWORD PTR _rhs$40352[ebp]
	mov	DWORD PTR $T42049[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _o$40354[ebp], ebx
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce
	mov	ecx, DWORD PTR _slot_id$40353[ebp]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?setSlotAtom@ScriptObject@avmplus@@QAEXHH@Z ; avmplus::ScriptObject::setSlotAtom

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getslot$40356:

; 1897 : 				restore_dxns();
; 1898 : 				NEXT;
; 1899 : 			}
; 1900 : 
; 1901 : 			INSTR(getslot) {
; 1902 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1903 : 				env->nullcheck(sp[0]);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _env$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 1904 : 				sp[0] = AvmCore::atomToScriptObject(sp[0])->getSlotAtom(U30ARG-1);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	sub	eax, 1
	and	ecx, -8					; fffffff8H
	push	eax
	mov	DWORD PTR $T42064[ebp], ecx
	call	?getSlotAtom@ScriptObject@avmplus@@QAEHH@Z ; avmplus::ScriptObject::getSlotAtom

; 2014 : 
; 2015 : 				*(sp -= argc) = tempAtom;

	mov	DWORD PTR [esi], eax

; 2016 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	add	edi, 4

; 2017 : 				NEXT;

	jmp	$LN421@interp
$L_setglobalslot$40358:

; 1905 : 				restore_dxns();
; 1906 : 				NEXT;
; 1907 : 			}
; 1908 : 
; 1909 : 			INSTR(setglobalslot) {
; 1910 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2

; 1911 : 				// find the global activation scope (object at depth 0 on scope chain)
; 1912 : 				ScriptObject *global;
; 1913 : 				if (outer_depth == 0)

	cmp	DWORD PTR _outer_depth$[ebp], 0
	mov	DWORD PTR _expc$[ebp], ecx
	jne	SHORT $LN917@interp

; 1914 : 					global = AvmCore::atomToScriptObject(scopeBase[0]);

	mov	edx, DWORD PTR _scopeBase$[ebp]
	mov	eax, DWORD PTR [edx]

; 1915 : 				else

	jmp	SHORT $LN1520@interp

; 1916 : 					global = AvmCore::atomToScriptObject(scope->getScope(0));

$LN917@interp:
	mov	eax, DWORD PTR _scope$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR $T42077[ebp], eax
$LN1520@interp:

; 1917 : 
; 1918 : 				int slot_id = U30ARG-1;

	mov	ebx, DWORD PTR [edi]

; 1919 : 				Atom op = sp[0];

	mov	esi, DWORD PTR _sp$[ebp]
	and	eax, -8					; fffffff8H
	mov	DWORD PTR _global$40359[ebp], eax

; 1920 : 				sp--;
; 1921 : 				global->setSlotAtom(slot_id, toplevel->coerce(op, global->traits()->getSlotTraits(slot_id)));

	mov	ecx, DWORD PTR _global$40359[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T42088[ebp], ecx
	mov	ecx, DWORD PTR [ecx+48]
	sub	ebx, 1
	mov	DWORD PTR $T42097[ebp], ecx
	mov	ecx, DWORD PTR [ecx+ebx*4]
	push	ecx
	mov	DWORD PTR $T42105[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	add	edi, 4
	sub	esi, 4
	push	eax
	mov	DWORD PTR _slot_id$40362[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _op$40363[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce
	mov	ecx, DWORD PTR _global$40359[ebp]
	push	eax
	push	ebx
	call	?setSlotAtom@ScriptObject@avmplus@@QAEXHH@Z ; avmplus::ScriptObject::setSlotAtom

; 2373 : 					restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getglobalslot$40365:

; 1922 : 				restore_dxns();
; 1923 : 				NEXT;
; 1924 : 			}
; 1925 : 
; 1926 : 			INSTR(getglobalslot) {
; 1927 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2

; 1928 : 				// find the global activation scope (object at depth 0 on scope chain)
; 1929 : 				ScriptObject *global;
; 1930 : 				if (outer_depth == 0)

	cmp	DWORD PTR _outer_depth$[ebp], 0
	mov	DWORD PTR _expc$[ebp], eax
	jne	SHORT $LN943@interp

; 1931 : 					global = AvmCore::atomToScriptObject(scopeBase[0]);

	mov	ecx, DWORD PTR _scopeBase$[ebp]
	mov	ecx, DWORD PTR [ecx]

; 1932 : 				else

	jmp	SHORT $LN1521@interp

; 1933 : 					global = AvmCore::atomToScriptObject(scope->getScope(0));

$LN943@interp:
	mov	edx, DWORD PTR _scope$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T42118[ebp], ecx
$LN1521@interp:

; 1934 : 
; 1935 : 				sp++;
; 1936 : 				sp[0] = global->getSlotAtom(U30ARG-1);

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR _sp$[ebp]
	sub	eax, 1
	and	ecx, -8					; fffffff8H
	add	esi, 4
	push	eax
	mov	DWORD PTR _global$40366[ebp], ecx
	mov	DWORD PTR _sp$[ebp], esi
	call	?getSlotAtom@ScriptObject@avmplus@@QAEHH@Z ; avmplus::ScriptObject::getSlotAtom

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	add	edi, 4
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_call$40370:

; 1937 : 				restore_dxns();
; 1938 : 				NEXT;
; 1939 : 			}
; 1940 : 
; 1941 : 			INSTR(call) {
; 1942 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1943 :                 int32 argc = U30ARG;

	mov	ecx, DWORD PTR [edi]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax

; 1944 :                 // stack in: function, receiver, arg1, ... argN
; 1945 :                 // stack out: result
; 1946 :                 Atom tempAtom = toplevel->op_call(sp[-argc-1]/*function*/, argc, sp-argc);

	mov	eax, DWORD PTR _sp$[ebp]
	lea	edx, DWORD PTR [ecx*4]
	sub	eax, edx
	push	eax
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	DWORD PTR _argc$40371[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _pc$[ebp], edi
	call	?op_call@Toplevel@avmplus@@QAEHHHPAH@Z	; avmplus::Toplevel::op_call

; 2014 : 
; 2015 : 				*(sp -= argc) = tempAtom;

	mov	DWORD PTR [esi], eax

; 2016 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _tempAtom$40372[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi

; 2017 : 				NEXT;

	jmp	$LN421@interp
$L_construct$40374:

; 1947 :                 *(sp = sp-argc-1) = tempAtom;
; 1948 : 				restore_dxns();
; 1949 :                 NEXT;
; 1950 : 			}
; 1951 : 
; 1952 : 			INSTR(construct) {
; 1953 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1954 :                 int32 argc = U30ARG;
; 1955 :                 // stack in: function, arg1, ..., argN
; 1956 :                 // stack out: new instance
; 1957 :                 Atom tempAtom = toplevel->op_construct(sp[-argc]/*function*/, argc, sp-argc);				

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax*4]
	sub	esi, edx
	sub	ecx, 4
	push	esi
	sar	ecx, 2
	push	eax
	mov	DWORD PTR _argc$40375[ebp], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _pc$[ebp], edi
	call	?op_construct@Toplevel@avmplus@@QAEHHHPAH@Z ; avmplus::Toplevel::op_construct

; 2014 : 
; 2015 : 				*(sp -= argc) = tempAtom;

	mov	DWORD PTR [esi], eax

; 2016 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _tempAtom$40376[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi

; 2017 : 				NEXT;

	jmp	$LN421@interp
$L_newfunction$40378:

; 1958 :                 *(sp = sp-argc) = tempAtom;
; 1959 : 				restore_dxns();
; 1960 :                 NEXT;
; 1961 : 			}
; 1962 : 
; 1963 :             INSTR(newfunction) {
; 1964 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1965 : 				sp++;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax

; 1966 : 				AbstractFunction *body = pool->getMethodInfo(U30ARG);

	mov	eax, DWORD PTR [edi]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _pool$[ebp]
	add	esi, 4
	push	eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?getMethodInfo@PoolObject@avmplus@@QAEPAVAbstractFunction@2@I@Z ; avmplus::PoolObject::getMethodInfo

; 1967 : 				sp[0] = env->newfunction(body, scope, scopeBase)->atom();

	mov	edx, DWORD PTR _scopeBase$[ebp]
	mov	ecx, DWORD PTR _scope$[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _body$40379[ebp], eax
	mov	DWORD PTR _pc$[ebp], edi
	call	?newfunction@MethodEnv@avmplus@@QBEPAVClassClosure@2@PAVAbstractFunction@2@PAVScopeChain@2@PAH@Z ; avmplus::MethodEnv::newfunction
	mov	DWORD PTR $T42128[ebp], eax

; 1968 : 				restore_dxns();
; 1969 :                 NEXT;

	jmp	$LN1478@interp
$L_newclass$40381:

; 1970 :             }
; 1971 : 
; 1972 :             INSTR(newclass) {
; 1973 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1974 : 				int class_index = U30ARG;

	mov	eax, DWORD PTR [edi]

; 1975 : 				AbstractFunction *cinit = pool->cinits[class_index];
; 1976 : 				ClassClosure* base = (ClassClosure*)(~7&toplevel->coerce(sp[0], CLASS_TYPE));

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _pool$[ebp]
	sub	edx, 4
	sar	edx, 2
	mov	DWORD PTR _expc$[ebp], edx
	mov	edx, DWORD PTR [ecx+156]
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _class_index$40382[ebp], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	add	edi, 4
	push	edx
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _cinit$40383[ebp], ebx
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce

; 1977 : 				sp[0] = env->newclass(cinit, base, scope, scopeBase)->atom();

	mov	ecx, DWORD PTR _scopeBase$[ebp]
	mov	edx, DWORD PTR _scope$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	and	eax, -8					; fffffff8H
	push	edx
	push	eax
	push	ebx
	mov	DWORD PTR _base$40384[ebp], eax
	call	?newclass@MethodEnv@avmplus@@QBEPAVClassClosure@2@PAVAbstractFunction@2@PAV32@PAVScopeChain@2@PAH@Z ; avmplus::MethodEnv::newclass

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR $T42135[ebp], eax
	or	eax, 1
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_callstatic$40387:

; 1978 : 				restore_dxns();
; 1979 : 				NEXT;
; 1980 : 			}
; 1981 : 				
; 1982 :             INSTR(callstatic) {
; 1983 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1984 : 				// stack in: receiver, arg1..N
; 1985 : 				// stack out: result
; 1986 : 				int method_id = U30ARG;

	mov	ecx, DWORD PTR [edi]

; 1987 : 				int32 argc = U30ARG;

	mov	ebx, DWORD PTR [edi+4]

; 1988 : 				env->nullcheck(sp[-argc]);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, edi
	sub	eax, edx
	add	edi, 4
	sub	eax, 4
	sar	eax, 2
	lea	edx, DWORD PTR [ebx*4]
	sub	esi, edx
	mov	DWORD PTR _expc$[ebp], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _method_id$40388[ebp], ecx
	mov	ecx, DWORD PTR _env$[ebp]
	add	edi, 4
	push	eax
	mov	DWORD PTR _argc$40389[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 1989 : 				// ISSUE if arg types were checked in verifier, this coerces again.
; 1990 : 				MethodEnv* f = env->vtable->abcEnv->methods[method_id];

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _method_id$40388[ebp]
	mov	DWORD PTR $T42139[ebp], eax
	mov	eax, DWORD PTR [eax+ecx*4+24]

; 1991 : 				Atom tempAtom = f->coerceEnter(argc, sp-argc);

	push	esi
	push	ebx
	mov	ecx, eax
	mov	DWORD PTR _f$40390[ebp], eax
	call	?coerceEnter@MethodEnv@avmplus@@QAEHHPAH@Z ; avmplus::MethodEnv::coerceEnter

; 1992 : 				*(sp -= argc) = tempAtom;

	mov	DWORD PTR [esi], eax

; 1993 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _tempAtom$40391[ebp], eax
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [edx+216], eax

; 1994 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_callmethod$40393:

; 1995 : 			}
; 1996 : 
; 1997 :             INSTR(callmethod) {
; 1998 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 1999 : 				// stack in: receiver, arg1..N
; 2000 : 				// stack out: result
; 2001 : 				uint32 disp_id = U30ARG-1;

	mov	esi, DWORD PTR [edi]

; 2002 : 				int32 argc = U30ARG;

	mov	eax, DWORD PTR [edi+4]

; 2003 : 				// null check included in env->callmethod
; 2004 : 				//tempAtom = env->callmethod(disp_id, argc, sp-argc);
; 2005 : 				Atom* atomv = sp-argc;

	mov	ebx, DWORD PTR _sp$[ebp]
	mov	edx, edi
	add	edi, 4
	mov	DWORD PTR _argc$40395[ebp], eax
	add	eax, eax
	add	eax, eax
	sub	edx, ecx
	sub	ebx, eax
	mov	eax, ebx

; 2006 : 
; 2007 : 				// must be a real class instance for this to be used.  primitives that have
; 2008 : 				// methods will only have final bindings and no dispatch table.
; 2009 : 				VTable* vtable = toplevel->toVTable(atomv[0]); // includes null check

	mov	ecx, DWORD PTR [eax]
	sub	edx, 4
	sar	edx, 2
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	sub	esi, 1
	add	edi, 4
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _disp_id$40394[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _atomv$40396[ebp], eax
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable

; 2010 : 				AvmAssert(disp_id < vtable->traits->methodCount);
; 2011 : 				MethodEnv *f = vtable->methods[disp_id];

	mov	esi, DWORD PTR [eax+esi*4+64]

; 2012 : 				// ISSUE if arg types were checked in verifier, this coerces again.
; 2013 : 				Atom tempAtom = f->coerceEnter(argc, atomv);

	mov	edx, ebx
	mov	DWORD PTR _vtable$40397[ebp], eax
	mov	eax, DWORD PTR _argc$40395[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _f$40401[ebp], esi
	call	?coerceEnter@MethodEnv@avmplus@@QAEHHPAH@Z ; avmplus::MethodEnv::coerceEnter

; 2014 : 
; 2015 : 				*(sp -= argc) = tempAtom;

	mov	esi, ebx
	mov	DWORD PTR [esi], eax

; 2016 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _tempAtom$40402[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi

; 2017 : 				NEXT;

	jmp	$LN421@interp
$L_callproperty$40404:

; 2018 : 			}
; 2019 : 
; 2020 : 	#define callprop_impl(atomv0) \
; 2021 :             {\
; 2022 : 				SAVE_EXPC;\
; 2023 : 				/* ( obj [ns [name]] arg1..N -- result ) */ \
; 2024 : 				Multiname multiname;\
; 2025 : 				pool->parseMultiname(multiname, U30ARG);\
; 2026 : 				int32 argc = U30ARG;\
; 2027 : 				Atom base;\
; 2028 : 				Atom *atomv = sp - argc;\
; 2029 : 				sp = multiname.isRuntime() ? initMultiname(env, multiname, atomv) : atomv;\
; 2030 : 				base = *sp;\
; 2031 : 				atomv[0] = atomv0;\
; 2032 : 				*sp = toplevel->callproperty(base, &multiname, argc, atomv, toplevel->toVTable(base));\
; 2033 : 			}\
; 2034 : 			restore_dxns();
; 2035 : 
; 2036 : 			INSTR(callproperty) {
; 2037 : 				callprop_impl(base);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	lea	ecx, DWORD PTR _multiname$40405[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42170[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42159[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40405[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _sp$[ebp]
	add	edi, 4
	mov	DWORD PTR _argc$40406[ebp], eax
	add	eax, eax
	add	eax, eax
	add	edi, 4
	sub	esi, eax
	test	BYTE PTR _multiname$40405[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _atomv$40408[ebp], esi
	je	SHORT $LN490@interp
	mov	edx, DWORD PTR _env$[ebp]
	push	0
	push	esi
	lea	ecx, DWORD PTR _multiname$40405[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax
$LN490@interp:
	mov	ebx, DWORD PTR [esi]
	mov	eax, DWORD PTR _atomv$40408[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	ebx
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _base$40407[ebp], ebx
	mov	DWORD PTR [eax], ebx
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	ecx, DWORD PTR _atomv$40408[ebp]
	mov	edx, DWORD PTR _argc$40406[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	edx
	lea	eax, DWORD PTR _multiname$40405[ebp]
	push	eax
	push	ebx
	call	?callproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@HPAHPAVVTable@2@@Z ; avmplus::Toplevel::callproperty
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	xor	eax, eax
	mov	DWORD PTR _multiname$40405[ebp], eax
	mov	DWORD PTR _multiname$40405[ebp+4], eax
	mov	DWORD PTR _multiname$40405[ebp+8], eax
	mov	DWORD PTR _multiname$40405[ebp+12], eax

; 2038 : 				NEXT;

	jmp	$LN421@interp
$L_callproplex$40410:

; 2039 : 			}
; 2040 : 
; 2041 : 			INSTR(callproplex) {
; 2042 : 				callprop_impl(nullObjectAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	lea	ecx, DWORD PTR _multiname$40411[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42207[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42196[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40411[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _sp$[ebp]
	add	edi, 4
	mov	DWORD PTR _argc$40412[ebp], eax
	add	eax, eax
	add	eax, eax
	add	edi, 4
	sub	ebx, eax
	test	BYTE PTR _multiname$40411[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _atomv$40414[ebp], ebx
	je	SHORT $LN492@interp
	mov	edx, DWORD PTR _env$[ebp]
	push	0
	push	ebx
	lea	ecx, DWORD PTR _multiname$40411[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax
	jmp	SHORT $LN1522@interp
$LN492@interp:
	mov	esi, ebx
$LN1522@interp:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _base$40413[ebp], eax
	mov	DWORD PTR [ebx], 1
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	edx, DWORD PTR _base$40413[ebp]
	push	eax
	mov	eax, DWORD PTR _argc$40412[ebp]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _multiname$40411[ebp]
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	edx
	call	?callproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@HPAHPAVVTable@2@@Z ; avmplus::Toplevel::callproperty

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	mov	DWORD PTR _multiname$40411[ebp], eax
	mov	DWORD PTR _multiname$40411[ebp+4], eax
	mov	DWORD PTR _multiname$40411[ebp+8], eax
	mov	DWORD PTR _multiname$40411[ebp+12], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_callpropvoid$40416:

; 2043 : 				NEXT;
; 2044 : 			}
; 2045 : 
; 2046 : 			INSTR(callpropvoid) {
; 2047 : 				callprop_impl(base);

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	lea	ecx, DWORD PTR _multiname$40417[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42244[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42233[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _multiname$40417[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _sp$[ebp]
	add	edi, 4
	mov	DWORD PTR _argc$40418[ebp], eax
	add	eax, eax
	add	eax, eax
	add	edi, 4
	sub	esi, eax
	test	BYTE PTR _multiname$40417[ebp], 12	; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _atomv$40420[ebp], esi
	je	SHORT $LN494@interp
	mov	edx, DWORD PTR _env$[ebp]
	push	0
	push	esi
	lea	ecx, DWORD PTR _multiname$40417[ebp]
	push	ecx
	push	edx
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	add	esp, 16					; 00000010H
	mov	esi, eax
$LN494@interp:
	mov	ebx, DWORD PTR [esi]
	mov	eax, DWORD PTR _atomv$40420[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	ebx
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _base$40419[ebp], ebx
	mov	DWORD PTR [eax], ebx
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	ecx, DWORD PTR _atomv$40420[ebp]
	mov	edx, DWORD PTR _argc$40418[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	edx
	lea	eax, DWORD PTR _multiname$40417[ebp]
	push	eax
	push	ebx
	call	?callproperty@Toplevel@avmplus@@QAEHHPAVMultiname@2@HPAHPAVVTable@2@@Z ; avmplus::Toplevel::callproperty
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	mov	DWORD PTR _multiname$40417[ebp], eax
	mov	DWORD PTR _multiname$40417[ebp+4], eax
	mov	DWORD PTR _multiname$40417[ebp+8], eax
	mov	DWORD PTR _multiname$40417[ebp+12], eax

; 2048 : 				sp--;
; 2049 : 				NEXT;

	jmp	$LN1483@interp
$L_constructprop$40422:

; 2050 : 			}
; 2051 : 
; 2052 : 			INSTR(constructprop) {
; 2053 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx

; 2054 : 				// stack in: obj [ns [name]] arg1..N
; 2055 : 				// stack out: result
; 2056 : 				Multiname name;

	lea	ecx, DWORD PTR _name$40423[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2057 : 				pool->parseMultiname(name, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42281[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42270[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40423[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2058 : 				int32 argc = U30ARG;

	mov	ebx, DWORD PTR [edi+4]
	add	edi, 4
	add	edi, 4

; 2059 : 				if (!name.isRuntime())

	test	BYTE PTR _name$40423[ebp], 12		; 0000000cH
	mov	DWORD PTR _argc$40424[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN63@interp

; 2060 : 				{
; 2061 : 					// np check in toVTable
; 2062 : 					Atom tempAtom = toplevel->constructprop(&name, argc, sp-argc, toplevel->toVTable(sp[-argc]));

	mov	esi, DWORD PTR _sp$[ebp]
	lea	eax, DWORD PTR [ebx*4]
	sub	esi, eax
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	push	esi
	push	ebx
	lea	edx, DWORD PTR _name$40423[ebp]
	push	edx
	call	?constructprop@Toplevel@avmplus@@QAEHPAVMultiname@2@HPAHPAVVTable@2@@Z ; avmplus::Toplevel::constructprop
	mov	DWORD PTR _tempAtom$40426[ebp], eax

; 2063 : 					*(sp -= argc) = tempAtom;

	mov	DWORD PTR _sp$[ebp], esi

; 2064 : 				}
; 2065 : 				else

	jmp	SHORT $LN1523@interp
$LN63@interp:

; 2066 : 				{
; 2067 : 					Atom* atomv = sp-argc;

	mov	eax, DWORD PTR _sp$[ebp]
	lea	ecx, DWORD PTR [ebx*4]
	sub	eax, ecx

; 2068 : 					sp = initMultiname(env, name, sp-argc);

	push	0
	push	eax
	lea	edx, DWORD PTR _name$40423[ebp]
	mov	DWORD PTR _atomv$40428[ebp], eax
	mov	eax, DWORD PTR _env$[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname

; 2069 : 					atomv[0] = *sp;

	mov	ecx, DWORD PTR _atomv$40428[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax

; 2070 : 					*sp = toplevel->constructprop(&name, argc, atomv, toplevel->toVTable(atomv[0]));

	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?toVTable@Toplevel@avmplus@@QAEPAVVTable@2@H@Z ; avmplus::Toplevel::toVTable
	mov	edx, DWORD PTR _atomv$40428[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	push	edx
	push	ebx
	lea	eax, DWORD PTR _name$40423[ebp]
	push	eax
	call	?constructprop@Toplevel@avmplus@@QAEHPAVMultiname@2@HPAHPAVVTable@2@@Z ; avmplus::Toplevel::constructprop
$LN1523@interp:

; 2071 : 				}
; 2072 : 				restore_dxns();

	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]

; 2073 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR [ecx+216], edx
	mov	DWORD PTR _name$40423[ebp], eax
	mov	DWORD PTR _name$40423[ebp+4], eax
	mov	DWORD PTR _name$40423[ebp+8], eax
	mov	DWORD PTR _name$40423[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_applytype$40430:

; 2074 : 			}
; 2075 : 
; 2076 : 			INSTR(applytype) {
; 2077 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2078 : 				int32 argc = U30ARG;
; 2079 : 				// stack in: factory, arg1, ... argN
; 2080 : 				// stack out: result
; 2081 : 				Atom tempAtom = toplevel->op_applytype(sp[-argc]/*function*/, argc, sp-argc+1);				

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	sub	ecx, 4
	sar	ecx, 2
	lea	edx, DWORD PTR [eax*4]
	sub	esi, edx
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _expc$[ebp], ecx
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	add	edi, 4
	push	edx
	mov	DWORD PTR _argc$40431[ebp], eax
	mov	DWORD PTR _pc$[ebp], edi
	call	?op_applytype@Toplevel@avmplus@@QAEHHHPAH@Z ; avmplus::Toplevel::op_applytype

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR _tempAtom$40432[ebp], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_callsuper$40434:

; 2082 : 				*(sp = sp-argc) = tempAtom;
; 2083 : 				restore_dxns();
; 2084 : 				NEXT;
; 2085 : 			}
; 2086 : 
; 2087 : 	#define callsuper_impl() \
; 2088 : 			{\
; 2089 : 				SAVE_EXPC; \
; 2090 : 				/* ( obj [ns [name]] arg1..N -- ) */ \
; 2091 : 				Multiname name; \
; 2092 : 				pool->parseMultiname(name, U30ARG); \
; 2093 : 				int32 argc = U30ARG; \
; 2094 : 				if (!name.isRuntime()) \
; 2095 : 				{ \
; 2096 : 					env->nullcheck(sp[-argc]); \
; 2097 : 					Atom tempAtom = env->callsuper(&name, argc, sp-argc); \
; 2098 : 					*(sp -= argc) = tempAtom; \
; 2099 : 				} \
; 2100 : 				else \
; 2101 : 				{ \
; 2102 : 					Atom* atomv = sp-argc; \
; 2103 : 					sp = initMultiname(env, name, sp-argc); \
; 2104 : 					atomv[0] = *sp; \
; 2105 : 					env->nullcheck(atomv[0]); \
; 2106 : 					*sp = env->callsuper(&name, argc, atomv); \
; 2107 : 				}\
; 2108 : 			}\
; 2109 : 			restore_dxns()
; 2110 : 
; 2111 : 			INSTR(callsuper) {
; 2112 : 				callsuper_impl();

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	lea	ecx, DWORD PTR _name$40435[ebp]
	mov	DWORD PTR _expc$[ebp], eax
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42318[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42307[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40435[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	mov	ebx, DWORD PTR [edi+4]
	add	edi, 4
	add	edi, 4
	test	BYTE PTR _name$40435[ebp], 12		; 0000000cH
	mov	DWORD PTR _argc$40436[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN59@interp
	mov	esi, DWORD PTR _sp$[ebp]
	lea	eax, DWORD PTR [ebx*4]
	sub	esi, eax
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	ecx, DWORD PTR _env$[ebp]
	push	esi
	push	ebx
	lea	edx, DWORD PTR _name$40435[ebp]
	push	edx
	call	?callsuper@MethodEnv@avmplus@@QBEHPAVMultiname@2@HPAH@Z ; avmplus::MethodEnv::callsuper
	mov	DWORD PTR _tempAtom$40438[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	jmp	SHORT $LN1524@interp
$LN59@interp:
	mov	eax, DWORD PTR _sp$[ebp]
	lea	ecx, DWORD PTR [ebx*4]
	sub	eax, ecx
	push	0
	push	eax
	lea	edx, DWORD PTR _name$40435[ebp]
	mov	DWORD PTR _atomv$40440[ebp], eax
	mov	eax, DWORD PTR _env$[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	mov	ecx, DWORD PTR _atomv$40440[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _env$[ebp]
	push	eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	edx, DWORD PTR _atomv$40440[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	push	edx
	push	ebx
	lea	eax, DWORD PTR _name$40435[ebp]
	push	eax
	call	?callsuper@MethodEnv@avmplus@@QBEHPAVMultiname@2@HPAH@Z ; avmplus::MethodEnv::callsuper
$LN1524@interp:
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]
	xor	eax, eax
	mov	DWORD PTR _name$40435[ebp], eax
	mov	DWORD PTR _name$40435[ebp+4], eax
	mov	DWORD PTR _name$40435[ebp+8], eax
	mov	DWORD PTR _name$40435[ebp+12], eax

; 2113 : 				NEXT;

	jmp	$LN421@interp
$L_callsupervoid$40442:

; 2114 : 			}
; 2115 : 
; 2116 : 			INSTR(callsupervoid) {
; 2117 : 				callsuper_impl();	

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	lea	ecx, DWORD PTR _name$40443[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42355[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42344[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40443[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	mov	ebx, DWORD PTR [edi+4]
	add	edi, 4
	add	edi, 4
	test	BYTE PTR _name$40443[ebp], 12		; 0000000cH
	mov	DWORD PTR _argc$40444[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN56@interp
	mov	esi, DWORD PTR _sp$[ebp]
	lea	eax, DWORD PTR [ebx*4]
	sub	esi, eax
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	ecx, DWORD PTR _env$[ebp]
	push	esi
	push	ebx
	lea	edx, DWORD PTR _name$40443[ebp]
	push	edx
	call	?callsuper@MethodEnv@avmplus@@QBEHPAVMultiname@2@HPAH@Z ; avmplus::MethodEnv::callsuper
	mov	DWORD PTR _tempAtom$40446[ebp], eax
	jmp	SHORT $LN1525@interp
$LN56@interp:
	mov	eax, DWORD PTR _sp$[ebp]
	lea	ecx, DWORD PTR [ebx*4]
	sub	eax, ecx
	push	0
	push	eax
	lea	edx, DWORD PTR _name$40443[ebp]
	mov	DWORD PTR _atomv$40448[ebp], eax
	mov	eax, DWORD PTR _env$[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname
	mov	ecx, DWORD PTR _atomv$40448[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _env$[ebp]
	push	eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	edx, DWORD PTR _atomv$40448[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	push	edx
	push	ebx
	lea	eax, DWORD PTR _name$40443[ebp]
	push	eax
	call	?callsuper@MethodEnv@avmplus@@QBEHPAVMultiname@2@HPAH@Z ; avmplus::MethodEnv::callsuper
$LN1525@interp:
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	mov	DWORD PTR _name$40443[ebp], eax
	mov	DWORD PTR _name$40443[ebp+4], eax
	mov	DWORD PTR _name$40443[ebp+8], eax
	mov	DWORD PTR _name$40443[ebp+12], eax
$LN1483@interp:
	mov	ecx, DWORD PTR _core$[ebp]
	mov	edx, DWORD PTR _dxnsAddr$[ebp]

; 2118 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR [ecx+216], edx
	mov	DWORD PTR _sp$[ebp], esi

; 2119 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getsuper$40450:

; 2120 : 			}
; 2121 : 
; 2122 : 			INSTR(getsuper) {
; 2123 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx

; 2124 : 				Multiname name;

	lea	ecx, DWORD PTR _name$40451[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2125 : 				pool->parseMultiname(name, U30ARG);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR $T42392[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42381[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40451[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname
	add	edi, 4

; 2126 : 				if (!name.isRuntime())

	test	BYTE PTR _name$40451[ebp], 12		; 0000000cH
	mov	DWORD PTR _pc$[ebp], edi
	jne	SHORT $LN53@interp

; 2127 : 				{
; 2128 : 					Atom objAtom = *sp;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [esi]

; 2129 : 					env->nullcheck(objAtom);//null check

	mov	ecx, DWORD PTR _env$[ebp]
	push	ebx
	mov	DWORD PTR _objAtom$40453[ebp], ebx
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 2130 : 					*sp = env->getsuper(objAtom, &name);

	lea	eax, DWORD PTR _name$40451[ebp]
	push	eax

; 2131 : 				}
; 2132 : 				else

	jmp	SHORT $LN1526@interp
$LN53@interp:

; 2133 : 				{
; 2134 : 					sp = initMultiname(env, name, sp);

	mov	ecx, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR _env$[ebp]
	push	0
	push	ecx
	lea	edx, DWORD PTR _name$40451[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname

; 2135 : 					Atom objAtom = *sp;
; 2136 : 					env->nullcheck(objAtom);//null check

	mov	ecx, DWORD PTR _env$[ebp]
	mov	esi, eax
	mov	ebx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	push	ebx
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR _objAtom$40455[ebp], ebx
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 2137 : 					*sp = env->getsuper(objAtom, &name);

	lea	ecx, DWORD PTR _name$40451[ebp]
	push	ecx
$LN1526@interp:
	mov	ecx, DWORD PTR _env$[ebp]
	push	ebx
	call	?getsuper@MethodEnv@avmplus@@QBEHHPAVMultiname@2@@Z ; avmplus::MethodEnv::getsuper
	mov	DWORD PTR [esi], eax

; 2138 : 				}
; 2139 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2140 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _name$40451[ebp], eax
	mov	DWORD PTR _name$40451[ebp+4], eax
	mov	DWORD PTR _name$40451[ebp+8], eax
	mov	DWORD PTR _name$40451[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_setsuper$40457:

; 2141 : 			}
; 2142 : 
; 2143 : 			INSTR(setsuper) {
; 2144 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2145 : 				int index = U30ARG;

	mov	esi, DWORD PTR [edi]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2
	add	edi, 4

; 2146 : 				Multiname name;

	lea	ecx, DWORD PTR _name$40459[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _index$40458[ebp], esi
	mov	DWORD PTR _pc$[ebp], edi
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2147 : 				pool->parseMultiname(name, index);

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _a$42418[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [ecx+272]
	lea	edx, DWORD PTR _name$40459[ebp]
	push	edx
	push	eax
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2148 : 				Atom valueAtom = *(sp--);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [esi]
	sub	esi, 4

; 2149 : 				if (!name.isRuntime())

	test	BYTE PTR _name$40459[ebp], 12		; 0000000cH
	mov	DWORD PTR _valueAtom$40460[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	jne	SHORT $LN50@interp

; 2150 : 				{
; 2151 : 					Atom objAtom = *(sp--);

	mov	eax, DWORD PTR [esi]

; 2152 : 					env->nullcheck(objAtom);

	mov	ecx, DWORD PTR _env$[ebp]
	sub	esi, 4
	push	eax
	mov	DWORD PTR _objAtom$40462[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 2153 : 					env->setsuper(objAtom, &name, valueAtom);

	mov	ecx, DWORD PTR _objAtom$40462[ebp]
	push	ebx
	lea	eax, DWORD PTR _name$40459[ebp]
	push	eax
	push	ecx

; 2154 : 				}
; 2155 : 				else

	jmp	SHORT $LN1527@interp
$LN50@interp:

; 2156 : 				{
; 2157 : 					sp = initMultiname(env, name, sp);

	mov	eax, DWORD PTR _env$[ebp]
	push	0
	push	esi
	lea	edx, DWORD PTR _name$40459[ebp]
	push	edx
	push	eax
	call	?initMultiname@avmplus@@YAPAHPAVMethodEnv@1@AAVMultiname@1@PAH_N@Z ; avmplus::initMultiname

; 2158 : 					Atom objAtom = *(sp--);
; 2159 : 					env->nullcheck(objAtom);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	sub	esi, 4
	push	eax
	mov	DWORD PTR _objAtom$40464[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 2160 : 					env->setsuper(objAtom, &name, valueAtom);

	mov	edx, DWORD PTR _objAtom$40464[ebp]
	push	ebx
	lea	ecx, DWORD PTR _name$40459[ebp]
	push	ecx
	push	edx
$LN1527@interp:
	mov	ecx, DWORD PTR _env$[ebp]
	call	?setsuper@MethodEnv@avmplus@@QBEXHPAVMultiname@2@H@Z ; avmplus::MethodEnv::setsuper

; 2161 : 				}
; 2162 : 				restore_dxns();

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2163 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR _name$40459[ebp], eax
	mov	DWORD PTR _name$40459[ebp+4], eax
	mov	DWORD PTR _name$40459[ebp+8], eax
	mov	DWORD PTR _name$40459[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_constructsuper$40466:

; 2164 : 			}
; 2165 : 
; 2166 : 			// obj arg1 arg2
; 2167 : 		    //           sp
; 2168 : 			INSTR(constructsuper) {
; 2169 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2170 : 				// stack in:  obj arg1..N
; 2171 : 				// stack out: 
; 2172 : 				int32 argc = U30ARG;

	mov	ebx, DWORD PTR [edi]

; 2173 : 				env->nullcheck(sp[-argc]);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, edi
	sub	eax, edx
	lea	ecx, DWORD PTR [ebx*4]
	sub	esi, ecx
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR _env$[ebp]
	sub	eax, 4
	sar	eax, 2
	add	edi, 4
	push	edx
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR _argc$40467[ebp], ebx
	mov	DWORD PTR _pc$[ebp], edi
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck

; 2174 : 				env->vtable->base->init->coerceEnter(argc, sp-argc);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR $T42438[ebp], eax
	mov	eax, DWORD PTR [eax+16]
	push	esi
	push	ebx
	mov	ecx, eax
	mov	DWORD PTR $T42442[ebp], eax
	call	?coerceEnter@MethodEnv@avmplus@@QAEHHPAH@Z ; avmplus::MethodEnv::coerceEnter

; 2175 : 				sp -= argc+1;
; 2176 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	add	esi, -4					; fffffffcH
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [edx+216], eax

; 2177 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_astype$40469:

; 2178 : 			}
; 2179 : 
; 2180 : #ifndef AVMPLUS_WORD_CODE
; 2181 :             INSTR(pushshort) {
; 2182 :                 // this just pushes an integer since we dont have short atoms
; 2183 :                 *(++sp) = ((signed short)U30ARG)<<3|kIntegerType;
; 2184 : 				NEXT;
; 2185 : 			}
; 2186 : #endif
; 2187 : 
; 2188 : 			INSTR(astype) {
; 2189 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 2190 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40470[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2191 : 				pool->parseMultiname(multiname, U30ARG);

	mov	esi, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR $T42473[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _a$42462[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [esi+272]
	lea	edx, DWORD PTR _multiname$40470[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2192 : 				sp[0] = env->astype(sp[0], getTraits(&multiname, pool, toplevel, core));

	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _multiname$40470[ebp]
	push	esi
	add	edi, 4
	push	edx
	mov	DWORD PTR _pc$[ebp], edi
	call	?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ; avmplus::getTraits
	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?astype@MethodEnv@avmplus@@QAEHHPAVTraits@2@@Z ; avmplus::MethodEnv::astype

; 2193 : 				// this used to be after the switch
; 2194 : 				restore_dxns();

	mov	edx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _core$[ebp]

; 2195 : 				NEXT;

	xor	eax, eax
	mov	DWORD PTR [ecx+216], edx
	mov	DWORD PTR _multiname$40470[ebp], eax
	mov	DWORD PTR _multiname$40470[ebp+4], eax
	mov	DWORD PTR _multiname$40470[ebp+8], eax
	mov	DWORD PTR _multiname$40470[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_astypelate$40472:

; 2196 : 			}
; 2197 : 
; 2198 : 			INSTR(astypelate) {
; 2199 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax

; 2200 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [eax-4]
	sub	ecx, 4
	lea	esi, DWORD PTR [eax-4]

; 2201 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx

; 2202 : 				sp--;
; 2203 : 				sp[0] = env->astype(lhs, env->toClassITraits(rhs));

	mov	ecx, DWORD PTR _env$[ebp]
	push	eax
	mov	DWORD PTR _lhs$40473[ebp], ebx
	mov	DWORD PTR _rhs$40474[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?toClassITraits@MethodEnv@avmplus@@QAEPAVTraits@2@H@Z ; avmplus::MethodEnv::toClassITraits
	mov	ecx, DWORD PTR _env$[ebp]
	push	eax
	push	ebx
	call	?astype@MethodEnv@avmplus@@QAEHHPAVTraits@2@@Z ; avmplus::MethodEnv::astype
	mov	DWORD PTR [esi], eax

; 2204 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2205 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_coerce$40476:

; 2206 : 			}
; 2207 : 
; 2208 :             INSTR(coerce) {
; 2209 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	edx, edi
	sub	edx, ecx
	sub	edx, 4
	sar	edx, 2

; 2210 :                 // expects a CONSTANT_Multiname cpool index
; 2211 : 				// this is the ES4 implicit coersion
; 2212 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40477[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2213 : 				pool->parseMultiname(multiname, U30ARG);

	mov	esi, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR $T42507[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _a$42496[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [esi+272]
	lea	edx, DWORD PTR _multiname$40477[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2214 : 				sp[0] = toplevel->coerce(sp[0], getTraits(&multiname, pool, toplevel, core));

	mov	eax, DWORD PTR _core$[ebp]
	mov	ebx, DWORD PTR _toplevel$[ebp]
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _multiname$40477[ebp]
	push	esi
	add	edi, 4
	push	ecx
	mov	DWORD PTR _pc$[ebp], edi
	call	?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ; avmplus::getTraits
	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	push	eax
	push	edx
	mov	ecx, ebx
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce

; 2215 : 				restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2216 :                 NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40477[ebp], eax
	mov	DWORD PTR _multiname$40477[ebp+4], eax
	mov	DWORD PTR _multiname$40477[ebp+8], eax
	mov	DWORD PTR _multiname$40477[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_coerce_o$40479:

; 2217 : 			}
; 2218 : 
; 2219 : 			INSTR(coerce_o) {
; 2220 : 				if (sp[0] == undefinedAtom)

	cmp	DWORD PTR [esi], 4
	jne	$LL420@interp

; 2221 : 					sp[0] = nullObjectAtom;

	mov	DWORD PTR [esi], 1

; 2222 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_coerce_s$40482:

; 2223 : 			}
; 2224 : 
; 2225 : 			INSTR(coerce_s) {
; 2226 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _val$40483[ebp], eax

; 2227 : 				if (!IS_STRING(val)) {

	and	al, 7
	cmp	al, 2
	je	$LL420@interp

; 2228 : 					SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	eax, DWORD PTR _val$40483[ebp]
	cmp	eax, 4
	ja	SHORT $LN496@interp
	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, 2
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$LN496@interp:

; 2229 : 					sp[0] = AvmCore::isNullOrUndefined(val) ? nullStringAtom : core->string(val)->atom();

	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?string@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::string
	mov	esi, DWORD PTR _sp$[ebp]
	mov	DWORD PTR $T42517[ebp], eax
	or	eax, 2
	mov	DWORD PTR [esi], eax

; 2230 : 					restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2231 : 				}
; 2232 : 				NEXT;

	jmp	$LN421@interp
$L_istype$40486:

; 2233 : 			}
; 2234 : 
; 2235 : 			INSTR(istype) {
; 2236 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx

; 2237 :                 // expects a CONSTANT_Multiname cpool index
; 2238 : 				// used when operator "is" RHS is a compile-time type constant
; 2239 : 				Multiname multiname;

	lea	ecx, DWORD PTR _multiname$40487[ebp]
	call	??0Multiname@avmplus@@QAE@XZ		; avmplus::Multiname::Multiname

; 2240 : 				pool->parseMultiname(multiname, U30ARG);

	mov	esi, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi+104]
	mov	DWORD PTR $T42548[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _a$42537[ebp], eax
	shr	eax, 3
	add	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _multiname$40487[ebp]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?parseMultiname@PoolObject@avmplus@@QBEXPBEAAVMultiname@2@@Z ; avmplus::PoolObject::parseMultiname

; 2241 : 				Traits* itraits = getTraits(&multiname, pool, toplevel, core);

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _toplevel$[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _multiname$40487[ebp]
	push	esi
	add	edi, 4
	push	ecx
	mov	DWORD PTR _pc$[ebp], edi
	call	?getTraits@avmplus@@YAPAVTraits@1@PAVMultiname@1@PAVPoolObject@1@PAVToplevel@1@PAVAvmCore@1@@Z ; avmplus::getTraits

; 2242 : 				sp[0] = core->istypeAtom(sp[0], itraits);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR _core$[ebp]
	add	esp, 16					; 00000010H
	push	eax
	push	edx
	mov	DWORD PTR _itraits$40488[ebp], eax
	mov	DWORD PTR $T42553[ebp], edx
	mov	DWORD PTR $T42552[ebp], ecx
	call	?istype@AvmCore@avmplus@@QAE_NHPAVTraits@2@@Z ; avmplus::AvmCore::istype
	neg	al
	sbb	eax, eax
	and	eax, 8
	add	eax, 5
	mov	DWORD PTR [esi], eax

; 2243 : 				restore_dxns();

	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	edx, DWORD PTR _core$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2244 :                 NEXT;

	xor	eax, eax
	mov	DWORD PTR _multiname$40487[ebp], eax
	mov	DWORD PTR _multiname$40487[ebp+4], eax
	mov	DWORD PTR _multiname$40487[ebp+8], eax
	mov	DWORD PTR _multiname$40487[ebp+12], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_istypelate$40490:

; 2245 : 			}
; 2246 : 
; 2247 : 			INSTR(istypelate) {
; 2248 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2249 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ebx, DWORD PTR [eax-4]
	mov	edx, edi
	sub	edx, ecx

; 2250 : 				Atom rhs = sp[0];
; 2251 : 				sp--;
; 2252 : 				sp[0] = core->istypeAtom(lhs, env->toClassITraits(rhs));

	mov	ecx, DWORD PTR _env$[ebp]
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [eax]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _lhs$40491[ebp], ebx
	mov	DWORD PTR _rhs$40492[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?toClassITraits@MethodEnv@avmplus@@QAEPAVTraits@2@H@Z ; avmplus::MethodEnv::toClassITraits
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	push	ebx
	mov	DWORD PTR $T42561[ebp], eax
	mov	DWORD PTR $T42560[ebp], ecx
	call	?istype@AvmCore@avmplus@@QAE_NHPAVTraits@2@@Z ; avmplus::AvmCore::istype

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	neg	al
	sbb	eax, eax
	and	eax, 8
	add	eax, 5
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getscopeobject$40494:

; 2253 : 				restore_dxns();
; 2254 :                 NEXT;
; 2255 : 			}
; 2256 : 
; 2257 : #ifndef AVMPLUS_WORD_CODE
; 2258 :             INSTR(pushbyte) {
; 2259 : 				sp++;
; 2260 :                 sp[0] = MAKE_INTEGER((sint8)U8ARG);
; 2261 :                 NEXT;
; 2262 : 			}
; 2263 : #endif
; 2264 : 					
; 2265 :             INSTR(getscopeobject) {
; 2266 : 				int scope_index = U8ARG;

	mov	eax, DWORD PTR [edi]

; 2267 : 				sp++;
; 2268 : 				sp[0] = scopeBase[scope_index];

	mov	edx, DWORD PTR _scopeBase$[ebp]
	mov	DWORD PTR _scope_index$40495[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	add	edi, 4
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], eax

; 2269 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getouterscope$40497:

; 2270 : 			}
; 2271 : 
; 2272 :             INSTR(getouterscope) {
; 2273 :                 int scope_index = U30ARG;

	mov	eax, DWORD PTR [edi]

; 2274 : 				sp++;
; 2275 :                 sp[0] = scope->getScope(scope_index);

	mov	ecx, DWORD PTR _scope$[ebp]
	mov	DWORD PTR _scope_index$40498[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4+8]
	add	edi, 4
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR $T42568[ebp], eax
	mov	DWORD PTR [esi], eax

; 2276 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_getglobalscope$40500:

; 2277 :             }
; 2278 : 
; 2279 :             INSTR(getglobalscope) {
; 2280 : 				sp++;

	add	esi, 4

; 2281 : 				sp[0] = (outer_depth > 0) ? scope->getScope(0) : scopeBase[0];

	cmp	DWORD PTR _outer_depth$[ebp], 0
	mov	DWORD PTR _sp$[ebp], esi
	jle	SHORT $LN498@interp
	mov	edx, DWORD PTR _scope$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi], eax

; 2282 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN498@interp:

; 2281 : 				sp[0] = (outer_depth > 0) ? scope->getScope(0) : scopeBase[0];

	mov	eax, DWORD PTR _scopeBase$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 2282 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushscope$40502:

; 2283 : 			}
; 2284 : 
; 2285 :             INSTR(pushscope) {
; 2286 : 				Atom s = sp[0];

	mov	ebx, DWORD PTR [esi]

; 2287 : 				sp--;

	sub	esi, 4

; 2288 : 				if (AvmCore::isNullOrUndefined(s)) {

	cmp	ebx, 4
	mov	DWORD PTR _s$40503[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	ja	SHORT $LN34@interp

; 2289 : 					SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2290 : 					env->nullcheck(s);

	mov	ebx, DWORD PTR _s$40503[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _env$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	ebx
	mov	DWORD PTR _expc$[ebp], edx
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	esi, DWORD PTR _sp$[ebp]
$LN34@interp:

; 2291 : 				}
; 2292 : 				scopeBase[scopeDepth++] = s;

	mov	eax, DWORD PTR _scopeDepth$[ebp]
	mov	ecx, DWORD PTR _scopeBase$[ebp]
	mov	DWORD PTR [ecx+eax*4], ebx
	add	eax, 1
	mov	DWORD PTR _scopeDepth$[ebp], eax

; 2293 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_pushwith$40506:

; 2294 : 			}
; 2295 : 			
; 2296 :             INSTR(pushwith) {
; 2297 : 				Atom s = sp[0];

	mov	ebx, DWORD PTR [esi]

; 2298 : 				sp--;

	sub	esi, 4

; 2299 : 				if (AvmCore::isNullOrUndefined(s)) {

	cmp	ebx, 4
	mov	DWORD PTR _s$40507[ebp], ebx
	mov	DWORD PTR _sp$[ebp], esi
	ja	SHORT $LN32@interp

; 2300 : 					SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2301 : 					env->nullcheck(s);

	mov	ebx, DWORD PTR _s$40507[ebp]
	mov	ecx, DWORD PTR _env$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	push	ebx
	mov	DWORD PTR _expc$[ebp], eax
	call	?nullcheck@MethodEnv@avmplus@@QAEXH@Z	; avmplus::MethodEnv::nullcheck
	mov	esi, DWORD PTR _sp$[ebp]
$LN32@interp:

; 2302 : 				}
; 2303 : 				if (!withBase)

	cmp	DWORD PTR _withBase$[ebp], 0
	jne	SHORT $LN31@interp

; 2304 : 					withBase = scopeBase+scopeDepth;

	mov	ecx, DWORD PTR _scopeBase$[ebp]
	mov	edx, DWORD PTR _scopeDepth$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _withBase$[ebp], eax
$LN31@interp:

; 2305 : 				scopeBase[scopeDepth++] = s;

	mov	eax, DWORD PTR _scopeDepth$[ebp]
	mov	ecx, DWORD PTR _scopeBase$[ebp]
	mov	DWORD PTR [ecx+eax*4], ebx
	add	eax, 1
	mov	DWORD PTR _scopeDepth$[ebp], eax

; 2306 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_newactivation$40511:

; 2307 : 			}
; 2308 : 
; 2309 :             INSTR(newactivation) {
; 2310 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2311 : 				sp++;

	mov	esi, DWORD PTR _sp$[ebp]

; 2312 : 				sp[0] = core->newActivation(env->getActivation(), NULL)->atom();

	mov	ecx, DWORD PTR _env$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	add	esi, 4
	push	0
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?getActivation@MethodEnv@avmplus@@QAEPAVVTable@2@XZ ; avmplus::MethodEnv::getActivation
	mov	ecx, DWORD PTR _core$[ebp]
	push	eax
	call	?newActivation@AvmCore@avmplus@@QAEPAVScriptObject@2@PAVVTable@2@PAV32@@Z ; avmplus::AvmCore::newActivation
	mov	DWORD PTR $T42585[ebp], eax
	or	eax, 1
	mov	DWORD PTR [esi], eax

; 2313 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2314 : 				NEXT;

	jmp	$LN421@interp
$L_newcatch$40513:

; 2315 : 			}
; 2316 : 
; 2317 :             INSTR(newcatch) {
; 2318 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2319 : 				int catch_index = U30ARG;
; 2320 : #ifdef AVMPLUS_WORD_CODE
; 2321 : 				Traits *t = info->word_code.exceptions->exceptions[catch_index].scopeTraits;
; 2322 : #else
; 2323 : 				Traits *t = info->exceptions->exceptions[catch_index].scopeTraits;
; 2324 : #endif
; 2325 : 				sp++;

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _catch_index$40514[ebp], eax
	lea	edx, DWORD PTR [eax+eax*4+5]
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2326 : 				sp[0] = env->newcatch(t)->atom();

	mov	ecx, DWORD PTR _env$[ebp]
	add	edi, 4
	add	esi, 4
	push	eax
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _t$40515[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?newcatch@MethodEnv@avmplus@@QAEPAVScriptObject@2@PAVTraits@2@@Z ; avmplus::MethodEnv::newcatch
	mov	DWORD PTR $T42589[ebp], eax
$LN1478@interp:
	or	eax, 1
	mov	DWORD PTR [esi], eax
$LN1479@interp:

; 2327 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [edx+216], eax

; 2328 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_popscope$40517:

; 2329 : 			}
; 2330 : 
; 2331 :             INSTR(popscope) {
; 2332 : 				scopeDepth--;

	mov	eax, DWORD PTR _scopeDepth$[ebp]

; 2333 : 				if (withBase >= scopeBase+scopeDepth)

	mov	ecx, DWORD PTR _scopeBase$[ebp]
	sub	eax, 1
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR _withBase$[ebp], edx
	mov	DWORD PTR _scopeDepth$[ebp], eax
	jb	$LL420@interp

; 2334 : 					withBase = NULL;

	mov	DWORD PTR _withBase$[ebp], 0

; 2335 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_coerce_i$40520:

; 2336 : 			}
; 2337 : 
; 2338 : 			INSTR(coerce_i) {
; 2339 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _val$40521[ebp], eax

; 2340 : 				if (!IS_INTEGER(val)) {

	and	eax, 7
	cmp	al, 6
	je	$LL420@interp

; 2341 : 					SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2342 : 					sp[0] = core->intAtom(val);

	mov	edx, DWORD PTR _val$40521[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, ecx
	push	edx
	mov	DWORD PTR $T42593[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	push	eax
	mov	ecx, esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2343 : 					restore_dxns();
; 2344 : 				}
; 2345 : 				NEXT;

	jmp	$LN1475@interp
$L_convert_i$40524:

; 2346 : 			}
; 2347 : 
; 2348 :             INSTR(convert_i) {
; 2349 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _val$40525[ebp], eax

; 2350 : 				if (!IS_INTEGER(val)) {

	and	eax, 7
	cmp	al, 6
	je	$LL420@interp

; 2351 : 					SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2352 : 					sp[0] = core->intAtom(val);

	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, edi
	sub	eax, edx
	mov	edx, DWORD PTR _val$40525[ebp]
	sub	eax, 4
	sar	eax, 2
	mov	esi, ecx
	push	edx
	mov	DWORD PTR _expc$[ebp], eax
	mov	DWORD PTR $T42597[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	push	eax
	mov	ecx, esi
	call	?intToAtom@AvmCore@avmplus@@QAEHH@Z	; avmplus::AvmCore::intToAtom

; 2353 : 					restore_dxns();
; 2354 : 				}
; 2355 :                 NEXT;

	jmp	$LN1475@interp
$L_coerce_u$40528:

; 2356 : 			}
; 2357 : 
; 2358 : 			INSTR(coerce_u) {
; 2359 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]

; 2360 : 				if (!IS_INTEGER(val) || val < 0) {

	mov	edx, eax
	and	edx, 7
	cmp	dl, 6
	mov	DWORD PTR _val$40529[ebp], eax
	jne	SHORT $LN20@interp
	test	eax, eax
	jge	$LL420@interp
$LN20@interp:

; 2361 : 					SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2362 : 					sp[0] = core->uintAtom(val);

	mov	edx, DWORD PTR _val$40529[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, ecx
	push	edx
	mov	DWORD PTR $T42607[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	DWORD PTR $T42602[ebp], eax

; 2363 : 					restore_dxns();
; 2364 : 				}
; 2365 :                 NEXT;

	jmp	SHORT $LN1474@interp
$L_convert_u$40533:

; 2366 : 			}
; 2367 : 
; 2368 : 			INSTR(convert_u) {
; 2369 : 				Atom val = sp[0];

	mov	eax, DWORD PTR [esi]

; 2370 : 				if (!IS_INTEGER(val) || val < 0) {

	mov	edx, eax
	and	edx, 7
	cmp	dl, 6
	mov	DWORD PTR _val$40534[ebp], eax
	jne	SHORT $LN17@interp
	test	eax, eax
	jge	$LL420@interp
$LN17@interp:

; 2371 : 					SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2372 : 					sp[0] = core->uintAtom(val);

	mov	edx, DWORD PTR _val$40534[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _core$[ebp]
	mov	esi, ecx
	push	edx
	mov	DWORD PTR $T42617[ebp], esi
	call	?integer@AvmCore@avmplus@@QBEHH@Z	; avmplus::AvmCore::integer
	mov	DWORD PTR $T42612[ebp], eax
$LN1474@interp:
	push	eax
	mov	ecx, esi
	call	?uintToAtom@AvmCore@avmplus@@QAEHI@Z	; avmplus::AvmCore::uintToAtom
$LN1475@interp:
	mov	esi, DWORD PTR _sp$[ebp]

; 2373 : 					restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2374 : 				}
; 2375 :                 NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_throw$40538:

; 2376 : 			}
; 2377 : 
; 2378 : 			INSTR(throw) {
; 2379 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2380 : 				core->throwAtom(*sp--);

	mov	esi, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _core$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?throwAtom@AvmCore@avmplus@@QAEXH@Z	; avmplus::AvmCore::throwAtom
$L_pop$39668:
	sub	esi, 4
	mov	DWORD PTR _sp$[ebp], esi

; 2381 : 				// unreachable
; 2382 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_instanceof$40540:

; 2383 : 			}
; 2384 : 				
; 2385 :             INSTR(instanceof) {
; 2386 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2387 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	lea	esi, DWORD PTR [eax-4]

; 2388 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	sub	edx, 4

; 2389 : 				sp--;
; 2390 : 				sp[0] = toplevel->instanceof(lhs, rhs);

	push	eax
	sar	edx, 2
	mov	DWORD PTR _lhs$40541[ebp], ecx
	push	ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	mov	DWORD PTR _expc$[ebp], edx
	mov	DWORD PTR _rhs$40542[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?instanceof@Toplevel@avmplus@@QAEHHH@Z	; avmplus::Toplevel::instanceof

; 2391 : 				restore_dxns();

	mov	ecx, DWORD PTR _dxnsAddr$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _core$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 2392 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_in$40544:

; 2393 : 			}
; 2394 : 
; 2395 :             INSTR(in) {
; 2396 : 				SAVE_EXPC;

	mov	edx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]
	mov	eax, edi
	sub	eax, edx
	sub	eax, 4
	sar	eax, 2
	mov	DWORD PTR _expc$[ebp], eax

; 2397 : 				Atom lhs = sp[-1];

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]

; 2398 : 				Atom rhs = sp[0];

	mov	eax, DWORD PTR [eax]

; 2399 : 				sp--;
; 2400 : 				sp[0] = env->in(lhs, rhs);

	push	eax
	mov	DWORD PTR _lhs$40545[ebp], ecx
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR _rhs$40546[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
	call	?in@MethodEnv@avmplus@@QBEHHH@Z		; avmplus::MethodEnv::in
	mov	DWORD PTR [esi], eax

; 2401 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2402 : 				NEXT;

	jmp	$LN421@interp
$L_dxns$40548:

; 2403 : 			}
; 2404 : 
; 2405 : 			INSTR(dxns) {
; 2406 : 				SAVE_EXPC;

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2407 : 				dxns = core->newPublicNamespace(cpool_string[U30ARG]);

	mov	edx, DWORD PTR _cpool_string$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T42621[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _core$[ebp]
	push	0
	push	eax
	mov	DWORD PTR $T42627[ebp], eax
	mov	DWORD PTR $T42626[ebp], ecx
	call	?newNamespace@AvmCore@avmplus@@QAEPAVNamespace@2@PAVString@2@W4NamespaceType@32@@Z ; avmplus::AvmCore::newNamespace
	mov	DWORD PTR _dxns$[ebp], eax
$LN1471@interp:

; 2408 : 				restore_dxns();

	mov	edx, DWORD PTR _core$[ebp]
	mov	eax, DWORD PTR _dxnsAddr$[ebp]

; 2409 : 				NEXT;

	mov	esi, DWORD PTR _sp$[ebp]
	add	edi, 4
	mov	DWORD PTR [edx+216], eax
	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$L_dxnslate$40550:

; 2410 : 			}
; 2411 : 
; 2412 : 			INSTR(dxnslate) {
; 2413 : 				SAVE_EXPC;

	mov	ecx, DWORD PTR _code_start$[ebp]
	mov	edi, DWORD PTR _pc$[ebp]

; 2414 : 				dxns = core->newPublicNamespace(core->intern(*sp));

	mov	esi, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	edx, edi
	sub	edx, ecx
	mov	ecx, DWORD PTR _core$[ebp]
	sub	edx, 4
	sar	edx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], edx
	call	?intern@AvmCore@avmplus@@QAEPAVString@2@H@Z ; avmplus::AvmCore::intern
	mov	ecx, DWORD PTR _core$[ebp]
	push	0
	push	eax
	mov	DWORD PTR $T42632[ebp], eax
	mov	DWORD PTR $T42631[ebp], ecx
	call	?newNamespace@AvmCore@avmplus@@QAEPAVNamespace@2@PAVString@2@W4NamespaceType@32@@Z ; avmplus::AvmCore::newNamespace

; 2415 : 				sp--;

	sub	esi, 4
	mov	DWORD PTR _dxns$[ebp], eax
	mov	DWORD PTR _sp$[ebp], esi
$LN1429@interp:

; 2416 : 				// this used to be after the switch
; 2417 : 				restore_dxns();

	mov	ecx, DWORD PTR _core$[ebp]

; 2418 : 				NEXT;

	jmp	$LN421@interp
$L_ext_pushbits$40557:

; 2471 : 					goto L_ext_push_doublebits;
; 2472 : 				break;
; 2473 : #  endif
; 2474 : 
; 2475 : 			INSTR(ext_pushbits) {
; 2476 : 				*++sp = *pc++;

	mov	eax, DWORD PTR [edi]
	add	esi, 4
	mov	DWORD PTR _sp$[ebp], esi
	mov	DWORD PTR [esi], eax
	add	edi, 4

; 2477 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN500@interp:

; 675  : #else
; 676  : 		TRY_UNLESS(core, !info->exceptions, kCatchAction_SearchForActionScriptExceptionHandler) {
; 677  : #endif
; 678  : 			
; 679  : 		restore_dxns();
; 680  : 
; 681  : 		// the verifier ensures we don't fall off the end of a method.  so
; 682  : 		// we dont have to check the end pointer here.
; 683  : #if defined DIRECT_DISPATCH
; 684  : 
; 685  : 		NEXT;
; 686  : 
; 687  : #endif // DIRECT_DISPATCH
; 688  : 
; 689  : #if defined SWITCH_DISPATCH
; 690  : 			
; 691  :         for (;;)
; 692  :         {
; 693  : #  if defined AVMPLUS_WORD_CODE && !defined AVMPLUS_DIRECT_THREADED
; 694  : 			// See comments around INSTR(ext) below.
; 695  : 			AvmAssert((*pc & 65535) == ((*pc >> 16) & 65535));
; 696  : 			switch ((*pc++) & 255)
; 697  : #  else
; 698  :             switch (*pc++)

	cmp	eax, 767				; 000002ffH
	je	SHORT $L_ext_push_doublebits$40554
$LN11@interp:

; 2419 : 			}
; 2420 : 
; 2421 : 			// 'OP_abs_jump' always boils away in the translation to word code, see
; 2422 : 			// comments in Translator.cpp.
; 2423 : #ifndef AVMPLUS_WORD_CODE
; 2424 : 			INSTR(abs_jump)	{
; 2425 : 				if (interruptable && core->interrupted) {
; 2426 : 					SAVE_EXPC;
; 2427 : 					env->interrupt();
; 2428 : 				}
; 2429 : #  ifdef AVMPLUS_64BIT
; 2430 : 				uint32 base = AvmCore::readU30(pc);
; 2431 : 				byte *target = (byte *) ((uintptr(AvmCore::readU30(pc)) << 32));
; 2432 : 				target = (byte*)((uintptr)target | base);
; 2433 : 				code_start = pc = (const byte*) target;
; 2434 : #  else // !AVMPLUS_64BIT
; 2435 : 				const byte *target = (const byte *) U30ARG;
; 2436 : 				code_start = pc = target;
; 2437 : #  endif // AVMPLUS_64BIT
; 2438 : 				NEXT;
; 2439 :             }
; 2440 : #endif // !AVMPLUS_WORD_CODE
; 2441 : 
; 2442 : #if defined(AVMPLUS_WORD_CODE) && !defined(AVMPLUS_DIRECT_THREADED)
; 2443 : 			// Fleshes out the dispatch table so that it's 0..255, allows
; 2444 : 			// some compilers to generate better code for the switch at the
; 2445 : 			// top, which switches on the low 8 bits.  (0 is an illegal
; 2446 : 			// opcode; 255 is OP_ext, for which there's a case below.)
; 2447 : 			case 0: {
; 2448 : 				AvmAssert(false);
; 2449 : 			}
; 2450 : #endif
; 2451 : 
; 2452 : #ifdef AVMPLUS_WORD_CODE
; 2453 : #  ifndef AVMPLUS_DIRECT_THREADED
; 2454 : 			INSTR(ext) {
; 2455 : 			// When using token threading, opcodes for introduced (rewritten) instructions are 
; 2456 : 			// represented with the low byte being OP_ext (0xFF) and the second byte being one
; 2457 : 			// of the OP_ext_ opcodes.  The main dispatch loop must mask off the higher bits
; 2458 : 			// during initial dispatch; this incurs a slight cost but (a) the normal case is
; 2459 : 			// that direct threading will be used and (b) the effect of the optimizations enabled
; 2460 : 			// by the extended opcodes should make up for it.
; 2461 : #    ifdef _DEBUG
; 2462 : 			switch (pc[-1] & 65535) {
; 2463 : #    else
; 2464 : 			switch (pc[-1]) {
; 2465 : #    endif
; 2466 : #  endif // !AVMPLUS_DIRECT_THREADED
; 2467 : #  ifdef MSVC_X86_REWRITE_THREADING
; 2468 : 			default:
; 2469 : 				// Keep L_illegal_op and L_ext_push_doublebits alive...
; 2470 : 				if ((int)pc > 0x100000)

	cmp	edi, 1048576				; 00100000H
	jle	SHORT $LN10@interp
$L_ext_push_doublebits$40554:

; 2478 : 			}
; 2479 : 					
; 2480 : 			INSTR(ext_push_doublebits) {
; 2481 : 				union {
; 2482 : 					double d;
; 2483 : 					uint32 bits[2];
; 2484 : 				} u;
; 2485 : 				u.bits[0] = *pc++;

	mov	ecx, DWORD PTR [edi]

; 2486 : 				u.bits[1] = *pc++;

	mov	edx, DWORD PTR [edi+4]
	add	edi, 4
	mov	DWORD PTR _u$40568[ebp], ecx

; 2487 : 				*++sp = core->doubleToAtom(u.d);

	mov	ecx, DWORD PTR _core$[ebp]
	mov	DWORD PTR _u$40568[ebp+4], edx
	fld	QWORD PTR _u$40568[ebp]
	add	edi, 4
	add	esi, 4
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _pc$[ebp], edi
	mov	DWORD PTR _sp$[ebp], esi
	call	?doubleToAtom@AvmCore@avmplus@@QAEHN@Z	; avmplus::AvmCore::doubleToAtom
	mov	DWORD PTR [esi], eax

; 2488 : 				NEXT;

	mov	eax, DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _pc$[ebp], edi
	jmp	eax
; 	jmp	$LL420@interp
$LN10@interp:

; 2520 : 		}
; 2521 : 		END_CATCH
; 2522 : 		END_TRY 
; 2523 : 
; 2524 : #if defined AVMPLUS_DIRECT_THREADED
; 2525 : 
; 2526 : 		L_illegal_op:

	lea	ecx, DWORD PTR __ef$39597[ebp]
	call	?endTry@ExceptionFrame@avmplus@@QAEXXZ	; avmplus::ExceptionFrame::endTry
	mov	ecx, DWORD PTR _core$[ebp]
$L_illegal_op$40569:
	xor	ebx, ebx
	jmp	$MainLoop$39596
$L_returnvoid$39610:

; 699  : #  endif // AVMPLUS_WORD_CODE && !AVMPLUS_DIRECT_THREADING
; 700  :             {
; 701  : 
; 702  : #endif // SWITCH_DISPATCH
; 703  : 
; 704  : 	#define return_impl(val) \
; 705  :             {\
; 706  : 				SAVE_EXPC;\
; 707  : 				core->codeContextAtom = savedCodeContext;\
; 708  : 				tempAtom = toplevel->coerce(val, info->returnTraits());\
; 709  : 				restore_caller_dxns();\
; 710  : 			}
; 711  : 
; 712  : 			INSTR(returnvoid) {
; 713  : 				Atom tempAtom;
; 714  : 				#ifdef DEBUGGER
; 715  : 				env->debugExit(&callStackNode);
; 716  : 				#endif				
; 717  : 				return_impl(undefinedAtom);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _core$[ebp]
	mov	esi, DWORD PTR _info$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _savedCodeContext$[ebp]
	sub	ecx, 4
	mov	DWORD PTR [edx+844], eax
	mov	eax, DWORD PTR [esi+40]
	sar	ecx, 2
	push	eax
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	4
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce
	test	BYTE PTR [esi+24], 64			; 00000040H
	mov	edi, eax
	je	SHORT $LN413@interp
	mov	ecx, DWORD PTR _core$[ebp]
	mov	edx, DWORD PTR _dxnsAddrSave$[ebp]
	mov	DWORD PTR [ecx+216], edx

; 718  : 				#ifdef AVMPLUS_VERBOSE
; 719  : 				if (pool->verbose)
; 720  : 					core->console << "exit " << info << '\n';
; 721  : 				#endif
; 722  : 				return tempAtom;

	jmp	SHORT $LN413@interp
$L_returnvalue$39615:

; 723  : 			}
; 724  : 
; 725  :             INSTR(returnvalue) {
; 726  : 				Atom tempAtom;
; 727  : 				#ifdef DEBUGGER
; 728  : 				env->debugExit(&callStackNode);
; 729  : 				#endif				
; 730  : 				return_impl(*sp);

	mov	eax, DWORD PTR _code_start$[ebp]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR _core$[ebp]
	mov	esi, DWORD PTR _info$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _savedCodeContext$[ebp]
	sub	ecx, 4
	sar	ecx, 2
	mov	DWORD PTR _expc$[ebp], ecx
	mov	ecx, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [edx+844], eax
	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _toplevel$[ebp]
	push	eax
	push	edx
	call	?coerce@Toplevel@avmplus@@QBEHHPAVTraits@2@@Z ; avmplus::Toplevel::coerce
	test	BYTE PTR [esi+24], 64			; 00000040H
	mov	edi, eax
	je	SHORT $LN413@interp
	mov	eax, DWORD PTR _core$[ebp]
	mov	ecx, DWORD PTR _dxnsAddrSave$[ebp]
	mov	DWORD PTR [eax+216], ecx
$LN413@interp:

; 731  : 				#ifdef AVMPLUS_VERBOSE
; 732  : 				if (pool->verbose)
; 733  : 					core->console << "exit " << info << '\n';
; 734  : 				#endif
; 735  : 				return tempAtom;

	lea	ecx, DWORD PTR __ef$39597[ebp]
	call	?endTry@ExceptionFrame@avmplus@@QAEXXZ	; avmplus::ExceptionFrame::endTry
	mov	eax, edi

; 2527 : 			AvmAssert(!"Illegal operation!");
; 2528 : 			goto MainLoop;
; 2529 : 
; 2530 : #endif
; 2531 : 		//
; 2532 : 		// we never get here. verifier doesn't allow code to fall off end.
; 2533 : 		//
; 2534 :     }

	lea	esp, DWORD PTR [ebp-2020]
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	ebp, 108				; 0000006cH
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1534@interp:
	DD	$L_bkpt$39622
	DD	$L_throw$40538
	DD	$L_getsuper$40450
	DD	$L_setsuper$40457
	DD	$L_dxns$40548
	DD	$L_dxnslate$40550
	DD	$L_kill$39714
	DD	$L_ifnlt$40117
	DD	$L_ifnle$40147
	DD	$L_ifngt$40177
	DD	$L_ifnge$40207
	DD	$L_jump$39636
	DD	$L_iftrue$40008
	DD	$L_iffalse$40019
	DD	$L_ifeq$40030
	DD	$L_ifne$40048
	DD	$L_iflt$40102
	DD	$L_ifle$40132
	DD	$L_ifgt$40162
	DD	$L_ifge$40192
	DD	$L_ifstricteq$40066
	DD	$L_ifstrictne$40084
	DD	$L_lookupswitch$39999
	DD	$L_pushwith$40506
	DD	$L_popscope$40517
	DD	$L_nextname$40322
	DD	$L_hasnext$40330
	DD	$L_pushnull$39641
	DD	$L_pushundefined$39643
	DD	$L_nextvalue$40326
	DD	$L_pushtrue$39662
	DD	$L_pushfalse$39664
	DD	$L_pushnan$39666
	DD	$L_pop$39668
	DD	$L_dup$39670
	DD	$L_swap$39672
	DD	$L_pushstring$39645
	DD	$L_pushdouble$39647
	DD	$L_pushscope$40502
	DD	$L_pushnamespace$39650
	DD	$L_hasnext2$40334
	DD	$L_newfunction$40378
	DD	$L_call$40370
	DD	$L_construct$40374
	DD	$L_callmethod$40393
	DD	$L_callstatic$40387
	DD	$L_callsuper$40434
	DD	$L_callproperty$40404
	DD	$L_returnvoid$39610
	DD	$L_returnvalue$39615
	DD	$L_constructsuper$40466
	DD	$L_constructprop$40422
	DD	$L_callproplex$40410
	DD	$L_callsupervoid$40442
	DD	$L_callpropvoid$40416
	DD	$L_applytype$40430
	DD	$L_newobject$40262
	DD	$L_newarray$40266
	DD	$L_newactivation$40511
	DD	$L_newclass$40381
	DD	$L_getdescendants$40304
	DD	$L_newcatch$40513
	DD	$L_findpropstrict$40311
	DD	$L_findproperty$40315
	DD	$L_finddef$40319
	DD	$L_getlex$40270
	DD	$L_setproperty$40283
	DD	$L_getlocal$39652
	DD	$L_setlocal$39727
	DD	$L_getglobalscope$40500
	DD	$L_getscopeobject$40494
	DD	$L_getproperty$40274
	DD	$L_getouterscope$40497
	DD	$L_initproperty$40296
	DD	$L_deleteproperty$40340
	DD	$L_getslot$40356
	DD	$L_setslot$40350
	DD	$L_getglobalslot$40365
	DD	$L_setglobalslot$40358
	DD	$L_convert_s$39675
	DD	$L_esc_xelem$39678
	DD	$L_esc_xattr$39680
	DD	$L_convert_i$40524
	DD	$L_convert_u$40533
	DD	$L_convert_d$39685
	DD	$L_convert_b$39688
	DD	$L_convert_o$39702
	DD	$L_checkfilter$40309
	DD	$L_coerce$40476
	DD	$L_coerce_b$39695
	DD	$L_coerce_a$39620
	DD	$L_coerce_i$40520
	DD	$L_coerce_s$40482
	DD	$L_astype$40469
	DD	$L_astypelate$40472
	DD	$L_coerce_u$40528
	DD	$L_coerce_o$40479
	DD	$L_negate$39705
	DD	$L_increment$39737
	DD	$L_inclocal$39765
	DD	$L_decrement$39795
	DD	$L_declocal$39823
	DD	$L_typeof$39716
	DD	$L_not$39718
	DD	$L_bitnot$39725
	DD	$L_add$39853
	DD	$L_subtract$39889
	DD	$L_multiply$39925
	DD	$L_divide$39934
	DD	$L_modulo$39941
	DD	$L_lshift$39953
	DD	$L_rshift$39963
	DD	$L_urshift$39970
	DD	$L_bitand$39980
	DD	$L_bitor$39985
	DD	$L_bitxor$39990
	DD	$L_equals$39995
	DD	$L_strictequals$39997
	DD	$L_lessthan$40222
	DD	$L_lessequals$40232
	DD	$L_greaterthan$40242
	DD	$L_greaterequals$40252
	DD	$L_instanceof$40540
	DD	$L_istype$40486
	DD	$L_istypelate$40490
	DD	$L_in$40544
	DD	$L_increment_i$39751
	DD	$L_decrement_i$39809
	DD	$L_inclocal_i$39780
	DD	$L_declocal_i$39838
	DD	$L_negate_i$39712
	DD	$L_add_i$39871
	DD	$L_subtract_i$39907
	DD	$L_multiply_i$39932
	DD	$L_getlocal0$39654
	DD	$L_getlocal1$39656
	DD	$L_getlocal2$39658
	DD	$L_getlocal3$39660
	DD	$L_setlocal0$39729
	DD	$L_setlocal1$39731
	DD	$L_setlocal2$39733
	DD	$L_setlocal3$39735
	DD	$L_debugline$39624
	DD	$L_debugfile$39632
	DD	$L_bkptline$39628
	DD	$LN11@interp
$LN1408@interp:
	DB	0
	DB	-111					; ffffff91H
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	-111					; ffffff91H
	DB	29					; 0000001dH
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	-111					; ffffff91H
	DB	52					; 00000034H
	DB	-111					; ffffff91H
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	55					; 00000037H
	DB	-111					; ffffff91H
	DB	56					; 00000038H
	DB	57					; 00000039H
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	60					; 0000003cH
	DB	61					; 0000003dH
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	62					; 0000003eH
	DB	63					; 0000003fH
	DB	64					; 00000040H
	DB	65					; 00000041H
	DB	66					; 00000042H
	DB	67					; 00000043H
	DB	68					; 00000044H
	DB	69					; 00000045H
	DB	70					; 00000046H
	DB	71					; 00000047H
	DB	72					; 00000048H
	DB	73					; 00000049H
	DB	-111					; ffffff91H
	DB	74					; 0000004aH
	DB	-111					; ffffff91H
	DB	75					; 0000004bH
	DB	76					; 0000004cH
	DB	77					; 0000004dH
	DB	78					; 0000004eH
	DB	79					; 0000004fH
	DB	80					; 00000050H
	DB	81					; 00000051H
	DB	82					; 00000052H
	DB	83					; 00000053H
	DB	84					; 00000054H
	DB	85					; 00000055H
	DB	86					; 00000056H
	DB	87					; 00000057H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	88					; 00000058H
	DB	89					; 00000059H
	DB	90					; 0000005aH
	DB	91					; 0000005bH
	DB	84					; 00000054H
	DB	92					; 0000005cH
	DB	93					; 0000005dH
	DB	94					; 0000005eH
	DB	95					; 0000005fH
	DB	96					; 00000060H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	99					; 00000063H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	105					; 00000069H
	DB	106					; 0000006aH
	DB	107					; 0000006bH
	DB	108					; 0000006cH
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	113					; 00000071H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	118					; 00000076H
	DB	119					; 00000077H
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	122					; 0000007aH
	DB	123					; 0000007bH
	DB	124					; 0000007cH
	DB	125					; 0000007dH
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	126					; 0000007eH
	DB	127					; 0000007fH
	DB	-128					; ffffff80H
	DB	-127					; ffffff81H
	DB	-126					; ffffff82H
	DB	-125					; ffffff83H
	DB	-124					; ffffff84H
	DB	-123					; ffffff85H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-122					; ffffff86H
	DB	-121					; ffffff87H
	DB	-120					; ffffff88H
	DB	-119					; ffffff89H
	DB	-118					; ffffff8aH
	DB	-117					; ffffff8bH
	DB	-116					; ffffff8cH
	DB	-115					; ffffff8dH
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-111					; ffffff91H
	DB	-114					; ffffff8eH
	DB	-113					; ffffff8fH
	DB	-112					; ffffff90H
?opcode_labels@?L@??interp@avmplus@@YAHPAVMethodEnv@2@HPAI@Z@4PAPAXA:
DD	$L_illegal_op$40569
DD	$L_bkpt$39622
DD	$L_illegal_op$40569
DD	$L_throw$40538
DD	$L_getsuper$40450
DD	$L_setsuper$40457
DD	$L_dxns$40548
DD	$L_dxnslate$40550
DD	$L_kill$39714
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_ifnlt$40117
DD	$L_ifnle$40147
DD	$L_ifngt$40177
DD	$L_ifnge$40207
DD	$L_jump$39636
DD	$L_iftrue$40008
DD	$L_iffalse$40019
DD	$L_ifeq$40030
DD	$L_ifne$40048
DD	$L_iflt$40102
DD	$L_ifle$40132
DD	$L_ifgt$40162
DD	$L_ifge$40192
DD	$L_ifstricteq$40066
DD	$L_ifstrictne$40084
DD	$L_lookupswitch$39999
DD	$L_pushwith$40506
DD	$L_popscope$40517
DD	$L_nextname$40322
DD	$L_hasnext$40330
DD	$L_pushnull$39641
DD	$L_pushundefined$39643
DD	$L_illegal_op$40569
DD	$L_nextvalue$40326
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_pushtrue$39662
DD	$L_pushfalse$39664
DD	$L_pushnan$39666
DD	$L_pop$39668
DD	$L_dup$39670
DD	$L_swap$39672
DD	$L_pushstring$39645
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_pushdouble$39647
DD	$L_pushscope$40502
DD	$L_pushnamespace$39650
DD	$L_hasnext2$40334
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_newfunction$40378
DD	$L_call$40370
DD	$L_construct$40374
DD	$L_callmethod$40393
DD	$L_callstatic$40387
DD	$L_callsuper$40434
DD	$L_callproperty$40404
DD	$L_returnvoid$39610
DD	$L_returnvalue$39615
DD	$L_constructsuper$40466
DD	$L_constructprop$40422
DD	$L_illegal_op$40569
DD	$L_callproplex$40410
DD	$L_illegal_op$40569
DD	$L_callsupervoid$40442
DD	$L_callpropvoid$40416
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_applytype$40430
DD	$L_illegal_op$40569
DD	$L_newobject$40262
DD	$L_newarray$40266
DD	$L_newactivation$40511
DD	$L_newclass$40381
DD	$L_getdescendants$40304
DD	$L_newcatch$40513
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_findpropstrict$40311
DD	$L_findproperty$40315
DD	$L_finddef$40319
DD	$L_getlex$40270
DD	$L_setproperty$40283
DD	$L_getlocal$39652
DD	$L_setlocal$39727
DD	$L_getglobalscope$40500
DD	$L_getscopeobject$40494
DD	$L_getproperty$40274
DD	$L_getouterscope$40497
DD	$L_initproperty$40296
DD	$L_illegal_op$40569
DD	$L_deleteproperty$40340
DD	$L_illegal_op$40569
DD	$L_getslot$40356
DD	$L_setslot$40350
DD	$L_getglobalslot$40365
DD	$L_setglobalslot$40358
DD	$L_convert_s$39675
DD	$L_esc_xelem$39678
DD	$L_esc_xattr$39680
DD	$L_convert_i$40524
DD	$L_convert_u$40533
DD	$L_convert_d$39685
DD	$L_convert_b$39688
DD	$L_convert_o$39702
DD	$L_checkfilter$40309
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_coerce$40476
DD	$L_coerce_b$39695
DD	$L_coerce_a$39620
DD	$L_coerce_i$40520
DD	$L_coerce_d$39682
DD	$L_coerce_s$40482
DD	$L_astype$40469
DD	$L_astypelate$40472
DD	$L_coerce_u$40528
DD	$L_coerce_o$40479
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_negate$39705
DD	$L_increment$39737
DD	$L_inclocal$39765
DD	$L_decrement$39795
DD	$L_declocal$39823
DD	$L_typeof$39716
DD	$L_not$39718
DD	$L_bitnot$39725
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_add$39853
DD	$L_subtract$39889
DD	$L_multiply$39925
DD	$L_divide$39934
DD	$L_modulo$39941
DD	$L_lshift$39953
DD	$L_rshift$39963
DD	$L_urshift$39970
DD	$L_bitand$39980
DD	$L_bitor$39985
DD	$L_bitxor$39990
DD	$L_equals$39995
DD	$L_strictequals$39997
DD	$L_lessthan$40222
DD	$L_lessequals$40232
DD	$L_greaterthan$40242
DD	$L_greaterequals$40252
DD	$L_instanceof$40540
DD	$L_istype$40486
DD	$L_istypelate$40490
DD	$L_in$40544
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_increment_i$39751
DD	$L_decrement_i$39809
DD	$L_inclocal_i$39780
DD	$L_declocal_i$39838
DD	$L_negate_i$39712
DD	$L_add_i$39871
DD	$L_subtract_i$39907
DD	$L_multiply_i$39932
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_getlocal0$39654
DD	$L_getlocal1$39656
DD	$L_getlocal2$39658
DD	$L_getlocal3$39660
DD	$L_setlocal0$39729
DD	$L_setlocal1$39731
DD	$L_setlocal2$39733
DD	$L_setlocal3$39735
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_debugline$39624
DD	$L_debugfile$39632
DD	$L_bkptline$39628
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_ext_pushbits$40557
DD	$L_ext_push_doublebits$40554
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
DD	$L_illegal_op$40569
?interp@avmplus@@YAHPAVMethodEnv@1@HPAI@Z ENDP		; avmplus::interp
_TEXT	ENDS
PUBLIC	?interp32@avmplus@@YAHPAVMethodEnv@1@HPAI@Z	; avmplus::interp32
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_env$ = 8						; size = 4
_argc$ = 12						; size = 4
_ap$ = 16						; size = 4
?interp32@avmplus@@YAHPAVMethodEnv@1@HPAI@Z PROC	; avmplus::interp32

; 110  : 		Atom a = interp(env, argc, ap);

	mov	eax, DWORD PTR _ap$[esp-4]
	mov	ecx, DWORD PTR _argc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _env$[esp]
	push	eax
	push	ecx
	push	esi
	call	?interp@avmplus@@YAHPAVMethodEnv@1@HPAI@Z ; avmplus::interp

; 111  : 		Traits* t = env->method->returnTraits();

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+40]

; 112  : 		AvmCore* core = env->core();

	mov	edx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [edx+4]
	add	esp, 12					; 0000000cH

; 113  : 		if (!t || t == OBJECT_TYPE || t == VOID_TYPE)

	test	ecx, ecx
	pop	esi
	je	SHORT $LN6@interp32
	cmp	ecx, DWORD PTR [edx+128]
	je	SHORT $LN6@interp32
	cmp	ecx, DWORD PTR [edx+164]
	je	SHORT $LN6@interp32

; 114  : 			return a;
; 115  : 		if (t == INT_TYPE)

	cmp	ecx, DWORD PTR [edx+120]
	jne	SHORT $LN3@interp32

; 116  : 			return AvmCore::integer_i(a);

	push	eax
	call	?integer_i@AvmCore@avmplus@@SAHH@Z	; avmplus::AvmCore::integer_i
	add	esp, 4

; 122  : 	}

	ret	0
$LN3@interp32:

; 117  : 		if (t == UINT_TYPE)

	cmp	ecx, DWORD PTR [edx+124]
	jne	SHORT $LN2@interp32

; 118  : 			return AvmCore::integer_u(a);

	push	eax
	call	?integer_u@AvmCore@avmplus@@SAIH@Z	; avmplus::AvmCore::integer_u
	add	esp, 4

; 122  : 	}

	ret	0
$LN2@interp32:

; 119  : 		if (t == BOOLEAN_TYPE)

	cmp	ecx, DWORD PTR [edx+88]
	jne	SHORT $LN1@interp32

; 120  : 			return a>>3;

	sar	eax, 3

; 122  : 	}

	ret	0
$LN1@interp32:

; 121  : 		return a & ~7; // possibly null pointer

	and	eax, -8					; fffffff8H
$LN6@interp32:

; 122  : 	}

	ret	0
?interp32@avmplus@@YAHPAVMethodEnv@1@HPAI@Z ENDP	; avmplus::interp32
_TEXT	ENDS
PUBLIC	?interpN@avmplus@@YANPAVMethodEnv@1@HPAI@Z	; avmplus::interpN
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv133 = -4						; size = 4
_env$ = 8						; size = 4
_argc$ = 12						; size = 4
_ap$ = 16						; size = 4
?interpN@avmplus@@YANPAVMethodEnv@1@HPAI@Z PROC		; avmplus::interpN

; 125  : 	{

	push	ecx

; 126  : 		Atom a = interp(env, argc, ap);

	mov	eax, DWORD PTR _ap$[esp]
	mov	ecx, DWORD PTR _argc$[esp]
	mov	edx, DWORD PTR _env$[esp]
	push	eax
	push	ecx
	push	edx
	call	?interp@avmplus@@YAHPAVMethodEnv@1@HPAI@Z ; avmplus::interp

; 127  : 		return AvmCore::number_d(a);

	mov	ecx, eax
	and	ecx, 7
	add	esp, 12					; 0000000cH
	cmp	cl, 6
	jne	SHORT $LN12@interpN
	sar	eax, 3
	mov	DWORD PTR tv133[esp+4], eax
	fild	DWORD PTR tv133[esp+4]

; 128  : 	}

	pop	ecx
	ret	0

; 127  : 		return AvmCore::number_d(a);

$LN12@interpN:
	and	eax, -8					; fffffff8H
	fld	QWORD PTR [eax]

; 128  : 	}

	pop	ecx
	ret	0
?interpN@avmplus@@YANPAVMethodEnv@1@HPAI@Z ENDP		; avmplus::interpN
_TEXT	ENDS
END
