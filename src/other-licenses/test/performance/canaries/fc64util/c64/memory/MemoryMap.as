package c64.memory
{
	import flash.utils.Dictionary;
	
	public class MemoryMap
	{
		public static var keywordFromAddress:Array = getKeyword();
		public static var descriptionFromAddress:Array = getDescription();
		public static var addressFromKeyword:Dictionary = getAddress();

		private static function getKeyword():Array {
			var a:Array = [];
			a[0x0] = "D6510"; // 6510 On-Chip I/O DATA Direction Register
			a[0x1] = "R6510"; // 
			a[0x7] = "CHARAC"; // Search Character for Scanning BASIC Text Input
			a[0x8] = "ENDCHR"; // Search Character for Statement Termination or Quote
			a[0x9] = "TRMPOS"; // Column position of the Cursor before the Last TAB or SPC
			a[0xA] = "VERCK"; // Flag: LOAD or VERIFY
			a[0xB] = "COUNT"; // Index into the Text Input Buffer/Number of Array Subscripts
			a[0xC] = "DIMFLG"; // Flags for the Routines That Locate or Build an Array
			a[0xD] = "VALTYP"; // Flag: Type of Data (String or Numeric)
			a[0xE] = "INTFLG"; // Flat: Type of Numeric Data (Integer or Floating Point)
			a[0xF] = "GARBFL"; // Flag for LIST, Garbage Collection, and Program Tokenization
			a[0x10] = "SUBFLG"; // Flag: Subscript Reference to an Array or User-Defined Function Call (FN)
			a[0x11] = "INPFLG"; // Flag: Is Data Input to GET, READ or INPUT?
			a[0x12] = "TANSGN"; // Flag: Sign of the Result of the TAN or SIN Function
			a[0x13] = "CHANNL"; // Current I/O Channel (CMD Logical File) Number
			a[0x16] = "TEMPPT"; // Pointer to the Next Available Space in the Temporary String Stack
			a[0x4D] = "OPMASK"; // Mask for Comparison Operation
			a[0x53] = "FOUR6"; // Constant for Garbage Collection
			a[0x61] = "FACEXP"; // Floating Point Accumulator #1: Exponent
			a[0x66] = "FACSGN"; // Floating Point Accumulator #1: Sign
			a[0x67] = "SGNFLG"; // Number of Terms in a Series Evaluation
			a[0x68] = "BITS"; // Floating Point Accumulator #1: Overflow Digit
			a[0x69] = "ARGEXP"; // Floating Point Accumulator #2: Exponent
			a[0x6E] = "ARGSGN"; // Floating Point Accumulator #2: Sign
			a[0x6F] = "ARISGN"; // Result of a Signed Comparison of Accumulator #1 to Accumulator #2
			a[0x70] = "FACOV"; // Low Order Mantissa Byte of Floating Point Accumulator #1 (For
			a[0x90] = "STATUS"; // Kernal I/O Status Word (ST)
			a[0x91] = "STKEY"; // Flag: Was STOP Key Pressed?
			a[0x92] = "SVXT"; // Timing Constant for Tape Reads
			a[0x93] = "VERCK"; // Flag for Load Routine: 0=LOAD, 1=VERIFY
			a[0x94] = "C3PO"; // Flag: Serial Bus--Output Character Was Buffered
			a[0x95] = "BSOUR"; // Buffered Character for Serial Bus
			a[0x96] = "SYNO"; // Cassette Block Synchronization Number
			a[0x97] = "XSAV"; // Temporary .X Register Save Area
			a[0x98] = "LDTND"; // Number of Open I/O Files/Index to the End of File Tables
			a[0x99] = "DFLTN"; // Default Input Device (Set to 0 for Keyboard)
			a[0x9A] = "DFLTO"; // Default Output (CMD) Device (Set to 3 for the Screen)
			a[0x9B] = "PRTY"; // Tape Character Parity
			a[0x9C] = "DPSW"; // Flag: Tape Byte Received
			a[0x9D] = "MSGFLG"; // Flag: Kernal Message Control
			a[0x9E] = "PTR1"; // Tape Pass 1 Error Log Index
			a[0x9F] = "PTR2"; // Tape Pass 2 Error Log Correction Index
			a[0xA5] = "CNTDN"; // Cassette Synchronization Character Countdown
			a[0xA6] = "BUFPNT"; // Count of Characters in Tape I/O Buffer
			a[0xA7] = "INBIT"; // RS-232 Input Bits/Cassette Temporary Storage Area
			a[0xA8] = "BITCI"; // RS-232 Input Bit Count/Cassete Temporary Storage
			a[0xA9] = "RINONE"; // RS-232 Flag: Check for Start Bit
			a[0xAA] = "RIDATA"; // RS-232 Input Byte Buffer/Cassette Temporary Storage
			a[0xAB] = "RIPRTY"; // RS-232 Input Parity/Cassete Leader Counter
			a[0xB4] = "BITTS"; // RS-232 Output Bit Count/Cassette Temporary Storage
			a[0xB5] = "NXTBIT"; // RS-232 Next Bit to Send/Tape EOT Flag
			a[0xB6] = "RODATA"; // RS-232 Output Byte Buffer
			a[0xB7] = "FNLEN"; // Length of Current Filename
			a[0xB8] = "LA"; // Current Logical File Number
			a[0xB9] = "SA"; // Current Secondary Address
			a[0xBA] = "FA"; // Current Device Number
			a[0xBD] = "ROPRTY"; // RS-232 Output Parity/Cassette Temporary Storage
			a[0xBE] = "FSBLK"; // Cassette Read/Write Block Count
			a[0xBF] = "MYCH"; // Tape Input Byte Buffer
			a[0xC0] = "CAS1"; // Tape Motor Interlock
			a[0xC5] = "LSTX"; // Matrix Coordinate of Last Key Pressed, 64=None Pressed
			a[0xC6] = "NDX"; // Number of Characters in Keyboard Buffer (Queue)
			a[0xC7] = "RVS"; // Flag: Print Reverse Characters? 0=No
			a[0xC8] = "INDX"; // Pointer: End of Logical Line for Input
			a[0xCB] = "SFDX"; // Matrix Coordinate of Current Key Pressed
			a[0xCC] = "BLNSW"; // Cursor Blink Enable: 0=Flash Cursor
			a[0xCD] = "BLNCT"; // Timer: Countdown to Blink Cursor
			a[0xCE] = "GDBLN"; // Character Under Cursor
			a[0xCF] = "BLNON"; // Flag: Was Last Curson Blink on or off?
			a[0xD0] = "CRSW"; // Flag: Input from Keyboard or Screen
			a[0xD3] = "PNTR"; // Cursor Column on Current Line
			a[0xD4] = "QTSW"; // Flag: Editor in Quote Mode? 0=No
			a[0xD5] = "LNMX"; // Maximum Length of Physical Screen Line
			a[0xD6] = "TBLX"; // Current Cursor Physical Line Number
			a[0xD8] = "INSRT"; // Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)
			a[0xFF] = "BASZPT"; // BASIC Temporary Data for Floating Point to ASCII Conversion
			a[0x285] = "TIMOUT"; // Flag: Kernal Variable for IEEE Time-Out
			a[0x286] = "COLOR"; // Current Foreground Color for Text
			a[0x287] = "GDCOL"; // Color of Character under Cursor
			a[0x288] = "HIBASE"; // Top Page of Screen Memory
			a[0x289] = "XMAX"; // Maximum Keyboard Buffer Size
			a[0x28A] = "RPTFLAG"; // Flag: Which Keys Will Repeat?
			a[0x28B] = "KOUNT"; // Counter for Timing the Delay Between Key Repeats
			a[0x28C] = "DELAY"; // Counter for Timing the Delay Until the First Key Repeat Begins
			a[0x28D] = "SHFLAG"; // Flag: SHIFT/CTRL/Logo Keypress
			a[0x28E] = "LSTSHF"; // Last Pattern of SHIFT/CTRL/Logo Keypress
			a[0x291] = "MODE"; // Flag: Enable or Disable Changing Character Sets with SHIFT/Logo
			a[0x292] = "AUTODN"; // Flag: Screen Scrolling Enabled
			a[0x293] = "M51CTR"; // RS-232: Mock 6551 Control Register
			a[0x294] = "M51CDR"; // RS-232: Mock 6551 Command Register
			a[0x298] = "BITNUM"; // RS-232: Number of Bits Left to be Sent/Received
			a[0x29B] = "RIDBE"; // RS-232: Index to End of Receive Buffer
			a[0x29C] = "RIDBS"; // RS-232: Index to Start of Receive Buffer
			a[0x29D] = "RODBS"; // RS-232: Index to Start of Transmit Buffer
			a[0x29E] = "RODBE"; // RS-232: Index to End of Transmit Buffer
			a[0x2A1] = "ENABL"; // RS-232 Interrupts Enabled
			a[0x30C] = "SAREG"; // Storage Area for .A Register (Accumulator)
			a[0x30D] = "SXREG"; // Storage Area for .X Index Register
			a[0x30E] = "SYREG"; // Storage Area for .Y Index Register
			a[0x30F] = "SPREG"; // Storage Area for .P (Status) Register
			a[0x310] = "USRPOK"; // Jump Instruction for User Function ($4C)
			a[0xA3B8] = "BLTU"; // Open a Space in Memory for a New Program Line or Variable
			a[0xA49C] = "MAIN1"; // Add or Replace a Line of Program Text
			a[0xA533] = "LINKPRG"; // Relink Lines of Tokenized Program Text
			a[0xA560] = "INLIN"; // Input a Line to Buffer from Keyboard
			a[0xA579] = "CRUNCH"; // Tokenize Line in Input Buffer
			a[0xA613] = "FINDLN"; // Search for Line Number
			a[0xA642] = "SCRTCH"; // Perform NEW
			a[0xA65E] = "CLEAR"; // Perform CLR
			a[0xA68E] = "RUNC"; // Reset Pointer to Current Text Character to the Beginning of Program
			a[0xA717] = "QPLOP"; // Print BASIC Tokens as ASCII Characters
			a[0xA742] = "FOR"; // Perform FOR
			a[0xA7AE] = "NEWSTT"; // Set Up Next Statement for Execution
			a[0xA7E4] = "GONE"; // Read and Execute the Next Statement
			a[0xA81D] = "RESTOR"; // Perform RESTORE
			a[0xA857] = "CONT"; // Perform CONT
			a[0xA871] = "RUN"; // Perform RUN
			a[0xA883] = "GOSUB"; // Perform GOSUB
			a[0xA8A0] = "GOTO"; // Perform GOTO
			a[0xA8D2] = "RETURN"; // Perform RETURN
			a[0xA8F8] = "DATA"; // Perform DATA
			a[0xA906] = "DATAN"; // Search Program Text for the End of the Current BASIC Statement
			a[0xA928] = "IF"; // Perform IF
			a[0xA93B] = "REM"; // Perform REM
			a[0xA94B] = "ONGOTO"; // Perform ON GOTO or ON GOSUB
			a[0xA96B] = "LINGET"; // Convert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber
			a[0xA9A5] = "LET"; // Perform LET
			a[0xAA80] = "PRINTN"; // Perform PRINT#
			a[0xAA86] = "CMD"; // Perform CMD
			a[0xAAA0] = "PRINT"; // Perform PRINT
			a[0xAB1E] = "STROUT"; // Print Message from a String Whose Address Is in the .Y and .A
			a[0xAB4D] = "DOAGIN"; // Error Message Formatting Routines for GET, INPUT, and READ
			a[0xAB7B] = "GET"; // Perform GET and GET#
			a[0xABA5] = "INPUTN"; // Perform INPUT#
			a[0xABBF] = "INPUT"; // Perform INPUT
			a[0xAC06] = "READ"; // Perform READ
			a[0xACFC] = "EXIGNT"; // ASCII Text for Input Error Messages
			a[0xAD1E] = "NEXT"; // Perform NEXT
			a[0xAD8A] = "FRMNUM"; // Evaluate a Numeric Expression and/or Check for Data Type Mismatch
			a[0xAD9E] = "FRMEVAL"; // Evaluate Expression
			a[0xAE83] = "EVAL"; // Convert a Single Numeric Term from ASCII Text to a Floating Point
			a[0xAEA8] = "PIVAL"; // PI Expressed as a Five-Byte Floating Point Number
			a[0xAEF1] = "PARCHK"; // Evaluate Expression Within Parentheses
			a[0xAEF7] = "CHKCLS"; // Check for and Skip Closing Parentheses
			a[0xAEFA] = "CHKOPN"; // Check for and Skip Opening Parentheses
			a[0xAEFF] = "CHKCOM"; // Check for and Skip Comma
			a[0xAF08] = "SNERR"; // Print Syntax Error Message
			a[0xAF2B] = "ISVAR"; // Get the Value of a Variable
			a[0xAFA7] = "ISFUN"; // Dispatch and Evaluate a Function
			a[0xAFE6] = "OROP"; // Perform OR
			a[0xAFE9] = "ANDOP"; // Perform AND
			a[0xB016] = "DORE1"; // Perform Comparisons
			a[0xB08B] = "PTRGET"; // Search for a Variable and Set It Up If It Is Not Found
			a[0xB11D] = "NOTFNS"; // Create a New BASIC Variable
			a[0xB185] = "FINPTR"; // Return the Address of the Variable That Was Found or Created
			a[0xB194] = "ARYGET"; // Allocate Space for Array Descriptors
			a[0xB1A5] = "N32768"; // The Constant -32768 in Five-Byte Floating Point Format
			a[0xB1B2] = "INTIDX"; // Input and Convert a Floating Point Subscript to a Positive Integer
			a[0xB1BF] = "AYINT"; // Convert a Floating Point Number to a Signed Integer
			a[0xB1D1] = "ISARY"; // Find Array Element or Create New Array in RAM
			a[0xB245] = "BSERR"; // Print BAD SUBSCRIPT Error Message
			a[0xB248] = "FCERR"; // Print ILLEGAL QUANTITY Error Message
			a[0xB34C] = "UMULT"; // Compute the Size of a Multidimensional Array
			a[0xB37D] = "FRE"; // Perform FRE
			a[0xB391] = "GIVAYF"; // Convert 16-Bit Signed Integer to Floating Point
			a[0xB39E] = "POS"; // Perform POS
			a[0xB3A6] = "ERRDIR"; // Check If the Program is Running in Direct Mode, and If So Issue an Error
			a[0xB3B3] = "DEF"; // Perform DEF
			a[0xB3E1] = "GETFNM"; // Check DEF and FN Syntax
			a[0xB3F4] = "FNDOER"; // Perform FN
			a[0xB465] = "STRD"; // Perform STR$
			a[0xB487] = "STRLIT"; // Scan and Set Up Pointers to a String in Memory
			a[0xB4F4] = "GETSPA"; // Allocate Space in Memory for String
			a[0xB526] = "GARBAG"; // String Garbage Collection
			a[0xB63D] = "CAT"; // Concatenate Two Strings
			a[0xB67A] = "MOVINS"; // Move a String in Memory
			a[0xB6A3] = "FRESTR"; // Discard a Temporary String
			a[0xB6DB] = "FRETMS"; // Remove an Entry from the String Descriptor Stack
			a[0xB6EC] = "CHRD"; // Perform CHR$
			a[0xB700] = "LEFTD"; // Perform LEFT$
			a[0xB72C] = "RIGHTD"; // Perform RIGHT$
			a[0xB737] = "MIDD"; // Perform MID$
			a[0xB761] = "PREAM"; // Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$
			a[0xB77C] = "LEN"; // Perform LEN
			a[0xB78B] = "ASC"; // Perform ASC
			a[0xB79B] = "GETBYTC"; // Input a Parameter Whose Value Is Between 0 and 255
			a[0xB7AD] = "VAL"; // Perform VAL
			a[0xB7EB] = "GETNUM"; // Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)
			a[0xB7F7] = "GETADR"; // Convert a Floating Point Number to an Unsigned Two-Byte Integer
			a[0xB80D] = "PEEK"; // Perform PEEK
			a[0xB824] = "POKE"; // Perform POKE
			a[0xB82D] = "FUWAIT"; // Perform WAIT
			a[0xB849] = "FADDH"; // Add .5 to Contents of Floating Point Accumulator #1
			a[0xB850] = "FSUB"; // Subtract FAC1 from a Number in Memory
			a[0xB853] = "FSUBT"; // BASIC's Subtraction Operation
			a[0xB867] = "FADD"; // Add FAC1 to a Number in Memory
			a[0xB86A] = "FADDT"; // Perform BASIC's Addition Operation
			a[0xB8A7] = "FADD4"; // Make the Result Negative If a Borrow Was Done
			a[0xB8FE] = "NORMAL"; // Normalize Floating Point Accumulator #1
			a[0xB947] = "NEGFAC"; // Replace FAC1 with Its 2's Complement
			a[0xB97E] = "OVERR"; // Print Overflow Error Message
			a[0xB983] = "MULSHF"; // SHIFT Routine
			a[0xB9BC] = "FONE"; // Floating Point Constant with a Value of 1
			a[0xB9C1] = "LOGCN2"; // Table of Floating Point Constants for the LOG Function
			a[0xB9EA] = "LOG"; // Perform LOG to Base E
			a[0xBA28] = "FMULT"; // Multiply FAC1 with FAC2
			a[0xBA59] = "MLTPLY"; // Multiply a Byte Subroutine
			a[0xBA8C] = "CONUPK"; // Move a Floating Point Number from Memory into FAC2
			a[0xBAB7] = "MULDIV"; // Add Exponent of FAC1 to Exponent of FAC2
			a[0xBAD4] = "MLDVEX"; // Handle Underflow or Overflow
			a[0xBAE2] = "MUL10"; // Multiply FAC1 by 10
			a[0xBAF9] = "TENC"; // The Constant 10 in Five-Byte Floating Format
			a[0xBAFE] = "DIV10"; // Divide FAC1 by 10
			a[0xBB0F] = "FDIV"; // Divide a Number in Memory by FAC1
			a[0xBB12] = "FDIVT"; // Divide FAC2 by FAC1
			a[0xBBA2] = "MOVFM"; // Move a Floating Point Number from Memory to FAC1
			a[0xBBC7] = "MOV2F"; // Move a Floating Point Number from FAC1 to Memory
			a[0xBBFC] = "MOVFA"; // Move a Floating Point Number from FAC2 to FAC1
			a[0xBC0C] = "MOVAF"; // Round and Move a Floating Point Number from FAC1 to FAC2
			a[0xBC0F] = "MOVEF"; // Copy FAC1 to FAC2 Without Rounding
			a[0xBC1B] = "ROUND"; // Round Accumulator #1 by Adjusting the Rounding Byte
			a[0xBC2B] = "SIGN"; // Put the Sign of Accumulator #1 into .A Register
			a[0xBC39] = "SGN"; // Perform SGN
			a[0xBC58] = "ABS"; // Perform ABS
			a[0xBC5B] = "FCOMP"; // Compare FAC1 to Memory
			a[0xBC9B] = "QINT"; // Convert FAC1 into Integer Within FAC1
			a[0xBCCC] = "INT"; // Perform INT
			a[0xBCF3] = "FIN"; // Convert an ASCII String to a Floating Point Number FAC1
			a[0xBD7E] = "FINLOG"; // Add Signed Integer to FAC1
			a[0xBDB3] = "NO999"; // 
			a[0xBDC0] = "INPRT"; // Print IN Followed by a Line Number
			a[0xBDCD] = "LINPRT"; // Output a Number in ASCII Decimal Digits
			a[0xBDDD] = "FOUT"; // Convert Contents of FAC1 to ASCII String
			a[0xBF11] = "FHALF"; // The Constant Value 1/2 in Five-Byte Floating Point Notation
			a[0xBF1C] = "FOUTBL"; // Powers of Minus Ten Constants Table
			a[0xBF3A] = "FDCEND"; // Table of Constants for TI$ Conversion
			a[0xBF71] = "SQR"; // Perform SQR
			a[0xBF7B] = "FPWRT"; // Performs Exponentation (Power Calculation Called for by UPARROW)
			a[0xBFB4] = "NEGOP"; // Perform NOT and >
			a[0xBFBF] = "EXPCON"; // Table of Constants for EXP and LOG in Five-Byte Floating Point Format
			a[0xBFED] = "EXP"; // Perform EXP
			a[0xD000] = "SP0X"; // Sprite 0 Horizontal Position
			a[0xD001] = "SP0Y"; // Sprite 0 Vertical Position
			a[0xD002] = "SP1X"; // Sprite 1 Horizontal Position
			a[0xD003] = "SP1Y"; // Sprite 1 Vertical Position
			a[0xD004] = "SP2X"; // Sprite 2 Horizontal Position
			a[0xD005] = "SP2Y"; // Sprite 2 Vertical Position
			a[0xD006] = "SP3X"; // Sprite 3 Horizontal Position
			a[0xD007] = "SP3Y"; // Sprite 3 Vertical Position
			a[0xD008] = "SP4X"; // Sprite 4 Horizontal Position
			a[0xD009] = "SP4Y"; // Sprite 4 Vertical Position
			a[0xD00A] = "SP5X"; // Sprite 5 Horizontal Position
			a[0xD00B] = "SP5Y"; // Sprite 5 Vertical Position
			a[0xD00C] = "SP6X"; // Sprite 6 Horizontal Position
			a[0xD00D] = "SP6Y"; // Sprite 6 Vertical Position
			a[0xD00E] = "SP7X"; // Sprite 7 Horizontal Position
			a[0xD00F] = "SP7Y"; // Sprite 7 Vertical Position
			a[0xD010] = "MSIGX"; // Most Significant Bits of Sprites 0-7 Horizontal Position
			a[0xD011] = "SCROLY"; // Vertical Fine Scrolling and Control Register
			a[0xD012] = "RASTER"; // Read Current Raster Scan Line/Write Line to Compare for Raster IRQ
			a[0xD013] = "LPENX"; // Light Pen Horizontal Position
			a[0xD014] = "LPENY"; // Light Pen Vertical Position
			a[0xD015] = "SPENA"; // Sprite Enable Register
			a[0xD016] = "SCROLX"; // Horizontal Fine Scrolling and Control Register
			a[0xD017] = "YXPAND"; // Sprite Vertical Expansion Register
			a[0xD018] = "VMCSB"; // VIC-II Chip Memory Control Register
			a[0xD019] = "VICIRQ"; // VIC Interrupt Flag Register
			a[0xD01A] = "IRQMASK"; // IRQ Mask Register
			a[0xD01B] = "SPBGPR"; // Sprite to Foreground Display Priority Register
			a[0xD01C] = "SPMC"; // Sprite Multicolor Registers
			a[0xD01D] = "XXPAND"; // Sprite Horizontal Expansion Register
			a[0xD01E] = "SPSPCL"; // Sprite to Sprite Collision Register
			a[0xD01F] = "SPBGCL"; // Sprite to Foreground Collision Register
			a[0xD020] = "EXTCOL"; // Border Color Register
			a[0xD021] = "BGCOL0"; // Background Color 0
			a[0xD022] = "BGCOL1"; // Background Color 1
			a[0xD023] = "BGCOL2"; // Background Color 2
			a[0xD025] = "SPMC0"; // Sprite Multicolor Register 0
			a[0xD026] = "SPMC1"; // Sprite Multicolor Register 1
			a[0xD027] = "SP0COL"; // Sprite 0 Color Register (the default color value is 1, white)
			a[0xD028] = "SP1COL"; // Sprite 1 Color Register (the default color value is 2, red)
			a[0xD029] = "SP2COL"; // Sprite 2 Color Register (the default color value is 3, cyan)
			a[0xD400] = "FRELO1"; // Voice 1 Frequency Control (low byte)
			a[0xD401] = "FREHI1"; // Voice 1 Frequency Control (high byte)
			a[0xD402] = "PWLO1"; // Voice 1 Pulse Waveform Width (low byte)
			a[0xD403] = "PWHI1"; // Voice 1 Pulse Waveform Width (high nybble)
			a[0xD404] = "VCREG1"; // Voice 1 Control Register
			a[0xD405] = "ATDCY1"; // Voice 1 Attack/Decay Register
			a[0xD406] = "SUREL1"; // Voice 1 Sustain/Release Control Register
			a[0xD407] = "FRELO2"; // Voice 2 Frequency Control (low byte)
			a[0xD408] = "FREHI2"; // Voice 2 Frequency Control (high byte)
			a[0xD409] = "PWLO2"; // Voice 2 Pulse Waveform Width (low byte)
			a[0xD40A] = "PWHI2"; // Voice 2 Pulse Waveform Width (high nybble)
			a[0xD40B] = "VCREG2"; // Voice 2 Control Register
			a[0xD40C] = "ATDCY2"; // Voice 2 Attack/Decay Register
			a[0xD40D] = "SUREL2"; // Voice 2 Sustain/Release Control Register
			a[0xD40E] = "FRELO3"; // Voice 3 Frequency Control (low byte)
			a[0xD40F] = "FREHI3"; // Voice 3 Frequency Control (high byte)
			a[0xD410] = "PWLO3"; // Voice 3 Pulse Waveform Width (low byte)
			a[0xD411] = "PWHI3"; // Voice 3 Pulse Waveform Width (high nybble)
			a[0xD412] = "VCREG3"; // Voice 3 Control Register
			a[0xD413] = "ATDCY3"; // Voice 3 Attack/Decay Register
			a[0xD414] = "SUREL3"; // Voice 3 Sustain/Release Control Register
			a[0xD415] = "CUTLO"; // 
			a[0xD416] = "CUTHI"; // Filter Cutoff Frequency (high byte)
			a[0xD417] = "RESON"; // Filter Resonance Control Register
			a[0xD418] = "SIGVOL"; // Volume and Filter Select Register
			a[0xD419] = "POTX"; // Read Game Paddle 1 (or 3) Position
			a[0xD41A] = "POTY"; // Read Game Paddle 2 (or 4) Position
			a[0xD41B] = "RANDOM"; // Read Oscillator 3/Random Number Generator
			a[0xD41C] = "ENV3"; // Envelope Generator 3 Output
			a[0xDC00] = "CIAPRA"; // Data Port Register A
			a[0xDC01] = "CIAPRB"; // Data Port Register B
			a[0xDC02] = "CIDDRA"; // Data Direction Register A
			a[0xDC03] = "CIDDRB"; // Data Direction Register B
			a[0xDC04] = "TIMALO"; // Timer A (low byte)
			a[0xDC05] = "TIMAHI"; // Timer A (high byte)
			a[0xDC06] = "TIMBLO"; // Timer B (low byte)
			a[0xDC07] = "TIMBHI"; // Timer B (high byte)
			a[0xDC08] = "TODTEN"; // Time of Day Clock Tenths of Seconds
			a[0xDC09] = "TODSEC"; // Time of Day Clock Seconds
			a[0xDC0A] = "TODMIN"; // Time of Day Clock Minutes
			a[0xDC0B] = "TODHRS"; // Time of Day Clock Hours
			a[0xDC0C] = "CIASDR"; // Serial Data Port
			a[0xDC0D] = "CIAICR"; // Interrupt Control Register
			a[0xDC0E] = "CIACRA"; // Control Register A
			a[0xDC0F] = "CIACRB"; // Control Register B
			a[0xDD00] = "CI2PRA"; // Data Port Register A
			a[0xDD01] = "CI2PRB"; // Data Port B
			a[0xDD02] = "C2DDRA"; // Data Direction Register A
			a[0xDD03] = "C2DDRB"; // Data Direction Register B
			a[0xDD04] = "TI2ALO"; // Timer A (low byte)
			a[0xDD05] = "TI2AHI"; // Timer A (high byte)
			a[0xDD06] = "TI2BLO"; // Timer B (low byte)
			a[0xDD07] = "TI2BHI"; // Timer B (high byte)
			a[0xDD08] = "TO2TEN"; // Time of Day Clock Tenths of Seconds
			a[0xDD09] = "TO2SEC"; // Time of Day Clock Seconds
			a[0xDD0A] = "TO2MIN"; // Time of Day Clock Minutes
			a[0xDD0B] = "TO2HRS"; // Time of Day Clock Hours
			a[0xDD0C] = "CI2SDR"; // Serial Data Port
			a[0xDD0D] = "CI2ICR"; // Interrupt Control Register
			a[0xDD0E] = "CI2CRA"; // Control Register A
			a[0xDD0F] = "CI2CRB"; // Control Register B
			a[0xE043] = "POLY1"; // Function Series Evaluation Subroutine 1
			a[0xE059] = "POLY2"; // Function Series Evaluation Subroutine 2
			a[0xE08D] = "RMULC"; // Multiplicative Constant for RND
			a[0xE092] = "RADDC"; // Additive Constant for RND
			a[0xE097] = "RND"; // Perform RND
			a[0xE12A] = "SYS"; // Perform SYS
			a[0xE156] = "SAVE"; // Perform SAVE
			a[0xE165] = "VERIFY"; // Perform VERIFY
			a[0xE168] = "LOAD"; // Perform LOAD
			a[0xE1BE] = "OPEN"; // Perform OPEN
			a[0xE1C7] = "CLOSE"; // Perform CLOSE
			a[0xE264] = "COS"; // Perform COS
			a[0xE268] = "SIN"; // Perform SIN
			a[0xE2B4] = "TAN"; // Perform TAN
			a[0xE2E0] = "PI2"; // The Five-Byte Floating Point Representation of the Constant PI/2
			a[0xE2E5] = "TWOPI"; // The Five-Byte Floating Point Representation of the Constant 2*PI
			a[0xE2EA] = "FR4"; // The Five-Byte Floating Point Representation of the Constant 1/4
			a[0xE2EF] = "SINCON"; // Table of Constants for Evaluation of SIN, COS, and TAN
			a[0xE30E] = "ATN"; // Perform ATN
			a[0xE33E] = "ATNCON"; // Table of Constants for ATN Evaluation
			a[0xE3A2] = "INITAT"; // Text of the CHRGET Routine Which Runs at 115 ($73)
			a[0xE3BF] = "INIT"; // Initialize BASIC
			a[0xE460] = "WORDS"; // Power-Up Messages
			a[0xE500] = "IOBASE"; // Store Base Address of Memory-Mapped I/O Devices in .X and .Y Registers
			a[0xE505] = "SCREEN"; // Store Number of Screen Rows and Columns in .Y and .X
			a[0xE50A] = "PLOT"; // Read/Set Location of the Cursor
			a[0xE5B4] = "LP2"; // Get a Character from the Keyboard Buffer
			a[0xEA87] = "SCNKEY"; // Read the Keyboard
			a[0xED09] = "TALK"; // Send TALK to a Device on the Serial Bus
			a[0xED0C] = "LISTEN"; // 
			a[0xEDB9] = "SECOND"; // Send a Secondary Address to a Device on the Serial Bus after LISTEN
			a[0xEDC7] = "TKSA"; // Send a Secondary Address to a Device on the Serial Bus after TALK
			a[0xEDDD] = "CIOUT"; // Send a Byte to an I/O Device over the Serial Bus
			a[0xEDEF] = "UNTLK"; // Send UNTALK to a Device on the Serial Bus
			a[0xEDFE] = "UNLSN"; // Send UNLISTED to a Device on the Serial Bus
			a[0xEE13] = "ACPTR"; // Receive a Byte of Data from a Device on the Serial Bus
			a[0xF13E] = "GETIN"; // Get One Byte from the Input Device
			a[0xF157] = "CHRIN"; // Input a Character from the Current Device
			a[0xF1CA] = "CHROUT"; // Output a Byte
			a[0xF20E] = "CHKIN"; // Designate a Logical File As the Current Input Channel
			a[0xF250] = "CHKOUT"; // Designate a Logical File As the Current Output Channel
			a[0xF291] = "CLOSE"; // Close a Logical I/O File
			a[0xF32F] = "CLALL"; // Close All Logical I/O Files
			a[0xF333] = "CLRCHN"; // Restore Current Input and Output Devices to the Default Devices
			a[0xF34A] = "OPEN"; // Open a Logical I/O File
			a[0xF49E] = "LOAD"; // Load RAM from a Device
			a[0xF5DD] = "SAVE"; // Save RAM to a Device
			a[0xF69B] = "UDTIM"; // Update the Software Clock and Check for the STOP Key
			a[0xF6DD] = "RDTIM"; // Read the Time From the Software Clock into the .A, .X, and .Y
			a[0xF6E4] = "SETTIM"; // Set the Software Clock from the .A, .X, and .Y Registers
			a[0xF6ED] = "STOP"; // Test STOP Key
			a[0xFD15] = "RESTOR"; // Restore RAM Vectors for Default I/O Routines
			a[0xFD1A] = "VECTOR"; // Set the RAM Vector Table from the Table Pointed to by .X and .Y
			a[0xFD50] = "RAMTAS"; // Perform RAM Test and Set Pointers to the Top and Bottom of RAM
			a[0xFDA3] = "IOINIT"; // Initialize CIA I/O Devices
			a[0xFDF9] = "SETNAM"; // Set Filename Parameters
			a[0xFE00] = "SETLFS"; // Set Logical File Number, Device Number, and Secondary Address
			a[0xFE07] = "READST"; // Read the I/O Status Word
			a[0xFE18] = "SETMSG"; // Set the Message Control Flag
			a[0xFE25] = "MEMTOP"; // Read/Set Top of RAM Pointer
			a[0xFE34] = "MEMBOT"; // Read/Set Bottom of RAM Pointer
			a[0xFF5B] = "CINT"; // Initialize Screen Editor and VIC-II Chip
			return a;
		}

		private static function getDescription():Array {
			var a:Array = [];
			a[0x0] = "6510 On-Chip I/O DATA Direction Register";
			a[0x7] = "Search Character for Scanning BASIC Text Input";
			a[0x8] = "Search Character for Statement Termination or Quote";
			a[0x9] = "Column position of the Cursor before the Last TAB or SPC";
			a[0xA] = "Flag: LOAD or VERIFY";
			a[0xB] = "Index into the Text Input Buffer/Number of Array Subscripts";
			a[0xC] = "Flags for the Routines That Locate or Build an Array";
			a[0xD] = "Flag: Type of Data (String or Numeric)";
			a[0xE] = "Flat: Type of Numeric Data (Integer or Floating Point)";
			a[0xF] = "Flag for LIST, Garbage Collection, and Program Tokenization";
			a[0x10] = "Flag: Subscript Reference to an Array or User-Defined Function Call (FN)";
			a[0x11] = "Flag: Is Data Input to GET, READ or INPUT?";
			a[0x12] = "Flag: Sign of the Result of the TAN or SIN Function";
			a[0x13] = "Current I/O Channel (CMD Logical File) Number";
			a[0x16] = "Pointer to the Next Available Space in the Temporary String Stack";
			a[0x4D] = "Mask for Comparison Operation";
			a[0x53] = "Constant for Garbage Collection";
			a[0x61] = "Floating Point Accumulator #1: Exponent";
			a[0x66] = "Floating Point Accumulator #1: Sign";
			a[0x67] = "Number of Terms in a Series Evaluation";
			a[0x68] = "Floating Point Accumulator #1: Overflow Digit";
			a[0x69] = "Floating Point Accumulator #2: Exponent";
			a[0x6E] = "Floating Point Accumulator #2: Sign";
			a[0x6F] = "Result of a Signed Comparison of Accumulator #1 to Accumulator #2";
			a[0x70] = "Low Order Mantissa Byte of Floating Point Accumulator #1 (For";
			a[0x90] = "Kernal I/O Status Word (ST)";
			a[0x91] = "Flag: Was STOP Key Pressed?";
			a[0x92] = "Timing Constant for Tape Reads";
			a[0x93] = "Flag for Load Routine: 0=LOAD, 1=VERIFY";
			a[0x94] = "Flag: Serial Bus--Output Character Was Buffered";
			a[0x95] = "Buffered Character for Serial Bus";
			a[0x96] = "Cassette Block Synchronization Number";
			a[0x97] = "Temporary .X Register Save Area";
			a[0x98] = "Number of Open I/O Files/Index to the End of File Tables";
			a[0x99] = "Default Input Device (Set to 0 for Keyboard)";
			a[0x9A] = "Default Output (CMD) Device (Set to 3 for the Screen)";
			a[0x9B] = "Tape Character Parity";
			a[0x9C] = "Flag: Tape Byte Received";
			a[0x9D] = "Flag: Kernal Message Control";
			a[0x9E] = "Tape Pass 1 Error Log Index";
			a[0x9F] = "Tape Pass 2 Error Log Correction Index";
			a[0xA5] = "Cassette Synchronization Character Countdown";
			a[0xA6] = "Count of Characters in Tape I/O Buffer";
			a[0xA7] = "RS-232 Input Bits/Cassette Temporary Storage Area";
			a[0xA8] = "RS-232 Input Bit Count/Cassete Temporary Storage";
			a[0xA9] = "RS-232 Flag: Check for Start Bit";
			a[0xAA] = "RS-232 Input Byte Buffer/Cassette Temporary Storage";
			a[0xAB] = "RS-232 Input Parity/Cassete Leader Counter";
			a[0xB4] = "RS-232 Output Bit Count/Cassette Temporary Storage";
			a[0xB5] = "RS-232 Next Bit to Send/Tape EOT Flag";
			a[0xB6] = "RS-232 Output Byte Buffer";
			a[0xB7] = "Length of Current Filename";
			a[0xB8] = "Current Logical File Number";
			a[0xB9] = "Current Secondary Address";
			a[0xBA] = "Current Device Number";
			a[0xBD] = "RS-232 Output Parity/Cassette Temporary Storage";
			a[0xBE] = "Cassette Read/Write Block Count";
			a[0xBF] = "Tape Input Byte Buffer";
			a[0xC0] = "Tape Motor Interlock";
			a[0xC5] = "Matrix Coordinate of Last Key Pressed, 64=None Pressed";
			a[0xC6] = "Number of Characters in Keyboard Buffer (Queue)";
			a[0xC7] = "Flag: Print Reverse Characters? 0=No";
			a[0xC8] = "Pointer: End of Logical Line for Input";
			a[0xCB] = "Matrix Coordinate of Current Key Pressed";
			a[0xCC] = "Cursor Blink Enable: 0=Flash Cursor";
			a[0xCD] = "Timer: Countdown to Blink Cursor";
			a[0xCE] = "Character Under Cursor";
			a[0xCF] = "Flag: Was Last Curson Blink on or off?";
			a[0xD0] = "Flag: Input from Keyboard or Screen";
			a[0xD3] = "Cursor Column on Current Line";
			a[0xD4] = "Flag: Editor in Quote Mode? 0=No";
			a[0xD5] = "Maximum Length of Physical Screen Line";
			a[0xD6] = "Current Cursor Physical Line Number";
			a[0xD8] = "Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)";
			a[0xFF] = "BASIC Temporary Data for Floating Point to ASCII Conversion";
			a[0x285] = "Flag: Kernal Variable for IEEE Time-Out";
			a[0x286] = "Current Foreground Color for Text";
			a[0x287] = "Color of Character under Cursor";
			a[0x288] = "Top Page of Screen Memory";
			a[0x289] = "Maximum Keyboard Buffer Size";
			a[0x28A] = "Flag: Which Keys Will Repeat?";
			a[0x28B] = "Counter for Timing the Delay Between Key Repeats";
			a[0x28C] = "Counter for Timing the Delay Until the First Key Repeat Begins";
			a[0x28D] = "Flag: SHIFT/CTRL/Logo Keypress";
			a[0x28E] = "Last Pattern of SHIFT/CTRL/Logo Keypress";
			a[0x291] = "Flag: Enable or Disable Changing Character Sets with SHIFT/Logo";
			a[0x292] = "Flag: Screen Scrolling Enabled";
			a[0x293] = "RS-232: Mock 6551 Control Register";
			a[0x294] = "RS-232: Mock 6551 Command Register";
			a[0x298] = "RS-232: Number of Bits Left to be Sent/Received";
			a[0x29B] = "RS-232: Index to End of Receive Buffer";
			a[0x29C] = "RS-232: Index to Start of Receive Buffer";
			a[0x29D] = "RS-232: Index to Start of Transmit Buffer";
			a[0x29E] = "RS-232: Index to End of Transmit Buffer";
			a[0x2A1] = "RS-232 Interrupts Enabled";
			a[0x30C] = "Storage Area for .A Register (Accumulator)";
			a[0x30D] = "Storage Area for .X Index Register";
			a[0x30E] = "Storage Area for .Y Index Register";
			a[0x30F] = "Storage Area for .P (Status) Register";
			a[0x310] = "Jump Instruction for User Function ($4C)";
			a[0xA3B8] = "Open a Space in Memory for a New Program Line or Variable";
			a[0xA49C] = "Add or Replace a Line of Program Text";
			a[0xA533] = "Relink Lines of Tokenized Program Text";
			a[0xA560] = "Input a Line to Buffer from Keyboard";
			a[0xA579] = "Tokenize Line in Input Buffer";
			a[0xA613] = "Search for Line Number";
			a[0xA642] = "Perform NEW";
			a[0xA65E] = "Perform CLR";
			a[0xA68E] = "Reset Pointer to Current Text Character to the Beginning of Program";
			a[0xA717] = "Print BASIC Tokens as ASCII Characters";
			a[0xA742] = "Perform FOR";
			a[0xA7AE] = "Set Up Next Statement for Execution";
			a[0xA7E4] = "Read and Execute the Next Statement";
			a[0xA81D] = "Perform RESTORE";
			a[0xA857] = "Perform CONT";
			a[0xA871] = "Perform RUN";
			a[0xA883] = "Perform GOSUB";
			a[0xA8A0] = "Perform GOTO";
			a[0xA8D2] = "Perform RETURN";
			a[0xA8F8] = "Perform DATA";
			a[0xA906] = "Search Program Text for the End of the Current BASIC Statement";
			a[0xA928] = "Perform IF";
			a[0xA93B] = "Perform REM";
			a[0xA94B] = "Perform ON GOTO or ON GOSUB";
			a[0xA96B] = "Convert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber";
			a[0xA9A5] = "Perform LET";
			a[0xAA80] = "Perform PRINT#";
			a[0xAA86] = "Perform CMD";
			a[0xAAA0] = "Perform PRINT";
			a[0xAB1E] = "Print Message from a String Whose Address Is in the .Y and .A";
			a[0xAB4D] = "Error Message Formatting Routines for GET, INPUT, and READ";
			a[0xAB7B] = "Perform GET and GET#";
			a[0xABA5] = "Perform INPUT#";
			a[0xABBF] = "Perform INPUT";
			a[0xAC06] = "Perform READ";
			a[0xACFC] = "ASCII Text for Input Error Messages";
			a[0xAD1E] = "Perform NEXT";
			a[0xAD8A] = "Evaluate a Numeric Expression and/or Check for Data Type Mismatch";
			a[0xAD9E] = "Evaluate Expression";
			a[0xAE83] = "Convert a Single Numeric Term from ASCII Text to a Floating Point";
			a[0xAEA8] = "PI Expressed as a Five-Byte Floating Point Number";
			a[0xAEF1] = "Evaluate Expression Within Parentheses";
			a[0xAEF7] = "Check for and Skip Closing Parentheses";
			a[0xAEFA] = "Check for and Skip Opening Parentheses";
			a[0xAEFF] = "Check for and Skip Comma";
			a[0xAF08] = "Print Syntax Error Message";
			a[0xAF2B] = "Get the Value of a Variable";
			a[0xAFA7] = "Dispatch and Evaluate a Function";
			a[0xAFE6] = "Perform OR";
			a[0xAFE9] = "Perform AND";
			a[0xB016] = "Perform Comparisons";
			a[0xB08B] = "Search for a Variable and Set It Up If It Is Not Found";
			a[0xB11D] = "Create a New BASIC Variable";
			a[0xB185] = "Return the Address of the Variable That Was Found or Created";
			a[0xB194] = "Allocate Space for Array Descriptors";
			a[0xB1A5] = "The Constant -32768 in Five-Byte Floating Point Format";
			a[0xB1B2] = "Input and Convert a Floating Point Subscript to a Positive Integer";
			a[0xB1BF] = "Convert a Floating Point Number to a Signed Integer";
			a[0xB1D1] = "Find Array Element or Create New Array in RAM";
			a[0xB245] = "Print BAD SUBSCRIPT Error Message";
			a[0xB248] = "Print ILLEGAL QUANTITY Error Message";
			a[0xB34C] = "Compute the Size of a Multidimensional Array";
			a[0xB37D] = "Perform FRE";
			a[0xB391] = "Convert 16-Bit Signed Integer to Floating Point";
			a[0xB39E] = "Perform POS";
			a[0xB3A6] = "Check If the Program is Running in Direct Mode, and If So Issue an Error";
			a[0xB3B3] = "Perform DEF";
			a[0xB3E1] = "Check DEF and FN Syntax";
			a[0xB3F4] = "Perform FN";
			a[0xB465] = "Perform STR$";
			a[0xB487] = "Scan and Set Up Pointers to a String in Memory";
			a[0xB4F4] = "Allocate Space in Memory for String";
			a[0xB526] = "String Garbage Collection";
			a[0xB63D] = "Concatenate Two Strings";
			a[0xB67A] = "Move a String in Memory";
			a[0xB6A3] = "Discard a Temporary String";
			a[0xB6DB] = "Remove an Entry from the String Descriptor Stack";
			a[0xB6EC] = "Perform CHR$";
			a[0xB700] = "Perform LEFT$";
			a[0xB72C] = "Perform RIGHT$";
			a[0xB737] = "Perform MID$";
			a[0xB761] = "Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$";
			a[0xB77C] = "Perform LEN";
			a[0xB78B] = "Perform ASC";
			a[0xB79B] = "Input a Parameter Whose Value Is Between 0 and 255";
			a[0xB7AD] = "Perform VAL";
			a[0xB7EB] = "Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)";
			a[0xB7F7] = "Convert a Floating Point Number to an Unsigned Two-Byte Integer";
			a[0xB80D] = "Perform PEEK";
			a[0xB824] = "Perform POKE";
			a[0xB82D] = "Perform WAIT";
			a[0xB849] = "Add .5 to Contents of Floating Point Accumulator #1";
			a[0xB850] = "Subtract FAC1 from a Number in Memory";
			a[0xB853] = "BASIC's Subtraction Operation";
			a[0xB867] = "Add FAC1 to a Number in Memory";
			a[0xB86A] = "Perform BASIC's Addition Operation";
			a[0xB8A7] = "Make the Result Negative If a Borrow Was Done";
			a[0xB8FE] = "Normalize Floating Point Accumulator #1";
			a[0xB947] = "Replace FAC1 with Its 2's Complement";
			a[0xB97E] = "Print Overflow Error Message";
			a[0xB983] = "SHIFT Routine";
			a[0xB9BC] = "Floating Point Constant with a Value of 1";
			a[0xB9C1] = "Table of Floating Point Constants for the LOG Function";
			a[0xB9EA] = "Perform LOG to Base E";
			a[0xBA28] = "Multiply FAC1 with FAC2";
			a[0xBA59] = "Multiply a Byte Subroutine";
			a[0xBA8C] = "Move a Floating Point Number from Memory into FAC2";
			a[0xBAB7] = "Add Exponent of FAC1 to Exponent of FAC2";
			a[0xBAD4] = "Handle Underflow or Overflow";
			a[0xBAE2] = "Multiply FAC1 by 10";
			a[0xBAF9] = "The Constant 10 in Five-Byte Floating Format";
			a[0xBAFE] = "Divide FAC1 by 10";
			a[0xBB0F] = "Divide a Number in Memory by FAC1";
			a[0xBB12] = "Divide FAC2 by FAC1";
			a[0xBBA2] = "Move a Floating Point Number from Memory to FAC1";
			a[0xBBC7] = "Move a Floating Point Number from FAC1 to Memory";
			a[0xBBFC] = "Move a Floating Point Number from FAC2 to FAC1";
			a[0xBC0C] = "Round and Move a Floating Point Number from FAC1 to FAC2";
			a[0xBC0F] = "Copy FAC1 to FAC2 Without Rounding";
			a[0xBC1B] = "Round Accumulator #1 by Adjusting the Rounding Byte";
			a[0xBC2B] = "Put the Sign of Accumulator #1 into .A Register";
			a[0xBC39] = "Perform SGN";
			a[0xBC58] = "Perform ABS";
			a[0xBC5B] = "Compare FAC1 to Memory";
			a[0xBC9B] = "Convert FAC1 into Integer Within FAC1";
			a[0xBCCC] = "Perform INT";
			a[0xBCF3] = "Convert an ASCII String to a Floating Point Number FAC1";
			a[0xBD7E] = "Add Signed Integer to FAC1";
			a[0xBDC0] = "Print IN Followed by a Line Number";
			a[0xBDCD] = "Output a Number in ASCII Decimal Digits";
			a[0xBDDD] = "Convert Contents of FAC1 to ASCII String";
			a[0xBF11] = "The Constant Value 1/2 in Five-Byte Floating Point Notation";
			a[0xBF1C] = "Powers of Minus Ten Constants Table";
			a[0xBF3A] = "Table of Constants for TI$ Conversion";
			a[0xBF71] = "Perform SQR";
			a[0xBF7B] = "Performs Exponentation (Power Calculation Called for by UPARROW)";
			a[0xBFB4] = "Perform NOT and >";
			a[0xBFBF] = "Table of Constants for EXP and LOG in Five-Byte Floating Point Format";
			a[0xBFED] = "Perform EXP";
			a[0xD000] = "Sprite 0 Horizontal Position";
			a[0xD001] = "Sprite 0 Vertical Position";
			a[0xD002] = "Sprite 1 Horizontal Position";
			a[0xD003] = "Sprite 1 Vertical Position";
			a[0xD004] = "Sprite 2 Horizontal Position";
			a[0xD005] = "Sprite 2 Vertical Position";
			a[0xD006] = "Sprite 3 Horizontal Position";
			a[0xD007] = "Sprite 3 Vertical Position";
			a[0xD008] = "Sprite 4 Horizontal Position";
			a[0xD009] = "Sprite 4 Vertical Position";
			a[0xD00A] = "Sprite 5 Horizontal Position";
			a[0xD00B] = "Sprite 5 Vertical Position";
			a[0xD00C] = "Sprite 6 Horizontal Position";
			a[0xD00D] = "Sprite 6 Vertical Position";
			a[0xD00E] = "Sprite 7 Horizontal Position";
			a[0xD00F] = "Sprite 7 Vertical Position";
			a[0xD010] = "Most Significant Bits of Sprites 0-7 Horizontal Position";
			a[0xD011] = "Vertical Fine Scrolling and Control Register";
			a[0xD012] = "Read Current Raster Scan Line/Write Line to Compare for Raster IRQ";
			a[0xD013] = "Light Pen Horizontal Position";
			a[0xD014] = "Light Pen Vertical Position";
			a[0xD015] = "Sprite Enable Register";
			a[0xD016] = "Horizontal Fine Scrolling and Control Register";
			a[0xD017] = "Sprite Vertical Expansion Register";
			a[0xD018] = "VIC-II Chip Memory Control Register";
			a[0xD019] = "VIC Interrupt Flag Register";
			a[0xD01A] = "IRQ Mask Register";
			a[0xD01B] = "Sprite to Foreground Display Priority Register";
			a[0xD01C] = "Sprite Multicolor Registers";
			a[0xD01D] = "Sprite Horizontal Expansion Register";
			a[0xD01E] = "Sprite to Sprite Collision Register";
			a[0xD01F] = "Sprite to Foreground Collision Register";
			a[0xD020] = "Border Color Register";
			a[0xD021] = "Background Color 0";
			a[0xD022] = "Background Color 1";
			a[0xD023] = "Background Color 2";
			a[0xD025] = "Sprite Multicolor Register 0";
			a[0xD026] = "Sprite Multicolor Register 1";
			a[0xD027] = "Sprite 0 Color Register (the default color value is 1, white)";
			a[0xD028] = "Sprite 1 Color Register (the default color value is 2, red)";
			a[0xD029] = "Sprite 2 Color Register (the default color value is 3, cyan)";
			a[0xD400] = "Voice 1 Frequency Control (low byte)";
			a[0xD401] = "Voice 1 Frequency Control (high byte)";
			a[0xD402] = "Voice 1 Pulse Waveform Width (low byte)";
			a[0xD403] = "Voice 1 Pulse Waveform Width (high nybble)";
			a[0xD404] = "Voice 1 Control Register";
			a[0xD405] = "Voice 1 Attack/Decay Register";
			a[0xD406] = "Voice 1 Sustain/Release Control Register";
			a[0xD407] = "Voice 2 Frequency Control (low byte)";
			a[0xD408] = "Voice 2 Frequency Control (high byte)";
			a[0xD409] = "Voice 2 Pulse Waveform Width (low byte)";
			a[0xD40A] = "Voice 2 Pulse Waveform Width (high nybble)";
			a[0xD40B] = "Voice 2 Control Register";
			a[0xD40C] = "Voice 2 Attack/Decay Register";
			a[0xD40D] = "Voice 2 Sustain/Release Control Register";
			a[0xD40E] = "Voice 3 Frequency Control (low byte)";
			a[0xD40F] = "Voice 3 Frequency Control (high byte)";
			a[0xD410] = "Voice 3 Pulse Waveform Width (low byte)";
			a[0xD411] = "Voice 3 Pulse Waveform Width (high nybble)";
			a[0xD412] = "Voice 3 Control Register";
			a[0xD413] = "Voice 3 Attack/Decay Register";
			a[0xD414] = "Voice 3 Sustain/Release Control Register";
			a[0xD416] = "Filter Cutoff Frequency (high byte)";
			a[0xD417] = "Filter Resonance Control Register";
			a[0xD418] = "Volume and Filter Select Register";
			a[0xD419] = "Read Game Paddle 1 (or 3) Position";
			a[0xD41A] = "Read Game Paddle 2 (or 4) Position";
			a[0xD41B] = "Read Oscillator 3/Random Number Generator";
			a[0xD41C] = "Envelope Generator 3 Output";
			a[0xDC00] = "Data Port Register A";
			a[0xDC01] = "Data Port Register B";
			a[0xDC02] = "Data Direction Register A";
			a[0xDC03] = "Data Direction Register B";
			a[0xDC04] = "Timer A (low byte)";
			a[0xDC05] = "Timer A (high byte)";
			a[0xDC06] = "Timer B (low byte)";
			a[0xDC07] = "Timer B (high byte)";
			a[0xDC08] = "Time of Day Clock Tenths of Seconds";
			a[0xDC09] = "Time of Day Clock Seconds";
			a[0xDC0A] = "Time of Day Clock Minutes";
			a[0xDC0B] = "Time of Day Clock Hours";
			a[0xDC0C] = "Serial Data Port";
			a[0xDC0D] = "Interrupt Control Register";
			a[0xDC0E] = "Control Register A";
			a[0xDC0F] = "Control Register B";
			a[0xDD00] = "Data Port Register A";
			a[0xDD01] = "Data Port B";
			a[0xDD02] = "Data Direction Register A";
			a[0xDD03] = "Data Direction Register B";
			a[0xDD04] = "Timer A (low byte)";
			a[0xDD05] = "Timer A (high byte)";
			a[0xDD06] = "Timer B (low byte)";
			a[0xDD07] = "Timer B (high byte)";
			a[0xDD08] = "Time of Day Clock Tenths of Seconds";
			a[0xDD09] = "Time of Day Clock Seconds";
			a[0xDD0A] = "Time of Day Clock Minutes";
			a[0xDD0B] = "Time of Day Clock Hours";
			a[0xDD0C] = "Serial Data Port";
			a[0xDD0D] = "Interrupt Control Register";
			a[0xDD0E] = "Control Register A";
			a[0xDD0F] = "Control Register B";
			a[0xE043] = "Function Series Evaluation Subroutine 1";
			a[0xE059] = "Function Series Evaluation Subroutine 2";
			a[0xE08D] = "Multiplicative Constant for RND";
			a[0xE092] = "Additive Constant for RND";
			a[0xE097] = "Perform RND";
			a[0xE12A] = "Perform SYS";
			a[0xE156] = "Perform SAVE";
			a[0xE165] = "Perform VERIFY";
			a[0xE168] = "Perform LOAD";
			a[0xE1BE] = "Perform OPEN";
			a[0xE1C7] = "Perform CLOSE";
			a[0xE264] = "Perform COS";
			a[0xE268] = "Perform SIN";
			a[0xE2B4] = "Perform TAN";
			a[0xE2E0] = "The Five-Byte Floating Point Representation of the Constant PI/2";
			a[0xE2E5] = "The Five-Byte Floating Point Representation of the Constant 2*PI";
			a[0xE2EA] = "The Five-Byte Floating Point Representation of the Constant 1/4";
			a[0xE2EF] = "Table of Constants for Evaluation of SIN, COS, and TAN";
			a[0xE30E] = "Perform ATN";
			a[0xE33E] = "Table of Constants for ATN Evaluation";
			a[0xE3A2] = "Text of the CHRGET Routine Which Runs at 115 ($73)";
			a[0xE3BF] = "Initialize BASIC";
			a[0xE460] = "Power-Up Messages";
			a[0xE500] = "Store Base Address of Memory-Mapped I/O Devices in .X and .Y Registers";
			a[0xE505] = "Store Number of Screen Rows and Columns in .Y and .X";
			a[0xE50A] = "Read/Set Location of the Cursor";
			a[0xE5B4] = "Get a Character from the Keyboard Buffer";
			a[0xEA87] = "Read the Keyboard";
			a[0xED09] = "Send TALK to a Device on the Serial Bus";
			a[0xEDB9] = "Send a Secondary Address to a Device on the Serial Bus after LISTEN";
			a[0xEDC7] = "Send a Secondary Address to a Device on the Serial Bus after TALK";
			a[0xEDDD] = "Send a Byte to an I/O Device over the Serial Bus";
			a[0xEDEF] = "Send UNTALK to a Device on the Serial Bus";
			a[0xEDFE] = "Send UNLISTED to a Device on the Serial Bus";
			a[0xEE13] = "Receive a Byte of Data from a Device on the Serial Bus";
			a[0xF13E] = "Get One Byte from the Input Device";
			a[0xF157] = "Input a Character from the Current Device";
			a[0xF1CA] = "Output a Byte";
			a[0xF20E] = "Designate a Logical File As the Current Input Channel";
			a[0xF250] = "Designate a Logical File As the Current Output Channel";
			a[0xF291] = "Close a Logical I/O File";
			a[0xF32F] = "Close All Logical I/O Files";
			a[0xF333] = "Restore Current Input and Output Devices to the Default Devices";
			a[0xF34A] = "Open a Logical I/O File";
			a[0xF49E] = "Load RAM from a Device";
			a[0xF5DD] = "Save RAM to a Device";
			a[0xF69B] = "Update the Software Clock and Check for the STOP Key";
			a[0xF6DD] = "Read the Time From the Software Clock into the .A, .X, and .Y";
			a[0xF6E4] = "Set the Software Clock from the .A, .X, and .Y Registers";
			a[0xF6ED] = "Test STOP Key";
			a[0xFD15] = "Restore RAM Vectors for Default I/O Routines";
			a[0xFD1A] = "Set the RAM Vector Table from the Table Pointed to by .X and .Y";
			a[0xFD50] = "Perform RAM Test and Set Pointers to the Top and Bottom of RAM";
			a[0xFDA3] = "Initialize CIA I/O Devices";
			a[0xFDF9] = "Set Filename Parameters";
			a[0xFE00] = "Set Logical File Number, Device Number, and Secondary Address";
			a[0xFE07] = "Read the I/O Status Word";
			a[0xFE18] = "Set the Message Control Flag";
			a[0xFE25] = "Read/Set Top of RAM Pointer";
			a[0xFE34] = "Read/Set Bottom of RAM Pointer";
			a[0xFF5B] = "Initialize Screen Editor and VIC-II Chip";
			return a;
		}

		private static function getAddress():Dictionary {
			var a:Dictionary = new Dictionary();
			a["D6510"] = 0x0; // 6510 On-Chip I/O DATA Direction Register
			a["R6510"] = 0x1; // 
			a["CHARAC"] = 0x7; // Search Character for Scanning BASIC Text Input
			a["ENDCHR"] = 0x8; // Search Character for Statement Termination or Quote
			a["TRMPOS"] = 0x9; // Column position of the Cursor before the Last TAB or SPC
			a["VERCK"] = 0xA; // Flag: LOAD or VERIFY
			a["COUNT"] = 0xB; // Index into the Text Input Buffer/Number of Array Subscripts
			a["DIMFLG"] = 0xC; // Flags for the Routines That Locate or Build an Array
			a["VALTYP"] = 0xD; // Flag: Type of Data (String or Numeric)
			a["INTFLG"] = 0xE; // Flat: Type of Numeric Data (Integer or Floating Point)
			a["GARBFL"] = 0xF; // Flag for LIST, Garbage Collection, and Program Tokenization
			a["SUBFLG"] = 0x10; // Flag: Subscript Reference to an Array or User-Defined Function Call (FN)
			a["INPFLG"] = 0x11; // Flag: Is Data Input to GET, READ or INPUT?
			a["TANSGN"] = 0x12; // Flag: Sign of the Result of the TAN or SIN Function
			a["CHANNL"] = 0x13; // Current I/O Channel (CMD Logical File) Number
			a["TEMPPT"] = 0x16; // Pointer to the Next Available Space in the Temporary String Stack
			a["OPMASK"] = 0x4D; // Mask for Comparison Operation
			a["FOUR6"] = 0x53; // Constant for Garbage Collection
			a["FACEXP"] = 0x61; // Floating Point Accumulator #1: Exponent
			a["FACSGN"] = 0x66; // Floating Point Accumulator #1: Sign
			a["SGNFLG"] = 0x67; // Number of Terms in a Series Evaluation
			a["BITS"] = 0x68; // Floating Point Accumulator #1: Overflow Digit
			a["ARGEXP"] = 0x69; // Floating Point Accumulator #2: Exponent
			a["ARGSGN"] = 0x6E; // Floating Point Accumulator #2: Sign
			a["ARISGN"] = 0x6F; // Result of a Signed Comparison of Accumulator #1 to Accumulator #2
			a["FACOV"] = 0x70; // Low Order Mantissa Byte of Floating Point Accumulator #1 (For
			a["STATUS"] = 0x90; // Kernal I/O Status Word (ST)
			a["STKEY"] = 0x91; // Flag: Was STOP Key Pressed?
			a["SVXT"] = 0x92; // Timing Constant for Tape Reads
			a["VERCK"] = 0x93; // Flag for Load Routine: 0=LOAD, 1=VERIFY
			a["C3PO"] = 0x94; // Flag: Serial Bus--Output Character Was Buffered
			a["BSOUR"] = 0x95; // Buffered Character for Serial Bus
			a["SYNO"] = 0x96; // Cassette Block Synchronization Number
			a["XSAV"] = 0x97; // Temporary .X Register Save Area
			a["LDTND"] = 0x98; // Number of Open I/O Files/Index to the End of File Tables
			a["DFLTN"] = 0x99; // Default Input Device (Set to 0 for Keyboard)
			a["DFLTO"] = 0x9A; // Default Output (CMD) Device (Set to 3 for the Screen)
			a["PRTY"] = 0x9B; // Tape Character Parity
			a["DPSW"] = 0x9C; // Flag: Tape Byte Received
			a["MSGFLG"] = 0x9D; // Flag: Kernal Message Control
			a["PTR1"] = 0x9E; // Tape Pass 1 Error Log Index
			a["PTR2"] = 0x9F; // Tape Pass 2 Error Log Correction Index
			a["CNTDN"] = 0xA5; // Cassette Synchronization Character Countdown
			a["BUFPNT"] = 0xA6; // Count of Characters in Tape I/O Buffer
			a["INBIT"] = 0xA7; // RS-232 Input Bits/Cassette Temporary Storage Area
			a["BITCI"] = 0xA8; // RS-232 Input Bit Count/Cassete Temporary Storage
			a["RINONE"] = 0xA9; // RS-232 Flag: Check for Start Bit
			a["RIDATA"] = 0xAA; // RS-232 Input Byte Buffer/Cassette Temporary Storage
			a["RIPRTY"] = 0xAB; // RS-232 Input Parity/Cassete Leader Counter
			a["BITTS"] = 0xB4; // RS-232 Output Bit Count/Cassette Temporary Storage
			a["NXTBIT"] = 0xB5; // RS-232 Next Bit to Send/Tape EOT Flag
			a["RODATA"] = 0xB6; // RS-232 Output Byte Buffer
			a["FNLEN"] = 0xB7; // Length of Current Filename
			a["LA"] = 0xB8; // Current Logical File Number
			a["SA"] = 0xB9; // Current Secondary Address
			a["FA"] = 0xBA; // Current Device Number
			a["ROPRTY"] = 0xBD; // RS-232 Output Parity/Cassette Temporary Storage
			a["FSBLK"] = 0xBE; // Cassette Read/Write Block Count
			a["MYCH"] = 0xBF; // Tape Input Byte Buffer
			a["CAS1"] = 0xC0; // Tape Motor Interlock
			a["LSTX"] = 0xC5; // Matrix Coordinate of Last Key Pressed, 64=None Pressed
			a["NDX"] = 0xC6; // Number of Characters in Keyboard Buffer (Queue)
			a["RVS"] = 0xC7; // Flag: Print Reverse Characters? 0=No
			a["INDX"] = 0xC8; // Pointer: End of Logical Line for Input
			a["SFDX"] = 0xCB; // Matrix Coordinate of Current Key Pressed
			a["BLNSW"] = 0xCC; // Cursor Blink Enable: 0=Flash Cursor
			a["BLNCT"] = 0xCD; // Timer: Countdown to Blink Cursor
			a["GDBLN"] = 0xCE; // Character Under Cursor
			a["BLNON"] = 0xCF; // Flag: Was Last Curson Blink on or off?
			a["CRSW"] = 0xD0; // Flag: Input from Keyboard or Screen
			a["PNTR"] = 0xD3; // Cursor Column on Current Line
			a["QTSW"] = 0xD4; // Flag: Editor in Quote Mode? 0=No
			a["LNMX"] = 0xD5; // Maximum Length of Physical Screen Line
			a["TBLX"] = 0xD6; // Current Cursor Physical Line Number
			a["INSRT"] = 0xD8; // Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)
			a["BASZPT"] = 0xFF; // BASIC Temporary Data for Floating Point to ASCII Conversion
			a["TIMOUT"] = 0x285; // Flag: Kernal Variable for IEEE Time-Out
			a["COLOR"] = 0x286; // Current Foreground Color for Text
			a["GDCOL"] = 0x287; // Color of Character under Cursor
			a["HIBASE"] = 0x288; // Top Page of Screen Memory
			a["XMAX"] = 0x289; // Maximum Keyboard Buffer Size
			a["RPTFLAG"] = 0x28A; // Flag: Which Keys Will Repeat?
			a["KOUNT"] = 0x28B; // Counter for Timing the Delay Between Key Repeats
			a["DELAY"] = 0x28C; // Counter for Timing the Delay Until the First Key Repeat Begins
			a["SHFLAG"] = 0x28D; // Flag: SHIFT/CTRL/Logo Keypress
			a["LSTSHF"] = 0x28E; // Last Pattern of SHIFT/CTRL/Logo Keypress
			a["MODE"] = 0x291; // Flag: Enable or Disable Changing Character Sets with SHIFT/Logo
			a["AUTODN"] = 0x292; // Flag: Screen Scrolling Enabled
			a["M51CTR"] = 0x293; // RS-232: Mock 6551 Control Register
			a["M51CDR"] = 0x294; // RS-232: Mock 6551 Command Register
			a["BITNUM"] = 0x298; // RS-232: Number of Bits Left to be Sent/Received
			a["RIDBE"] = 0x29B; // RS-232: Index to End of Receive Buffer
			a["RIDBS"] = 0x29C; // RS-232: Index to Start of Receive Buffer
			a["RODBS"] = 0x29D; // RS-232: Index to Start of Transmit Buffer
			a["RODBE"] = 0x29E; // RS-232: Index to End of Transmit Buffer
			a["ENABL"] = 0x2A1; // RS-232 Interrupts Enabled
			a["SAREG"] = 0x30C; // Storage Area for .A Register (Accumulator)
			a["SXREG"] = 0x30D; // Storage Area for .X Index Register
			a["SYREG"] = 0x30E; // Storage Area for .Y Index Register
			a["SPREG"] = 0x30F; // Storage Area for .P (Status) Register
			a["USRPOK"] = 0x310; // Jump Instruction for User Function ($4C)
			a["BLTU"] = 0xA3B8; // Open a Space in Memory for a New Program Line or Variable
			a["MAIN1"] = 0xA49C; // Add or Replace a Line of Program Text
			a["LINKPRG"] = 0xA533; // Relink Lines of Tokenized Program Text
			a["INLIN"] = 0xA560; // Input a Line to Buffer from Keyboard
			a["CRUNCH"] = 0xA579; // Tokenize Line in Input Buffer
			a["FINDLN"] = 0xA613; // Search for Line Number
			a["SCRTCH"] = 0xA642; // Perform NEW
			a["CLEAR"] = 0xA65E; // Perform CLR
			a["RUNC"] = 0xA68E; // Reset Pointer to Current Text Character to the Beginning of Program
			a["QPLOP"] = 0xA717; // Print BASIC Tokens as ASCII Characters
			a["FOR"] = 0xA742; // Perform FOR
			a["NEWSTT"] = 0xA7AE; // Set Up Next Statement for Execution
			a["GONE"] = 0xA7E4; // Read and Execute the Next Statement
			a["RESTOR"] = 0xA81D; // Perform RESTORE
			a["CONT"] = 0xA857; // Perform CONT
			a["RUN"] = 0xA871; // Perform RUN
			a["GOSUB"] = 0xA883; // Perform GOSUB
			a["GOTO"] = 0xA8A0; // Perform GOTO
			a["RETURN"] = 0xA8D2; // Perform RETURN
			a["DATA"] = 0xA8F8; // Perform DATA
			a["DATAN"] = 0xA906; // Search Program Text for the End of the Current BASIC Statement
			a["IF"] = 0xA928; // Perform IF
			a["REM"] = 0xA93B; // Perform REM
			a["ONGOTO"] = 0xA94B; // Perform ON GOTO or ON GOSUB
			a["LINGET"] = 0xA96B; // Convert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber
			a["LET"] = 0xA9A5; // Perform LET
			a["PRINTN"] = 0xAA80; // Perform PRINT#
			a["CMD"] = 0xAA86; // Perform CMD
			a["PRINT"] = 0xAAA0; // Perform PRINT
			a["STROUT"] = 0xAB1E; // Print Message from a String Whose Address Is in the .Y and .A
			a["DOAGIN"] = 0xAB4D; // Error Message Formatting Routines for GET, INPUT, and READ
			a["GET"] = 0xAB7B; // Perform GET and GET#
			a["INPUTN"] = 0xABA5; // Perform INPUT#
			a["INPUT"] = 0xABBF; // Perform INPUT
			a["READ"] = 0xAC06; // Perform READ
			a["EXIGNT"] = 0xACFC; // ASCII Text for Input Error Messages
			a["NEXT"] = 0xAD1E; // Perform NEXT
			a["FRMNUM"] = 0xAD8A; // Evaluate a Numeric Expression and/or Check for Data Type Mismatch
			a["FRMEVAL"] = 0xAD9E; // Evaluate Expression
			a["EVAL"] = 0xAE83; // Convert a Single Numeric Term from ASCII Text to a Floating Point
			a["PIVAL"] = 0xAEA8; // PI Expressed as a Five-Byte Floating Point Number
			a["PARCHK"] = 0xAEF1; // Evaluate Expression Within Parentheses
			a["CHKCLS"] = 0xAEF7; // Check for and Skip Closing Parentheses
			a["CHKOPN"] = 0xAEFA; // Check for and Skip Opening Parentheses
			a["CHKCOM"] = 0xAEFF; // Check for and Skip Comma
			a["SNERR"] = 0xAF08; // Print Syntax Error Message
			a["ISVAR"] = 0xAF2B; // Get the Value of a Variable
			a["ISFUN"] = 0xAFA7; // Dispatch and Evaluate a Function
			a["OROP"] = 0xAFE6; // Perform OR
			a["ANDOP"] = 0xAFE9; // Perform AND
			a["DORE1"] = 0xB016; // Perform Comparisons
			a["PTRGET"] = 0xB08B; // Search for a Variable and Set It Up If It Is Not Found
			a["NOTFNS"] = 0xB11D; // Create a New BASIC Variable
			a["FINPTR"] = 0xB185; // Return the Address of the Variable That Was Found or Created
			a["ARYGET"] = 0xB194; // Allocate Space for Array Descriptors
			a["N32768"] = 0xB1A5; // The Constant -32768 in Five-Byte Floating Point Format
			a["INTIDX"] = 0xB1B2; // Input and Convert a Floating Point Subscript to a Positive Integer
			a["AYINT"] = 0xB1BF; // Convert a Floating Point Number to a Signed Integer
			a["ISARY"] = 0xB1D1; // Find Array Element or Create New Array in RAM
			a["BSERR"] = 0xB245; // Print BAD SUBSCRIPT Error Message
			a["FCERR"] = 0xB248; // Print ILLEGAL QUANTITY Error Message
			a["UMULT"] = 0xB34C; // Compute the Size of a Multidimensional Array
			a["FRE"] = 0xB37D; // Perform FRE
			a["GIVAYF"] = 0xB391; // Convert 16-Bit Signed Integer to Floating Point
			a["POS"] = 0xB39E; // Perform POS
			a["ERRDIR"] = 0xB3A6; // Check If the Program is Running in Direct Mode, and If So Issue an Error
			a["DEF"] = 0xB3B3; // Perform DEF
			a["GETFNM"] = 0xB3E1; // Check DEF and FN Syntax
			a["FNDOER"] = 0xB3F4; // Perform FN
			a["STRD"] = 0xB465; // Perform STR$
			a["STRLIT"] = 0xB487; // Scan and Set Up Pointers to a String in Memory
			a["GETSPA"] = 0xB4F4; // Allocate Space in Memory for String
			a["GARBAG"] = 0xB526; // String Garbage Collection
			a["CAT"] = 0xB63D; // Concatenate Two Strings
			a["MOVINS"] = 0xB67A; // Move a String in Memory
			a["FRESTR"] = 0xB6A3; // Discard a Temporary String
			a["FRETMS"] = 0xB6DB; // Remove an Entry from the String Descriptor Stack
			a["CHRD"] = 0xB6EC; // Perform CHR$
			a["LEFTD"] = 0xB700; // Perform LEFT$
			a["RIGHTD"] = 0xB72C; // Perform RIGHT$
			a["MIDD"] = 0xB737; // Perform MID$
			a["PREAM"] = 0xB761; // Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$
			a["LEN"] = 0xB77C; // Perform LEN
			a["ASC"] = 0xB78B; // Perform ASC
			a["GETBYTC"] = 0xB79B; // Input a Parameter Whose Value Is Between 0 and 255
			a["VAL"] = 0xB7AD; // Perform VAL
			a["GETNUM"] = 0xB7EB; // Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)
			a["GETADR"] = 0xB7F7; // Convert a Floating Point Number to an Unsigned Two-Byte Integer
			a["PEEK"] = 0xB80D; // Perform PEEK
			a["POKE"] = 0xB824; // Perform POKE
			a["FUWAIT"] = 0xB82D; // Perform WAIT
			a["FADDH"] = 0xB849; // Add .5 to Contents of Floating Point Accumulator #1
			a["FSUB"] = 0xB850; // Subtract FAC1 from a Number in Memory
			a["FSUBT"] = 0xB853; // BASIC's Subtraction Operation
			a["FADD"] = 0xB867; // Add FAC1 to a Number in Memory
			a["FADDT"] = 0xB86A; // Perform BASIC's Addition Operation
			a["FADD4"] = 0xB8A7; // Make the Result Negative If a Borrow Was Done
			a["NORMAL"] = 0xB8FE; // Normalize Floating Point Accumulator #1
			a["NEGFAC"] = 0xB947; // Replace FAC1 with Its 2's Complement
			a["OVERR"] = 0xB97E; // Print Overflow Error Message
			a["MULSHF"] = 0xB983; // SHIFT Routine
			a["FONE"] = 0xB9BC; // Floating Point Constant with a Value of 1
			a["LOGCN2"] = 0xB9C1; // Table of Floating Point Constants for the LOG Function
			a["LOG"] = 0xB9EA; // Perform LOG to Base E
			a["FMULT"] = 0xBA28; // Multiply FAC1 with FAC2
			a["MLTPLY"] = 0xBA59; // Multiply a Byte Subroutine
			a["CONUPK"] = 0xBA8C; // Move a Floating Point Number from Memory into FAC2
			a["MULDIV"] = 0xBAB7; // Add Exponent of FAC1 to Exponent of FAC2
			a["MLDVEX"] = 0xBAD4; // Handle Underflow or Overflow
			a["MUL10"] = 0xBAE2; // Multiply FAC1 by 10
			a["TENC"] = 0xBAF9; // The Constant 10 in Five-Byte Floating Format
			a["DIV10"] = 0xBAFE; // Divide FAC1 by 10
			a["FDIV"] = 0xBB0F; // Divide a Number in Memory by FAC1
			a["FDIVT"] = 0xBB12; // Divide FAC2 by FAC1
			a["MOVFM"] = 0xBBA2; // Move a Floating Point Number from Memory to FAC1
			a["MOV2F"] = 0xBBC7; // Move a Floating Point Number from FAC1 to Memory
			a["MOVFA"] = 0xBBFC; // Move a Floating Point Number from FAC2 to FAC1
			a["MOVAF"] = 0xBC0C; // Round and Move a Floating Point Number from FAC1 to FAC2
			a["MOVEF"] = 0xBC0F; // Copy FAC1 to FAC2 Without Rounding
			a["ROUND"] = 0xBC1B; // Round Accumulator #1 by Adjusting the Rounding Byte
			a["SIGN"] = 0xBC2B; // Put the Sign of Accumulator #1 into .A Register
			a["SGN"] = 0xBC39; // Perform SGN
			a["ABS"] = 0xBC58; // Perform ABS
			a["FCOMP"] = 0xBC5B; // Compare FAC1 to Memory
			a["QINT"] = 0xBC9B; // Convert FAC1 into Integer Within FAC1
			a["INT"] = 0xBCCC; // Perform INT
			a["FIN"] = 0xBCF3; // Convert an ASCII String to a Floating Point Number FAC1
			a["FINLOG"] = 0xBD7E; // Add Signed Integer to FAC1
			a["NO999"] = 0xBDB3; // 
			a["INPRT"] = 0xBDC0; // Print IN Followed by a Line Number
			a["LINPRT"] = 0xBDCD; // Output a Number in ASCII Decimal Digits
			a["FOUT"] = 0xBDDD; // Convert Contents of FAC1 to ASCII String
			a["FHALF"] = 0xBF11; // The Constant Value 1/2 in Five-Byte Floating Point Notation
			a["FOUTBL"] = 0xBF1C; // Powers of Minus Ten Constants Table
			a["FDCEND"] = 0xBF3A; // Table of Constants for TI$ Conversion
			a["SQR"] = 0xBF71; // Perform SQR
			a["FPWRT"] = 0xBF7B; // Performs Exponentation (Power Calculation Called for by UPARROW)
			a["NEGOP"] = 0xBFB4; // Perform NOT and >
			a["EXPCON"] = 0xBFBF; // Table of Constants for EXP and LOG in Five-Byte Floating Point Format
			a["EXP"] = 0xBFED; // Perform EXP
			a["SP0X"] = 0xD000; // Sprite 0 Horizontal Position
			a["SP0Y"] = 0xD001; // Sprite 0 Vertical Position
			a["SP1X"] = 0xD002; // Sprite 1 Horizontal Position
			a["SP1Y"] = 0xD003; // Sprite 1 Vertical Position
			a["SP2X"] = 0xD004; // Sprite 2 Horizontal Position
			a["SP2Y"] = 0xD005; // Sprite 2 Vertical Position
			a["SP3X"] = 0xD006; // Sprite 3 Horizontal Position
			a["SP3Y"] = 0xD007; // Sprite 3 Vertical Position
			a["SP4X"] = 0xD008; // Sprite 4 Horizontal Position
			a["SP4Y"] = 0xD009; // Sprite 4 Vertical Position
			a["SP5X"] = 0xD00A; // Sprite 5 Horizontal Position
			a["SP5Y"] = 0xD00B; // Sprite 5 Vertical Position
			a["SP6X"] = 0xD00C; // Sprite 6 Horizontal Position
			a["SP6Y"] = 0xD00D; // Sprite 6 Vertical Position
			a["SP7X"] = 0xD00E; // Sprite 7 Horizontal Position
			a["SP7Y"] = 0xD00F; // Sprite 7 Vertical Position
			a["MSIGX"] = 0xD010; // Most Significant Bits of Sprites 0-7 Horizontal Position
			a["SCROLY"] = 0xD011; // Vertical Fine Scrolling and Control Register
			a["RASTER"] = 0xD012; // Read Current Raster Scan Line/Write Line to Compare for Raster IRQ
			a["LPENX"] = 0xD013; // Light Pen Horizontal Position
			a["LPENY"] = 0xD014; // Light Pen Vertical Position
			a["SPENA"] = 0xD015; // Sprite Enable Register
			a["SCROLX"] = 0xD016; // Horizontal Fine Scrolling and Control Register
			a["YXPAND"] = 0xD017; // Sprite Vertical Expansion Register
			a["VMCSB"] = 0xD018; // VIC-II Chip Memory Control Register
			a["VICIRQ"] = 0xD019; // VIC Interrupt Flag Register
			a["IRQMASK"] = 0xD01A; // IRQ Mask Register
			a["SPBGPR"] = 0xD01B; // Sprite to Foreground Display Priority Register
			a["SPMC"] = 0xD01C; // Sprite Multicolor Registers
			a["XXPAND"] = 0xD01D; // Sprite Horizontal Expansion Register
			a["SPSPCL"] = 0xD01E; // Sprite to Sprite Collision Register
			a["SPBGCL"] = 0xD01F; // Sprite to Foreground Collision Register
			a["EXTCOL"] = 0xD020; // Border Color Register
			a["BGCOL0"] = 0xD021; // Background Color 0
			a["BGCOL1"] = 0xD022; // Background Color 1
			a["BGCOL2"] = 0xD023; // Background Color 2
			a["SPMC0"] = 0xD025; // Sprite Multicolor Register 0
			a["SPMC1"] = 0xD026; // Sprite Multicolor Register 1
			a["SP0COL"] = 0xD027; // Sprite 0 Color Register (the default color value is 1, white)
			a["SP1COL"] = 0xD028; // Sprite 1 Color Register (the default color value is 2, red)
			a["SP2COL"] = 0xD029; // Sprite 2 Color Register (the default color value is 3, cyan)
			a["FRELO1"] = 0xD400; // Voice 1 Frequency Control (low byte)
			a["FREHI1"] = 0xD401; // Voice 1 Frequency Control (high byte)
			a["PWLO1"] = 0xD402; // Voice 1 Pulse Waveform Width (low byte)
			a["PWHI1"] = 0xD403; // Voice 1 Pulse Waveform Width (high nybble)
			a["VCREG1"] = 0xD404; // Voice 1 Control Register
			a["ATDCY1"] = 0xD405; // Voice 1 Attack/Decay Register
			a["SUREL1"] = 0xD406; // Voice 1 Sustain/Release Control Register
			a["FRELO2"] = 0xD407; // Voice 2 Frequency Control (low byte)
			a["FREHI2"] = 0xD408; // Voice 2 Frequency Control (high byte)
			a["PWLO2"] = 0xD409; // Voice 2 Pulse Waveform Width (low byte)
			a["PWHI2"] = 0xD40A; // Voice 2 Pulse Waveform Width (high nybble)
			a["VCREG2"] = 0xD40B; // Voice 2 Control Register
			a["ATDCY2"] = 0xD40C; // Voice 2 Attack/Decay Register
			a["SUREL2"] = 0xD40D; // Voice 2 Sustain/Release Control Register
			a["FRELO3"] = 0xD40E; // Voice 3 Frequency Control (low byte)
			a["FREHI3"] = 0xD40F; // Voice 3 Frequency Control (high byte)
			a["PWLO3"] = 0xD410; // Voice 3 Pulse Waveform Width (low byte)
			a["PWHI3"] = 0xD411; // Voice 3 Pulse Waveform Width (high nybble)
			a["VCREG3"] = 0xD412; // Voice 3 Control Register
			a["ATDCY3"] = 0xD413; // Voice 3 Attack/Decay Register
			a["SUREL3"] = 0xD414; // Voice 3 Sustain/Release Control Register
			a["CUTLO"] = 0xD415; // 
			a["CUTHI"] = 0xD416; // Filter Cutoff Frequency (high byte)
			a["RESON"] = 0xD417; // Filter Resonance Control Register
			a["SIGVOL"] = 0xD418; // Volume and Filter Select Register
			a["POTX"] = 0xD419; // Read Game Paddle 1 (or 3) Position
			a["POTY"] = 0xD41A; // Read Game Paddle 2 (or 4) Position
			a["RANDOM"] = 0xD41B; // Read Oscillator 3/Random Number Generator
			a["ENV3"] = 0xD41C; // Envelope Generator 3 Output
			a["CIAPRA"] = 0xDC00; // Data Port Register A
			a["CIAPRB"] = 0xDC01; // Data Port Register B
			a["CIDDRA"] = 0xDC02; // Data Direction Register A
			a["CIDDRB"] = 0xDC03; // Data Direction Register B
			a["TIMALO"] = 0xDC04; // Timer A (low byte)
			a["TIMAHI"] = 0xDC05; // Timer A (high byte)
			a["TIMBLO"] = 0xDC06; // Timer B (low byte)
			a["TIMBHI"] = 0xDC07; // Timer B (high byte)
			a["TODTEN"] = 0xDC08; // Time of Day Clock Tenths of Seconds
			a["TODSEC"] = 0xDC09; // Time of Day Clock Seconds
			a["TODMIN"] = 0xDC0A; // Time of Day Clock Minutes
			a["TODHRS"] = 0xDC0B; // Time of Day Clock Hours
			a["CIASDR"] = 0xDC0C; // Serial Data Port
			a["CIAICR"] = 0xDC0D; // Interrupt Control Register
			a["CIACRA"] = 0xDC0E; // Control Register A
			a["CIACRB"] = 0xDC0F; // Control Register B
			a["CI2PRA"] = 0xDD00; // Data Port Register A
			a["CI2PRB"] = 0xDD01; // Data Port B
			a["C2DDRA"] = 0xDD02; // Data Direction Register A
			a["C2DDRB"] = 0xDD03; // Data Direction Register B
			a["TI2ALO"] = 0xDD04; // Timer A (low byte)
			a["TI2AHI"] = 0xDD05; // Timer A (high byte)
			a["TI2BLO"] = 0xDD06; // Timer B (low byte)
			a["TI2BHI"] = 0xDD07; // Timer B (high byte)
			a["TO2TEN"] = 0xDD08; // Time of Day Clock Tenths of Seconds
			a["TO2SEC"] = 0xDD09; // Time of Day Clock Seconds
			a["TO2MIN"] = 0xDD0A; // Time of Day Clock Minutes
			a["TO2HRS"] = 0xDD0B; // Time of Day Clock Hours
			a["CI2SDR"] = 0xDD0C; // Serial Data Port
			a["CI2ICR"] = 0xDD0D; // Interrupt Control Register
			a["CI2CRA"] = 0xDD0E; // Control Register A
			a["CI2CRB"] = 0xDD0F; // Control Register B
			a["POLY1"] = 0xE043; // Function Series Evaluation Subroutine 1
			a["POLY2"] = 0xE059; // Function Series Evaluation Subroutine 2
			a["RMULC"] = 0xE08D; // Multiplicative Constant for RND
			a["RADDC"] = 0xE092; // Additive Constant for RND
			a["RND"] = 0xE097; // Perform RND
			a["SYS"] = 0xE12A; // Perform SYS
			a["SAVE"] = 0xE156; // Perform SAVE
			a["VERIFY"] = 0xE165; // Perform VERIFY
			a["LOAD"] = 0xE168; // Perform LOAD
			a["OPEN"] = 0xE1BE; // Perform OPEN
			a["CLOSE"] = 0xE1C7; // Perform CLOSE
			a["COS"] = 0xE264; // Perform COS
			a["SIN"] = 0xE268; // Perform SIN
			a["TAN"] = 0xE2B4; // Perform TAN
			a["PI2"] = 0xE2E0; // The Five-Byte Floating Point Representation of the Constant PI/2
			a["TWOPI"] = 0xE2E5; // The Five-Byte Floating Point Representation of the Constant 2*PI
			a["FR4"] = 0xE2EA; // The Five-Byte Floating Point Representation of the Constant 1/4
			a["SINCON"] = 0xE2EF; // Table of Constants for Evaluation of SIN, COS, and TAN
			a["ATN"] = 0xE30E; // Perform ATN
			a["ATNCON"] = 0xE33E; // Table of Constants for ATN Evaluation
			a["INITAT"] = 0xE3A2; // Text of the CHRGET Routine Which Runs at 115 ($73)
			a["INIT"] = 0xE3BF; // Initialize BASIC
			a["WORDS"] = 0xE460; // Power-Up Messages
			a["IOBASE"] = 0xE500; // Store Base Address of Memory-Mapped I/O Devices in .X and .Y Registers
			a["SCREEN"] = 0xE505; // Store Number of Screen Rows and Columns in .Y and .X
			a["PLOT"] = 0xE50A; // Read/Set Location of the Cursor
			a["LP2"] = 0xE5B4; // Get a Character from the Keyboard Buffer
			a["SCNKEY"] = 0xEA87; // Read the Keyboard
			a["TALK"] = 0xED09; // Send TALK to a Device on the Serial Bus
			a["LISTEN"] = 0xED0C; // 
			a["SECOND"] = 0xEDB9; // Send a Secondary Address to a Device on the Serial Bus after LISTEN
			a["TKSA"] = 0xEDC7; // Send a Secondary Address to a Device on the Serial Bus after TALK
			a["CIOUT"] = 0xEDDD; // Send a Byte to an I/O Device over the Serial Bus
			a["UNTLK"] = 0xEDEF; // Send UNTALK to a Device on the Serial Bus
			a["UNLSN"] = 0xEDFE; // Send UNLISTED to a Device on the Serial Bus
			a["ACPTR"] = 0xEE13; // Receive a Byte of Data from a Device on the Serial Bus
			a["GETIN"] = 0xF13E; // Get One Byte from the Input Device
			a["CHRIN"] = 0xF157; // Input a Character from the Current Device
			a["CHROUT"] = 0xF1CA; // Output a Byte
			a["CHKIN"] = 0xF20E; // Designate a Logical File As the Current Input Channel
			a["CHKOUT"] = 0xF250; // Designate a Logical File As the Current Output Channel
			a["CLOSE"] = 0xF291; // Close a Logical I/O File
			a["CLALL"] = 0xF32F; // Close All Logical I/O Files
			a["CLRCHN"] = 0xF333; // Restore Current Input and Output Devices to the Default Devices
			a["OPEN"] = 0xF34A; // Open a Logical I/O File
			a["LOAD"] = 0xF49E; // Load RAM from a Device
			a["SAVE"] = 0xF5DD; // Save RAM to a Device
			a["UDTIM"] = 0xF69B; // Update the Software Clock and Check for the STOP Key
			a["RDTIM"] = 0xF6DD; // Read the Time From the Software Clock into the .A, .X, and .Y
			a["SETTIM"] = 0xF6E4; // Set the Software Clock from the .A, .X, and .Y Registers
			a["STOP"] = 0xF6ED; // Test STOP Key
			a["RESTOR"] = 0xFD15; // Restore RAM Vectors for Default I/O Routines
			a["VECTOR"] = 0xFD1A; // Set the RAM Vector Table from the Table Pointed to by .X and .Y
			a["RAMTAS"] = 0xFD50; // Perform RAM Test and Set Pointers to the Top and Bottom of RAM
			a["IOINIT"] = 0xFDA3; // Initialize CIA I/O Devices
			a["SETNAM"] = 0xFDF9; // Set Filename Parameters
			a["SETLFS"] = 0xFE00; // Set Logical File Number, Device Number, and Secondary Address
			a["READST"] = 0xFE07; // Read the I/O Status Word
			a["SETMSG"] = 0xFE18; // Set the Message Control Flag
			a["MEMTOP"] = 0xFE25; // Read/Set Top of RAM Pointer
			a["MEMBOT"] = 0xFE34; // Read/Set Bottom of RAM Pointer
			a["CINT"] = 0xFF5B; // Initialize Screen Editor and VIC-II Chip
			return a;
		}
	}
}