///
/// generated by templates.py -- do not edit
///

/// return input type signature for given instruction
///
const Type** InstrFactory::buildInputSignature(InstrKind kind) {
  switch (kind) {
  case HR_start: {
    /* start: () -> (Effect, Top) */
    return NULL;
  }
  case HR_template: {
    /* template: () -> (Effect, Top) */
    return NULL;
  }
  case HR_catchblock: {
    /* catchblock: () -> Top */
    return NULL;
  }
  case HR_return: {
    /* return: (Effect, Top) -> () */
    const Type* input_sig[] = { EFFECT, TOP };
    return copySig(2, input_sig);
  }
  case HR_throw: {
    /* throw: (Effect, Atom) -> () */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_goto: {
    /* goto: Top -> () */
    return copySig(TOP);
  }
  case HR_label: {
    /* label: () -> Top */
    return NULL;
  }
  case HR_if: {
    /* if: (Boolean, Top) -> () */
    const Type* input_sig[] = { lattice_.boolean_type, TOP };
    return copySig(2, input_sig);
  }
  case HR_switch: {
    /* switch: (Int, Top) -> () */
    const Type* input_sig[] = { lattice_.int_type, TOP };
    return copySig(2, input_sig);
  }
  case HR_arm: {
    /* arm: () -> Top */
    return NULL;
  }
  case HR_const: {
    /* const: () -> Top */
    return NULL;
  }
  case HR_coerce: {
    /* coerce: (Effect, Traits, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TRAITS, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_cast: {
    /* cast: (Effect, Traits, Atom) -> (Effect, ScriptObject) */
    const Type* input_sig[] = { EFFECT, TRAITS, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_castobject: {
    /* castobject: Atom -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_tonumber: {
    /* tonumber: (Effect, Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_toint: {
    /* toint: (Effect, Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_touint: {
    /* touint: (Effect, Atom) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_toboolean: {
    /* toboolean: Atom -> Boolean */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_d2b: {
    /* d2b: Number -> Boolean */
    return copySig(lattice_.double_type);
  }
  case HR_caststring: {
    /* caststring: (Effect, Atom) -> (Effect, String) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_castns: {
    /* castns: (Effect, Atom) -> (Effect, Namespace) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_cknull: {
    /* cknull: (Effect, Atom) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_cknullobject: {
    /* cknullobject: (Effect, ScriptObject) -> (Effect, ScriptObject~) */
    const Type* input_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_cktimeout: {
    /* cktimeout: (Effect, Env) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, ENV };
    return copySig(2, input_sig);
  }
  case HR_abc_hasnext: {
    /* abc_hasnext: (Effect, Atom, Int) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_abc_hasnext2: {
    /* abc_hasnext2: (Effect, Int, Atom) -> (Effect, Boolean, Int, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_never: {
    /* never: () -> Bot */
    return NULL;
  }
  case HR_call: {
    /* call: (Effect, Atom, Atom, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_construct: {
    /* construct: (Effect, Atom, Atom, Atom) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_constructsuper: {
    /* constructsuper: (Effect, Env, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, ENV, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_loadenv_namespace: {
    /* loadenv_namespace: (Ord, Namespace~) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.namespace_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_loadenv_boolean: {
    /* loadenv_boolean: (Ord, Boolean) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.boolean_type };
    return copySig(2, input_sig);
  }
  case HR_loadenv_number: {
    /* loadenv_number: (Ord, Number~) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_loadenv_string: {
    /* loadenv_string: (Ord, String~) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.string_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_loadenv_interface: {
    /* loadenv_interface: (Method, ScriptObject~) -> Env */
    const Type* input_sig[] = { lattice_.method_type, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_loadenv: {
    /* loadenv: (Ord, ScriptObject~) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_loadenv_atom: {
    /* loadenv_atom: (Ord, Atom~) -> Env */
    const Type* input_sig[] = { ORDINAL, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_loadinitenv: {
    /* loadinitenv: ScriptObject~ -> Env */
    return copySig(lattice_.scriptobject_type[kTypeNotNull]);
  }
  case HR_loadsuperinitenv: {
    /* loadsuperinitenv: Env -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_env: {
    /* loadenv_env: (Ord, Env) -> Env */
    const Type* input_sig[] = { ORDINAL, ENV };
    return copySig(2, input_sig);
  }
  case HR_newobject: {
    /* newobject: (Effect, Atom) -> (Effect, ScriptObject~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_newarray: {
    /* newarray: (Effect, Atom) -> (Effect, Array~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_applytype: {
    /* applytype: (Effect, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_newinstance: {
    /* newinstance: Class~ -> ScriptObject~ */
    return copySig(lattice_.class_type[kTypeNotNull]);
  }
  case HR_abc_convert_s: {
    /* abc_convert_s: (Effect, Atom) -> (Effect, String~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_esc_xelem: {
    /* abc_esc_xelem: (Effect, Atom) -> (Effect, String~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_esc_xattr: {
    /* abc_esc_xattr: (Effect, Atom) -> (Effect, String~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_typeof: {
    /* abc_typeof: Atom -> String~ */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_speculate_int: {
    /* speculate_int: (Atom, State) -> Int */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_number: {
    /* speculate_number: (Atom, State) -> Number */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_numeric: {
    /* speculate_numeric: (Atom, State) -> Number */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_string: {
    /* speculate_string: (Atom, State) -> String */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_object: {
    /* speculate_object: (Atom, State) -> Object */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_array: {
    /* speculate_array: (Atom, State) -> Array */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_speculate_bool: {
    /* speculate_bool: (Atom, State) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], STATE };
    return copySig(2, input_sig);
  }
  case HR_ckfilter: {
    /* ckfilter: Atom~ -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_abc_add: {
    /* abc_add: (Effect, Atom, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_addd: {
    /* addd: (Number, Number) -> Number */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_concat_strings: {
    /* concat_strings: (String, String) -> String~ */
    const Type* input_sig[] = { lattice_.string_type[kTypeNullable], lattice_.string_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_nextname: {
    /* abc_nextname: (Effect, Atom, Int) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_abc_nextvalue: {
    /* abc_nextvalue: (Effect, Atom, Int) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_lessthan: {
    /* lessthan: (Atom, Atom) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_lessequals: {
    /* lessequals: (Atom, Atom) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_greaterthan: {
    /* greaterthan: (Atom, Atom) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_greaterequals: {
    /* greaterequals: (Atom, Atom) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_instanceof: {
    /* abc_instanceof: (Effect, Atom, Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_istype: {
    /* abc_istype: (Effect, Traits, Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, TRAITS, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_istypelate: {
    /* abc_istypelate: (Effect, Atom, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_astype: {
    /* abc_astype: (Traits, Atom) -> Atom */
    const Type* input_sig[] = { TRAITS, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_astypelate: {
    /* abc_astypelate: (Effect, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_in: {
    /* abc_in: (Effect, Atom, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_divd: {
    /* divd: (Number, Number) -> Number */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_modulo: {
    /* modulo: (Number, Number) -> Number */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_subd: {
    /* subd: (Number, Number) -> Number */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_muld: {
    /* muld: (Number, Number) -> Number */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_addi: {
    /* addi: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_subi: {
    /* subi: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_muli: {
    /* muli: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_ori: {
    /* ori: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_andi: {
    /* andi: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_xori: {
    /* xori: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_lshi: {
    /* lshi: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_rshi: {
    /* rshi: (Int, Int) -> Int */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_rshui: {
    /* rshui: (Int, Int) -> Uint */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_noti: {
    /* noti: Int -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_negi: {
    /* negi: Int -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_negd: {
    /* negd: Number -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_not: {
    /* not: Boolean -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_newactivation: {
    /* newactivation: (Effect, Env) -> (Effect, ScriptObject~) */
    const Type* input_sig[] = { EFFECT, ENV };
    return copySig(2, input_sig);
  }
  case HR_abc_finddef: {
    /* abc_finddef: (Effect, Name, Env) -> (Effect, ScriptObject~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV };
    return copySig(3, input_sig);
  }
  case HR_abc_findpropstrict: {
    /* abc_findpropstrict: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_findpropstrictx: {
    /* abc_findpropstrictx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_abc_findpropstrictns: {
    /* abc_findpropstrictns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_abc_findpropstrictnsx: {
    /* abc_findpropstrictnsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_abc_findproperty: {
    /* abc_findproperty: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_findpropertyx: {
    /* abc_findpropertyx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_abc_findpropertyns: {
    /* abc_findpropertyns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_abc_findpropertynsx: {
    /* abc_findpropertynsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, NAME, ENV, ORDINAL, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(6, input_sig);
  }
  case HR_newclass: {
    /* newclass: (Effect, Traits~, Class, Atom~) -> (Effect, Class~) */
    const Type* input_sig[] = { EFFECT, TRAITS, lattice_.class_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_newfunction: {
    /* newfunction: (Effect, Method, Atom~) -> (Effect, Function~) */
    const Type* input_sig[] = { EFFECT, lattice_.method_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_getsuper: {
    /* abc_getsuper: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_getsuperx: {
    /* abc_getsuperx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_getsuperns: {
    /* abc_getsuperns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_getsupernsx: {
    /* abc_getsupernsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_getdescendants: {
    /* abc_getdescendants: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_getdescendantsx: {
    /* abc_getdescendantsx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_getdescendantsns: {
    /* abc_getdescendantsns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_getdescendantsnsx: {
    /* abc_getdescendantsnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_callprop: {
    /* abc_callprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_callpropx: {
    /* abc_callpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callpropns: {
    /* abc_callpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callpropnsx: {
    /* abc_callpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_callproplex: {
    /* abc_callproplex: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_callproplexx: {
    /* abc_callproplexx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callproplexns: {
    /* abc_callproplexns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callproplexnsx: {
    /* abc_callproplexnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_constructprop: {
    /* abc_constructprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_constructpropx: {
    /* abc_constructpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_constructpropns: {
    /* abc_constructpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_constructpropnsx: {
    /* abc_constructpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_callsuper: {
    /* abc_callsuper: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_callsuperx: {
    /* abc_callsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callsuperns: {
    /* abc_callsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_callsupernsx: {
    /* abc_callsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_callstatic: {
    /* callstatic: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, ENV, TOPDATA, TOPDATA };
    return copySig(4, input_sig);
  }
  case HR_callmethod: {
    /* callmethod: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, ENV, TOPDATA, TOPDATA };
    return copySig(4, input_sig);
  }
  case HR_callinterface: {
    /* callinterface: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, ENV, TOPDATA, TOPDATA };
    return copySig(4, input_sig);
  }
  case HR_newcatch: {
    /* newcatch: (Effect, Traits~) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, TRAITS };
    return copySig(2, input_sig);
  }
  case HR_setslot: {
    /* setslot: (Effect, Ord, ScriptObject~, TopData) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNotNull], TOPDATA };
    return copySig(4, input_sig);
  }
  case HR_getslot: {
    /* getslot: (Effect, Ord, ScriptObject~) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_slottype: {
    /* slottype: (ScriptObject~, Ord) -> Traits */
    const Type* input_sig[] = { lattice_.scriptobject_type[kTypeNotNull], ORDINAL };
    return copySig(2, input_sig);
  }
  case HR_getouterscope: {
    /* getouterscope: (Ord, Env) -> Atom~ */
    const Type* input_sig[] = { ORDINAL, ENV };
    return copySig(2, input_sig);
  }
  case HR_safepoint: {
    /* safepoint: (Effect, State) -> (Effect, State) */
    const Type* input_sig[] = { EFFECT, STATE };
    return copySig(2, input_sig);
  }
  case HR_setlocal: {
    /* setlocal: (State, Atom) -> State */
    const Type* input_sig[] = { STATE, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_newstate: {
    /* newstate: () -> State */
    return NULL;
  }
  case HR_deopt_safepoint: {
    /* deopt_safepoint: (Effect, TopData) -> Effect */
    const Type* input_sig[] = { EFFECT, TOPDATA };
    return copySig(2, input_sig);
  }
  case HR_deopt_finish: {
    /* deopt_finish: Effect -> Effect */
    return copySig(EFFECT);
  }
  case HR_deopt_finishcall: {
    /* deopt_finishcall: (Effect, TopData) -> Effect */
    const Type* input_sig[] = { EFFECT, TOPDATA };
    return copySig(2, input_sig);
  }
  case HR_debugline: {
    /* debugline: (Effect, Int) -> Effect */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_debugfile: {
    /* debugfile: (Effect, String) -> Effect */
    const Type* input_sig[] = { EFFECT, lattice_.string_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_string2atom: {
    /* string2atom: String -> Atom */
    return copySig(lattice_.string_type[kTypeNullable]);
  }
  case HR_double2atom: {
    /* double2atom: Number -> Atom~ */
    return copySig(lattice_.double_type);
  }
  case HR_int2atom: {
    /* int2atom: Int -> Atom~ */
    return copySig(lattice_.int_type);
  }
  case HR_uint2atom: {
    /* uint2atom: Uint -> Atom~ */
    return copySig(lattice_.uint_type);
  }
  case HR_scriptobject2atom: {
    /* scriptobject2atom: ScriptObject -> Atom */
    return copySig(lattice_.scriptobject_type[kTypeNullable]);
  }
  case HR_bool2atom: {
    /* bool2atom: Boolean -> Atom~ */
    return copySig(lattice_.boolean_type);
  }
  case HR_ns2atom: {
    /* ns2atom: Namespace -> Atom */
    return copySig(lattice_.namespace_type[kTypeNullable]);
  }
  case HR_atom2bool: {
    /* atom2bool: Atom~ -> Boolean */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_atom2double: {
    /* atom2double: Atom -> Number */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2string: {
    /* atom2string: Atom -> String */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2int: {
    /* atom2int: Atom -> Int */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2uint: {
    /* atom2uint: Atom -> Uint */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2scriptobject: {
    /* atom2scriptobject: Atom -> ScriptObject */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2ns: {
    /* atom2ns: Atom -> Namespace */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_i2d: {
    /* i2d: Int -> Number */
    return copySig(lattice_.int_type);
  }
  case HR_u2d: {
    /* u2d: Uint -> Number */
    return copySig(lattice_.uint_type);
  }
  case HR_d2i: {
    /* d2i: Number -> Int */
    return copySig(lattice_.double_type);
  }
  case HR_d2u: {
    /* d2u: Number -> Uint */
    return copySig(lattice_.double_type);
  }
  case HR_toslot: {
    /* toslot: (ScriptObject, Name) -> Ord */
    const Type* input_sig[] = { lattice_.scriptobject_type[kTypeNullable], NAME };
    return copySig(2, input_sig);
  }
  case HR_toprimitive: {
    /* toprimitive: (Effect, Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_eqi: {
    /* eqi: (Int, Int) -> Boolean */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_lti: {
    /* lti: (Int, Int) -> Boolean */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_lei: {
    /* lei: (Int, Int) -> Boolean */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_gti: {
    /* gti: (Int, Int) -> Boolean */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_gei: {
    /* gei: (Int, Int) -> Boolean */
    const Type* input_sig[] = { lattice_.int_type, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_eqd: {
    /* eqd: (Number, Number) -> Boolean */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_ltd: {
    /* ltd: (Number, Number) -> Boolean */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_led: {
    /* led: (Number, Number) -> Boolean */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_gtd: {
    /* gtd: (Number, Number) -> Boolean */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_ged: {
    /* ged: (Number, Number) -> Boolean */
    const Type* input_sig[] = { lattice_.double_type, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_equi: {
    /* equi: (Uint, Uint) -> Boolean */
    const Type* input_sig[] = { lattice_.uint_type, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_ltui: {
    /* ltui: (Uint, Uint) -> Boolean */
    const Type* input_sig[] = { lattice_.uint_type, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_leui: {
    /* leui: (Uint, Uint) -> Boolean */
    const Type* input_sig[] = { lattice_.uint_type, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_gtui: {
    /* gtui: (Uint, Uint) -> Boolean */
    const Type* input_sig[] = { lattice_.uint_type, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_geui: {
    /* geui: (Uint, Uint) -> Boolean */
    const Type* input_sig[] = { lattice_.uint_type, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_eqb: {
    /* eqb: (Boolean, Boolean) -> Boolean */
    const Type* input_sig[] = { lattice_.boolean_type, lattice_.boolean_type };
    return copySig(2, input_sig);
  }
  case HR_doubletoint32: {
    /* doubletoint32: Number -> Int */
    return copySig(lattice_.double_type);
  }
  case HR_i2u: {
    /* i2u: Int -> Uint */
    return copySig(lattice_.int_type);
  }
  case HR_u2i: {
    /* u2i: Uint -> Int */
    return copySig(lattice_.uint_type);
  }
  case HR_abc_dxnslate: {
    /* abc_dxnslate: (Effect, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_dxns: {
    /* abc_dxns: (Effect, String~) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, input_sig);
  }
  case HR_li8: {
    /* li8: (Effect, Int) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_li16: {
    /* li16: (Effect, Int) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_li32: {
    /* li32: (Effect, Int) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_lf32: {
    /* lf32: (Effect, Int) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_lf64: {
    /* lf64: (Effect, Int) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_si8: {
    /* si8: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_si16: {
    /* si16: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_si32: {
    /* si32: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_sf32: {
    /* sf32: (Effect, Number, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_sf64: {
    /* sf64: (Effect, Number, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_abc_equals: {
    /* abc_equals: (Effect, Atom, Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_eqp: {
    /* eqp: (ScriptObject, ScriptObject) -> Boolean */
    const Type* input_sig[] = { lattice_.scriptobject_type[kTypeNullable], lattice_.scriptobject_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_eqs: {
    /* eqs: (String, String) -> Boolean */
    const Type* input_sig[] = { lattice_.string_type[kTypeNullable], lattice_.string_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_strictequals: {
    /* abc_strictequals: (Atom, Atom) -> Boolean */
    const Type* input_sig[] = { lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_setsuper: {
    /* abc_setsuper: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_setsuperx: {
    /* abc_setsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_setsuperns: {
    /* abc_setsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_setsupernsx: {
    /* abc_setsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_deleteprop: {
    /* abc_deleteprop: (Effect, Name, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_deletepropx: {
    /* abc_deletepropx: (Effect, Name, Atom, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_deletepropns: {
    /* abc_deletepropns: (Effect, Name, Atom, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_deletepropnsx: {
    /* abc_deletepropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_getprop: {
    /* abc_getprop: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_getpropx: {
    /* abc_getpropx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropertylate_u: {
    /* getpropertylate_u: (Effect, Uint, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_getpropertylate_i: {
    /* getpropertylate_i: (Effect, Int, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_getpropertylate_d: {
    /* getpropertylate_d: (Effect, Number, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_array_get_u: {
    /* array_get_u: (Effect, Uint, Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.array_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_array_get_i: {
    /* array_get_i: (Effect, Int, Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.array_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_array_get_d: {
    /* array_get_d: (Effect, Number, Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.array_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectorint_get_u: {
    /* vectorint_get_u: (Effect, Uint, VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectorint_get_i: {
    /* vectorint_get_i: (Effect, Int, VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectorint_get_d: {
    /* vectorint_get_d: (Effect, Number, VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectoruint_get_u: {
    /* vectoruint_get_u: (Effect, Uint, VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectoruint_get_i: {
    /* vectoruint_get_i: (Effect, Int, VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectoruint_get_d: {
    /* vectoruint_get_d: (Effect, Number, VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectordouble_get_u: {
    /* vectordouble_get_u: (Effect, Uint, VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectordouble_get_i: {
    /* vectordouble_get_i: (Effect, Int, VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_vectordouble_get_d: {
    /* vectordouble_get_d: (Effect, Number, VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(3, input_sig);
  }
  case HR_abc_getpropns: {
    /* abc_getpropns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_getpropnsx: {
    /* abc_getpropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull] };
    return copySig(5, input_sig);
  }
  case HR_abc_setprop: {
    /* abc_setprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_setpropx: {
    /* abc_setpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropertylate_u: {
    /* setpropertylate_u: (Effect, Uint, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_setpropertylate_i: {
    /* setpropertylate_i: (Effect, Int, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_setpropertylate_d: {
    /* setpropertylate_d: (Effect, Number, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_array_set_u: {
    /* array_set_u: (Effect, Uint, Array~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_array_set_i: {
    /* array_set_i: (Effect, Int, Array~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_array_set_d: {
    /* array_set_d: (Effect, Number, Array~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_vectorint_set_u: {
    /* vectorint_set_u: (Effect, Uint, VectorInt~, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull], lattice_.int_type };
    return copySig(4, input_sig);
  }
  case HR_vectorint_set_i: {
    /* vectorint_set_i: (Effect, Int, VectorInt~, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull], lattice_.int_type };
    return copySig(4, input_sig);
  }
  case HR_vectorint_set_d: {
    /* vectorint_set_d: (Effect, Number, VectorInt~, Int) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull], lattice_.int_type };
    return copySig(4, input_sig);
  }
  case HR_vectoruint_set_u: {
    /* vectoruint_set_u: (Effect, Uint, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.uint_type };
    return copySig(4, input_sig);
  }
  case HR_vectoruint_set_i: {
    /* vectoruint_set_i: (Effect, Int, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.uint_type };
    return copySig(4, input_sig);
  }
  case HR_vectoruint_set_d: {
    /* vectoruint_set_d: (Effect, Number, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.uint_type };
    return copySig(4, input_sig);
  }
  case HR_vectordouble_set_u: {
    /* vectordouble_set_u: (Effect, Uint, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.double_type };
    return copySig(4, input_sig);
  }
  case HR_vectordouble_set_i: {
    /* vectordouble_set_i: (Effect, Int, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.double_type };
    return copySig(4, input_sig);
  }
  case HR_vectordouble_set_d: {
    /* vectordouble_set_d: (Effect, Number, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.double_type };
    return copySig(4, input_sig);
  }
  case HR_abc_setpropns: {
    /* abc_setpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_setpropnsx: {
    /* abc_setpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_initprop: {
    /* abc_initprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_abc_initpropx: {
    /* abc_initpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_initpropns: {
    /* abc_initpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_initpropnsx: {
    /* abc_initpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(6, input_sig);
  }
  case HR_abc_increment: {
    /* abc_increment: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_decrement: {
    /* abc_decrement: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_increment_i: {
    /* abc_increment_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_decrement_i: {
    /* abc_decrement_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_not: {
    /* abc_not: (effect0:Effect, x:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_negate: {
    /* abc_negate: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_bitnot: {
    /* abc_bitnot: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_negate_i: {
    /* abc_negate_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_sxi1: {
    /* abc_sxi1: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_sxi8: {
    /* abc_sxi8: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_sxi16: {
    /* abc_sxi16: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_checkfilter: {
    /* abc_checkfilter: (effect0:Effect, x:Atom) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_li8: {
    /* abc_li8: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_li16: {
    /* abc_li16: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_li32: {
    /* abc_li32: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_lf32: {
    /* abc_lf32: (effect0:Effect, addr:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_lf64: {
    /* abc_lf64: (effect0:Effect, addr:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, input_sig);
  }
  case HR_abc_si8: {
    /* abc_si8: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_si16: {
    /* abc_si16: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_si32: {
    /* abc_si32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_sf32: {
    /* abc_sf32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_sf64: {
    /* abc_sf64: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_subtract: {
    /* abc_subtract: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_multiply: {
    /* abc_multiply: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_modulo: {
    /* abc_modulo: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_divide: {
    /* abc_divide: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_add_i: {
    /* abc_add_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_subtract_i: {
    /* abc_subtract_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_multiply_i: {
    /* abc_multiply_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_bitor: {
    /* abc_bitor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_bitand: {
    /* abc_bitand: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_bitxor: {
    /* abc_bitxor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_lshift: {
    /* abc_lshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_rshift: {
    /* abc_rshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_urshift: {
    /* abc_urshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_add_ui: {
    /* add_ui: (effect0:Effect, x:Uint, y:Int) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_add_nn: {
    /* add_nn: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_add_ss: {
    /* add_ss: (effect0:Effect, x:Atom, y:Atom) -> (Effect, String~) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_lessthan: {
    /* abc_lessthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_greaterequals: {
    /* abc_greaterequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_greaterthan: {
    /* abc_greaterthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_lessequals: {
    /* abc_lessequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_ii: {
    /* abc_equals_ii: (effect0:Effect, x:Int, y:Int) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type, lattice_.int_type };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_uu: {
    /* abc_equals_uu: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.uint_type };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_bb: {
    /* abc_equals_bb: (effect0:Effect, x:Boolean, y:Boolean) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.boolean_type, lattice_.boolean_type };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_nn: {
    /* abc_equals_nn: (effect0:Effect, x:Number, y:Number) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type, lattice_.double_type };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_pp: {
    /* abc_equals_pp: (effect0:Effect, x:ScriptObject, y:ScriptObject) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNullable], lattice_.scriptobject_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_equals_ss: {
    /* abc_equals_ss: (effect0:Effect, x:String, y:String) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, lattice_.string_type[kTypeNullable], lattice_.string_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_getslot: {
    /* abc_getslot: (effect0:Effect, slot:Ord, object:ScriptObject) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_abc_getprop_slot: {
    /* abc_getprop_slot: (effect0:Effect, name:Name, any:ScriptObject) -> (Effect, TopData) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.scriptobject_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_getpropx_u: {
    /* getpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_i: {
    /* getpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_d: {
    /* getpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.atom_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_au: {
    /* getpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.array_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_ai: {
    /* getpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.array_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_ad: {
    /* getpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.array_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_viu: {
    /* getpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vii: {
    /* getpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vid: {
    /* getpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vuu: {
    /* getpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vui: {
    /* getpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vud: {
    /* getpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vdu: {
    /* getpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vdi: {
    /* getpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_getpropx_vdd: {
    /* getpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull] };
    return copySig(4, input_sig);
  }
  case HR_abc_setprop_slot: {
    /* abc_setprop_slot: (effect0:Effect, name:Name, object:ScriptObject, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, NAME, lattice_.scriptobject_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_setpropx_u: {
    /* setpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_i: {
    /* setpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_d: {
    /* setpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_au: {
    /* setpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_ai: {
    /* setpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_ad: {
    /* setpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_viu: {
    /* setpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vii: {
    /* setpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vid: {
    /* setpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vuu: {
    /* setpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vui: {
    /* setpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vud: {
    /* setpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vdu: {
    /* setpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vdi: {
    /* setpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_setpropx_vdd: {
    /* setpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    return copySig(5, input_sig);
  }
  case HR_abc_setslot: {
    /* abc_setslot: (effect0:Effect, slot:Ord, object:ScriptObject, val:Atom) -> (Effect, Bot) */
    const Type* input_sig[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_findprop2finddef: {
    /* findprop2finddef: (effect0:Effect, name:Env, env:Name, scopes:Top) -> (Effect, ScriptObject~) */
    const Type* input_sig[] = { EFFECT, ENV, NAME, TOP };
    return copySig(4, input_sig);
  }
  case HR_findprop2getouter: {
    /* findprop2getouter: (effect0:Effect, index:Ord, env:Env, scopes:Top) -> (Effect, Atom~) */
    const Type* input_sig[] = { EFFECT, ORDINAL, ENV, TOP };
    return copySig(4, input_sig);
  }
  case HR_callprop_string: {
    /* callprop_string: (effect0:Effect, name:Top, stringclass:Top, value:Atom) -> (Effect, String~) */
    const Type* input_sig[] = { EFFECT, TOP, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(4, input_sig);
  }
  case HR_coerce_any: {
    /* coerce_any: (effect0:Effect, traits:Top, value:Top) -> (Effect, Top) */
    const Type* input_sig[] = { EFFECT, TOP, TOP };
    return copySig(3, input_sig);
  }
  case HR_coerce_object: {
    /* coerce_object: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Atom) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_number: {
    /* coerce_number: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Number) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_int: {
    /* coerce_int: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_uint: {
    /* coerce_uint: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_boolean: {
    /* coerce_boolean: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Boolean) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_string: {
    /* coerce_string: (effect0:Effect, traits:Top, value:Atom) -> (Effect, String) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_coerce_ns: {
    /* coerce_ns: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Namespace) */
    const Type* input_sig[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    return copySig(3, input_sig);
  }
  case HR_inttouint: {
    /* inttouint: (effect0:Effect, value:Int) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, input_sig);
  }
  case HR_uinttoint: {
    /* uinttoint: (effect0:Effect, value:Uint) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, input_sig);
  }
  case HR_numbertoint: {
    /* numbertoint: (effect0:Effect, value:Number) -> (Effect, Int) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_numbertouint: {
    /* numbertouint: (effect0:Effect, value:Number) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, input_sig);
  }
  case HR_abc_modulo_and: {
    /* abc_modulo_and: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Uint) */
    const Type* input_sig[] = { EFFECT, lattice_.uint_type, lattice_.uint_type };
    return copySig(3, input_sig);
  }
  default: {
    assert(false && "unsupported opcode");
    return NULL;
  }
  } // switch
}

/// return output type signature for given instruction
///
const Type** InstrFactory::buildOutputSignature(InstrKind kind) {
  switch (kind) {
  case HR_start: {
    /* start: () -> (Effect, Top) */
    const Type* output_sig[] = { EFFECT, TOP };
    return copySig(2, output_sig);
  }
  case HR_template: {
    /* template: () -> (Effect, Top) */
    const Type* output_sig[] = { EFFECT, TOP };
    return copySig(2, output_sig);
  }
  case HR_catchblock: {
    /* catchblock: () -> Top */
    return copySig(TOP);
  }
  case HR_return: {
    /* return: (Effect, Top) -> () */
    return NULL;
  }
  case HR_throw: {
    /* throw: (Effect, Atom) -> () */
    return NULL;
  }
  case HR_goto: {
    /* goto: Top -> () */
    return NULL;
  }
  case HR_label: {
    /* label: () -> Top */
    return copySig(TOP);
  }
  case HR_if: {
    /* if: (Boolean, Top) -> () */
    return NULL;
  }
  case HR_switch: {
    /* switch: (Int, Top) -> () */
    return NULL;
  }
  case HR_arm: {
    /* arm: () -> Top */
    return copySig(TOP);
  }
  case HR_const: {
    /* const: () -> Top */
    return copySig(TOP);
  }
  case HR_coerce: {
    /* coerce: (Effect, Traits, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_cast: {
    /* cast: (Effect, Traits, Atom) -> (Effect, ScriptObject) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_castobject: {
    /* castobject: Atom -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_tonumber: {
    /* tonumber: (Effect, Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_toint: {
    /* toint: (Effect, Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_touint: {
    /* touint: (Effect, Atom) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_toboolean: {
    /* toboolean: Atom -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_d2b: {
    /* d2b: Number -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_caststring: {
    /* caststring: (Effect, Atom) -> (Effect, String) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_castns: {
    /* castns: (Effect, Atom) -> (Effect, Namespace) */
    const Type* output_sig[] = { EFFECT, lattice_.namespace_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_cknull: {
    /* cknull: (Effect, Atom) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_cknullobject: {
    /* cknullobject: (Effect, ScriptObject) -> (Effect, ScriptObject~) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_cktimeout: {
    /* cktimeout: (Effect, Env) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_hasnext: {
    /* abc_hasnext: (Effect, Atom, Int) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_hasnext2: {
    /* abc_hasnext2: (Effect, Int, Atom) -> (Effect, Boolean, Int, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type, lattice_.int_type, lattice_.atom_type[kTypeNullable] };
    return copySig(4, output_sig);
  }
  case HR_never: {
    /* never: () -> Bot */
    return copySig(BOT);
  }
  case HR_call: {
    /* call: (Effect, Atom, Atom, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_construct: {
    /* construct: (Effect, Atom, Atom, Atom) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_constructsuper: {
    /* constructsuper: (Effect, Env, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_loadenv_namespace: {
    /* loadenv_namespace: (Ord, Namespace~) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_boolean: {
    /* loadenv_boolean: (Ord, Boolean) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_number: {
    /* loadenv_number: (Ord, Number~) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_string: {
    /* loadenv_string: (Ord, String~) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_interface: {
    /* loadenv_interface: (Method, ScriptObject~) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv: {
    /* loadenv: (Ord, ScriptObject~) -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_atom: {
    /* loadenv_atom: (Ord, Atom~) -> Env */
    return copySig(ENV);
  }
  case HR_loadinitenv: {
    /* loadinitenv: ScriptObject~ -> Env */
    return copySig(ENV);
  }
  case HR_loadsuperinitenv: {
    /* loadsuperinitenv: Env -> Env */
    return copySig(ENV);
  }
  case HR_loadenv_env: {
    /* loadenv_env: (Ord, Env) -> Env */
    return copySig(ENV);
  }
  case HR_newobject: {
    /* newobject: (Effect, Atom) -> (Effect, ScriptObject~) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_newarray: {
    /* newarray: (Effect, Atom) -> (Effect, Array~) */
    const Type* output_sig[] = { EFFECT, lattice_.array_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_applytype: {
    /* applytype: (Effect, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_newinstance: {
    /* newinstance: Class~ -> ScriptObject~ */
    return copySig(lattice_.scriptobject_type[kTypeNotNull]);
  }
  case HR_abc_convert_s: {
    /* abc_convert_s: (Effect, Atom) -> (Effect, String~) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_esc_xelem: {
    /* abc_esc_xelem: (Effect, Atom) -> (Effect, String~) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_esc_xattr: {
    /* abc_esc_xattr: (Effect, Atom) -> (Effect, String~) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_typeof: {
    /* abc_typeof: Atom -> String~ */
    return copySig(lattice_.string_type[kTypeNotNull]);
  }
  case HR_speculate_int: {
    /* speculate_int: (Atom, State) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_speculate_number: {
    /* speculate_number: (Atom, State) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_speculate_numeric: {
    /* speculate_numeric: (Atom, State) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_speculate_string: {
    /* speculate_string: (Atom, State) -> String */
    return copySig(lattice_.string_type[kTypeNullable]);
  }
  case HR_speculate_object: {
    /* speculate_object: (Atom, State) -> Object */
    return copySig(lattice_.object_type[kTypeNullable]);
  }
  case HR_speculate_array: {
    /* speculate_array: (Atom, State) -> Array */
    return copySig(lattice_.array_type[kTypeNullable]);
  }
  case HR_speculate_bool: {
    /* speculate_bool: (Atom, State) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_ckfilter: {
    /* ckfilter: Atom~ -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_abc_add: {
    /* abc_add: (Effect, Atom, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_addd: {
    /* addd: (Number, Number) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_concat_strings: {
    /* concat_strings: (String, String) -> String~ */
    return copySig(lattice_.string_type[kTypeNotNull]);
  }
  case HR_abc_nextname: {
    /* abc_nextname: (Effect, Atom, Int) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_nextvalue: {
    /* abc_nextvalue: (Effect, Atom, Int) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_lessthan: {
    /* lessthan: (Atom, Atom) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_lessequals: {
    /* lessequals: (Atom, Atom) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_greaterthan: {
    /* greaterthan: (Atom, Atom) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_greaterequals: {
    /* greaterequals: (Atom, Atom) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_abc_instanceof: {
    /* abc_instanceof: (Effect, Atom, Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_istype: {
    /* abc_istype: (Effect, Traits, Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_istypelate: {
    /* abc_istypelate: (Effect, Atom, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_astype: {
    /* abc_astype: (Traits, Atom) -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_abc_astypelate: {
    /* abc_astypelate: (Effect, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_in: {
    /* abc_in: (Effect, Atom, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_divd: {
    /* divd: (Number, Number) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_modulo: {
    /* modulo: (Number, Number) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_subd: {
    /* subd: (Number, Number) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_muld: {
    /* muld: (Number, Number) -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_addi: {
    /* addi: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_subi: {
    /* subi: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_muli: {
    /* muli: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_ori: {
    /* ori: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_andi: {
    /* andi: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_xori: {
    /* xori: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_lshi: {
    /* lshi: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_rshi: {
    /* rshi: (Int, Int) -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_rshui: {
    /* rshui: (Int, Int) -> Uint */
    return copySig(lattice_.uint_type);
  }
  case HR_noti: {
    /* noti: Int -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_negi: {
    /* negi: Int -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_negd: {
    /* negd: Number -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_not: {
    /* not: Boolean -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_newactivation: {
    /* newactivation: (Effect, Env) -> (Effect, ScriptObject~) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_finddef: {
    /* abc_finddef: (Effect, Name, Env) -> (Effect, ScriptObject~) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropstrict: {
    /* abc_findpropstrict: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropstrictx: {
    /* abc_findpropstrictx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropstrictns: {
    /* abc_findpropstrictns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropstrictnsx: {
    /* abc_findpropstrictnsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findproperty: {
    /* abc_findproperty: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropertyx: {
    /* abc_findpropertyx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropertyns: {
    /* abc_findpropertyns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_findpropertynsx: {
    /* abc_findpropertynsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_newclass: {
    /* newclass: (Effect, Traits~, Class, Atom~) -> (Effect, Class~) */
    const Type* output_sig[] = { EFFECT, lattice_.class_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_newfunction: {
    /* newfunction: (Effect, Method, Atom~) -> (Effect, Function~) */
    const Type* output_sig[] = { EFFECT, lattice_.function_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_getsuper: {
    /* abc_getsuper: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getsuperx: {
    /* abc_getsuperx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getsuperns: {
    /* abc_getsuperns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getsupernsx: {
    /* abc_getsupernsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getdescendants: {
    /* abc_getdescendants: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getdescendantsx: {
    /* abc_getdescendantsx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getdescendantsns: {
    /* abc_getdescendantsns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getdescendantsnsx: {
    /* abc_getdescendantsnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callprop: {
    /* abc_callprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callpropx: {
    /* abc_callpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callpropns: {
    /* abc_callpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callpropnsx: {
    /* abc_callpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callproplex: {
    /* abc_callproplex: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callproplexx: {
    /* abc_callproplexx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callproplexns: {
    /* abc_callproplexns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callproplexnsx: {
    /* abc_callproplexnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_constructprop: {
    /* abc_constructprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_constructpropx: {
    /* abc_constructpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_constructpropns: {
    /* abc_constructpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_constructpropnsx: {
    /* abc_constructpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callsuper: {
    /* abc_callsuper: (Effect, Name, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callsuperx: {
    /* abc_callsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callsuperns: {
    /* abc_callsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_callsupernsx: {
    /* abc_callsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_callstatic: {
    /* callstatic: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_callmethod: {
    /* callmethod: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_callinterface: {
    /* callinterface: (Effect, Env, TopData, TopData) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_newcatch: {
    /* newcatch: (Effect, Traits~) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_setslot: {
    /* setslot: (Effect, Ord, ScriptObject~, TopData) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_getslot: {
    /* getslot: (Effect, Ord, ScriptObject~) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_slottype: {
    /* slottype: (ScriptObject~, Ord) -> Traits */
    return copySig(TRAITS);
  }
  case HR_getouterscope: {
    /* getouterscope: (Ord, Env) -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_safepoint: {
    /* safepoint: (Effect, State) -> (Effect, State) */
    const Type* output_sig[] = { EFFECT, STATE };
    return copySig(2, output_sig);
  }
  case HR_setlocal: {
    /* setlocal: (State, Atom) -> State */
    return copySig(STATE);
  }
  case HR_newstate: {
    /* newstate: () -> State */
    return copySig(STATE);
  }
  case HR_deopt_safepoint: {
    /* deopt_safepoint: (Effect, TopData) -> Effect */
    return copySig(EFFECT);
  }
  case HR_deopt_finish: {
    /* deopt_finish: Effect -> Effect */
    return copySig(EFFECT);
  }
  case HR_deopt_finishcall: {
    /* deopt_finishcall: (Effect, TopData) -> Effect */
    return copySig(EFFECT);
  }
  case HR_debugline: {
    /* debugline: (Effect, Int) -> Effect */
    return copySig(EFFECT);
  }
  case HR_debugfile: {
    /* debugfile: (Effect, String) -> Effect */
    return copySig(EFFECT);
  }
  case HR_string2atom: {
    /* string2atom: String -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_double2atom: {
    /* double2atom: Number -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_int2atom: {
    /* int2atom: Int -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_uint2atom: {
    /* uint2atom: Uint -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_scriptobject2atom: {
    /* scriptobject2atom: ScriptObject -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_bool2atom: {
    /* bool2atom: Boolean -> Atom~ */
    return copySig(lattice_.atom_type[kTypeNotNull]);
  }
  case HR_ns2atom: {
    /* ns2atom: Namespace -> Atom */
    return copySig(lattice_.atom_type[kTypeNullable]);
  }
  case HR_atom2bool: {
    /* atom2bool: Atom~ -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_atom2double: {
    /* atom2double: Atom -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_atom2string: {
    /* atom2string: Atom -> String */
    return copySig(lattice_.string_type[kTypeNullable]);
  }
  case HR_atom2int: {
    /* atom2int: Atom -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_atom2uint: {
    /* atom2uint: Atom -> Uint */
    return copySig(lattice_.uint_type);
  }
  case HR_atom2scriptobject: {
    /* atom2scriptobject: Atom -> ScriptObject */
    return copySig(lattice_.scriptobject_type[kTypeNullable]);
  }
  case HR_atom2ns: {
    /* atom2ns: Atom -> Namespace */
    return copySig(lattice_.namespace_type[kTypeNullable]);
  }
  case HR_i2d: {
    /* i2d: Int -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_u2d: {
    /* u2d: Uint -> Number */
    return copySig(lattice_.double_type);
  }
  case HR_d2i: {
    /* d2i: Number -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_d2u: {
    /* d2u: Number -> Uint */
    return copySig(lattice_.uint_type);
  }
  case HR_toslot: {
    /* toslot: (ScriptObject, Name) -> Ord */
    return copySig(ORDINAL);
  }
  case HR_toprimitive: {
    /* toprimitive: (Effect, Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_eqi: {
    /* eqi: (Int, Int) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_lti: {
    /* lti: (Int, Int) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_lei: {
    /* lei: (Int, Int) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_gti: {
    /* gti: (Int, Int) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_gei: {
    /* gei: (Int, Int) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_eqd: {
    /* eqd: (Number, Number) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_ltd: {
    /* ltd: (Number, Number) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_led: {
    /* led: (Number, Number) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_gtd: {
    /* gtd: (Number, Number) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_ged: {
    /* ged: (Number, Number) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_equi: {
    /* equi: (Uint, Uint) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_ltui: {
    /* ltui: (Uint, Uint) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_leui: {
    /* leui: (Uint, Uint) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_gtui: {
    /* gtui: (Uint, Uint) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_geui: {
    /* geui: (Uint, Uint) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_eqb: {
    /* eqb: (Boolean, Boolean) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_doubletoint32: {
    /* doubletoint32: Number -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_i2u: {
    /* i2u: Int -> Uint */
    return copySig(lattice_.uint_type);
  }
  case HR_u2i: {
    /* u2i: Uint -> Int */
    return copySig(lattice_.int_type);
  }
  case HR_abc_dxnslate: {
    /* abc_dxnslate: (Effect, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_dxns: {
    /* abc_dxns: (Effect, String~) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_li8: {
    /* li8: (Effect, Int) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_li16: {
    /* li16: (Effect, Int) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_li32: {
    /* li32: (Effect, Int) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_lf32: {
    /* lf32: (Effect, Int) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_lf64: {
    /* lf64: (Effect, Int) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_si8: {
    /* si8: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_si16: {
    /* si16: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_si32: {
    /* si32: (Effect, Int, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_sf32: {
    /* sf32: (Effect, Number, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_sf64: {
    /* sf64: (Effect, Number, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_equals: {
    /* abc_equals: (Effect, Atom, Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_eqp: {
    /* eqp: (ScriptObject, ScriptObject) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_eqs: {
    /* eqs: (String, String) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_abc_strictequals: {
    /* abc_strictequals: (Atom, Atom) -> Boolean */
    return copySig(lattice_.boolean_type);
  }
  case HR_abc_setsuper: {
    /* abc_setsuper: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setsuperx: {
    /* abc_setsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setsuperns: {
    /* abc_setsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setsupernsx: {
    /* abc_setsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_deleteprop: {
    /* abc_deleteprop: (Effect, Name, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_deletepropx: {
    /* abc_deletepropx: (Effect, Name, Atom, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_deletepropns: {
    /* abc_deletepropns: (Effect, Name, Atom, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_deletepropnsx: {
    /* abc_deletepropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_getprop: {
    /* abc_getprop: (Effect, Name, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getpropx: {
    /* abc_getpropx: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropertylate_u: {
    /* getpropertylate_u: (Effect, Uint, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropertylate_i: {
    /* getpropertylate_i: (Effect, Int, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropertylate_d: {
    /* getpropertylate_d: (Effect, Number, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_array_get_u: {
    /* array_get_u: (Effect, Uint, Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_array_get_i: {
    /* array_get_i: (Effect, Int, Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_array_get_d: {
    /* array_get_d: (Effect, Number, Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_vectorint_get_u: {
    /* vectorint_get_u: (Effect, Uint, VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_vectorint_get_i: {
    /* vectorint_get_i: (Effect, Int, VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_vectorint_get_d: {
    /* vectorint_get_d: (Effect, Number, VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_get_u: {
    /* vectoruint_get_u: (Effect, Uint, VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_get_i: {
    /* vectoruint_get_i: (Effect, Int, VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_get_d: {
    /* vectoruint_get_d: (Effect, Number, VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_get_u: {
    /* vectordouble_get_u: (Effect, Uint, VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_get_i: {
    /* vectordouble_get_i: (Effect, Int, VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_get_d: {
    /* vectordouble_get_d: (Effect, Number, VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_getpropns: {
    /* abc_getpropns: (Effect, Name, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_getpropnsx: {
    /* abc_getpropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_abc_setprop: {
    /* abc_setprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setpropx: {
    /* abc_setpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropertylate_u: {
    /* setpropertylate_u: (Effect, Uint, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropertylate_i: {
    /* setpropertylate_i: (Effect, Int, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropertylate_d: {
    /* setpropertylate_d: (Effect, Number, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_array_set_u: {
    /* array_set_u: (Effect, Uint, Array~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_array_set_i: {
    /* array_set_i: (Effect, Int, Array~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_array_set_d: {
    /* array_set_d: (Effect, Number, Array~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectorint_set_u: {
    /* vectorint_set_u: (Effect, Uint, VectorInt~, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectorint_set_i: {
    /* vectorint_set_i: (Effect, Int, VectorInt~, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectorint_set_d: {
    /* vectorint_set_d: (Effect, Number, VectorInt~, Int) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_set_u: {
    /* vectoruint_set_u: (Effect, Uint, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_set_i: {
    /* vectoruint_set_i: (Effect, Int, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectoruint_set_d: {
    /* vectoruint_set_d: (Effect, Number, VectorUInt~, Uint) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_set_u: {
    /* vectordouble_set_u: (Effect, Uint, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_set_i: {
    /* vectordouble_set_i: (Effect, Int, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_vectordouble_set_d: {
    /* vectordouble_set_d: (Effect, Number, VectorDouble~, Number) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setpropns: {
    /* abc_setpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setpropnsx: {
    /* abc_setpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_initprop: {
    /* abc_initprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_initpropx: {
    /* abc_initpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_initpropns: {
    /* abc_initpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_initpropnsx: {
    /* abc_initpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_increment: {
    /* abc_increment: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_decrement: {
    /* abc_decrement: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_increment_i: {
    /* abc_increment_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_decrement_i: {
    /* abc_decrement_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_not: {
    /* abc_not: (effect0:Effect, x:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_negate: {
    /* abc_negate: (effect0:Effect, x:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_bitnot: {
    /* abc_bitnot: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_negate_i: {
    /* abc_negate_i: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_sxi1: {
    /* abc_sxi1: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_sxi8: {
    /* abc_sxi8: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_sxi16: {
    /* abc_sxi16: (effect0:Effect, x:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_checkfilter: {
    /* abc_checkfilter: (effect0:Effect, x:Atom) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_li8: {
    /* abc_li8: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_li16: {
    /* abc_li16: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_li32: {
    /* abc_li32: (effect0:Effect, addr:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_lf32: {
    /* abc_lf32: (effect0:Effect, addr:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_lf64: {
    /* abc_lf64: (effect0:Effect, addr:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_si8: {
    /* abc_si8: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_si16: {
    /* abc_si16: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_si32: {
    /* abc_si32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_sf32: {
    /* abc_sf32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_sf64: {
    /* abc_sf64: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_subtract: {
    /* abc_subtract: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_multiply: {
    /* abc_multiply: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_modulo: {
    /* abc_modulo: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_divide: {
    /* abc_divide: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_add_i: {
    /* abc_add_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_subtract_i: {
    /* abc_subtract_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_multiply_i: {
    /* abc_multiply_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_bitor: {
    /* abc_bitor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_bitand: {
    /* abc_bitand: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_bitxor: {
    /* abc_bitxor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_lshift: {
    /* abc_lshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_rshift: {
    /* abc_rshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_abc_urshift: {
    /* abc_urshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_add_ui: {
    /* add_ui: (effect0:Effect, x:Uint, y:Int) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_add_nn: {
    /* add_nn: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_add_ss: {
    /* add_ss: (effect0:Effect, x:Atom, y:Atom) -> (Effect, String~) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_abc_lessthan: {
    /* abc_lessthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_greaterequals: {
    /* abc_greaterequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_greaterthan: {
    /* abc_greaterthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_lessequals: {
    /* abc_lessequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_ii: {
    /* abc_equals_ii: (effect0:Effect, x:Int, y:Int) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_uu: {
    /* abc_equals_uu: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_bb: {
    /* abc_equals_bb: (effect0:Effect, x:Boolean, y:Boolean) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_nn: {
    /* abc_equals_nn: (effect0:Effect, x:Number, y:Number) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_pp: {
    /* abc_equals_pp: (effect0:Effect, x:ScriptObject, y:ScriptObject) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_equals_ss: {
    /* abc_equals_ss: (effect0:Effect, x:String, y:String) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_abc_getslot: {
    /* abc_getslot: (effect0:Effect, slot:Ord, object:ScriptObject) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_abc_getprop_slot: {
    /* abc_getprop_slot: (effect0:Effect, name:Name, any:ScriptObject) -> (Effect, TopData) */
    const Type* output_sig[] = { EFFECT, TOPDATA };
    return copySig(2, output_sig);
  }
  case HR_getpropx_u: {
    /* getpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_i: {
    /* getpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_d: {
    /* getpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_au: {
    /* getpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_ai: {
    /* getpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_ad: {
    /* getpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_getpropx_viu: {
    /* getpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vii: {
    /* getpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vid: {
    /* getpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vuu: {
    /* getpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vui: {
    /* getpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vud: {
    /* getpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vdu: {
    /* getpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vdi: {
    /* getpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_getpropx_vdd: {
    /* getpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_abc_setprop_slot: {
    /* abc_setprop_slot: (effect0:Effect, name:Name, object:ScriptObject, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_u: {
    /* setpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_i: {
    /* setpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_d: {
    /* setpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_au: {
    /* setpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_ai: {
    /* setpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_ad: {
    /* setpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_viu: {
    /* setpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vii: {
    /* setpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vid: {
    /* setpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vuu: {
    /* setpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vui: {
    /* setpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vud: {
    /* setpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vdu: {
    /* setpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vdi: {
    /* setpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_setpropx_vdd: {
    /* setpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_abc_setslot: {
    /* abc_setslot: (effect0:Effect, slot:Ord, object:ScriptObject, val:Atom) -> (Effect, Bot) */
    const Type* output_sig[] = { EFFECT, BOT };
    return copySig(2, output_sig);
  }
  case HR_findprop2finddef: {
    /* findprop2finddef: (effect0:Effect, name:Env, env:Name, scopes:Top) -> (Effect, ScriptObject~) */
    const Type* output_sig[] = { EFFECT, lattice_.scriptobject_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_findprop2getouter: {
    /* findprop2getouter: (effect0:Effect, index:Ord, env:Env, scopes:Top) -> (Effect, Atom~) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_callprop_string: {
    /* callprop_string: (effect0:Effect, name:Top, stringclass:Top, value:Atom) -> (Effect, String~) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNotNull] };
    return copySig(2, output_sig);
  }
  case HR_coerce_any: {
    /* coerce_any: (effect0:Effect, traits:Top, value:Top) -> (Effect, Top) */
    const Type* output_sig[] = { EFFECT, TOP };
    return copySig(2, output_sig);
  }
  case HR_coerce_object: {
    /* coerce_object: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Atom) */
    const Type* output_sig[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_coerce_number: {
    /* coerce_number: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Number) */
    const Type* output_sig[] = { EFFECT, lattice_.double_type };
    return copySig(2, output_sig);
  }
  case HR_coerce_int: {
    /* coerce_int: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_coerce_uint: {
    /* coerce_uint: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_coerce_boolean: {
    /* coerce_boolean: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Boolean) */
    const Type* output_sig[] = { EFFECT, lattice_.boolean_type };
    return copySig(2, output_sig);
  }
  case HR_coerce_string: {
    /* coerce_string: (effect0:Effect, traits:Top, value:Atom) -> (Effect, String) */
    const Type* output_sig[] = { EFFECT, lattice_.string_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_coerce_ns: {
    /* coerce_ns: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Namespace) */
    const Type* output_sig[] = { EFFECT, lattice_.namespace_type[kTypeNullable] };
    return copySig(2, output_sig);
  }
  case HR_inttouint: {
    /* inttouint: (effect0:Effect, value:Int) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_uinttoint: {
    /* uinttoint: (effect0:Effect, value:Uint) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_numbertoint: {
    /* numbertoint: (effect0:Effect, value:Number) -> (Effect, Int) */
    const Type* output_sig[] = { EFFECT, lattice_.int_type };
    return copySig(2, output_sig);
  }
  case HR_numbertouint: {
    /* numbertouint: (effect0:Effect, value:Number) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  case HR_abc_modulo_and: {
    /* abc_modulo_and: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Uint) */
    const Type* output_sig[] = { EFFECT, lattice_.uint_type };
    return copySig(2, output_sig);
  }
  default: {
    assert(false && "unsupported opcode");
    return NULL;
  }
  } // switch
}
