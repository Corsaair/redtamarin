///
/// generated by templates.py -- do not edit
///

namespace halfmoon {
using namespace avmplus;
struct Stubs {
  static const int stub_count = 245;

  // throw: (Effect, Atom) -> ()
  static void do_throw(MethodFrame*, Atom);

  // coerce: (Effect, Traits, Atom) -> (Effect, Atom)
  static Atom do_coerce(MethodFrame*, Traits*, Atom);

  // cast: (Effect, Traits, Atom) -> (Effect, ScriptObject)
  static ScriptObject* do_cast(MethodFrame*, Traits*, Atom);

  // castobject: Atom -> Atom
  static Atom do_castobject(MethodFrame*, Atom);

  // tonumber: (Effect, Atom) -> (Effect, Number)
  static double do_tonumber(MethodFrame*, Atom);

  // toint: (Effect, Atom) -> (Effect, Int)
  static int32_t do_toint(MethodFrame*, Atom);

  // touint: (Effect, Atom) -> (Effect, Uint)
  static uint32_t do_touint(MethodFrame*, Atom);

  // toboolean: Atom -> Boolean
  static BoolKind do_toboolean(MethodFrame*, Atom);

  // d2b: Number -> Boolean
  static BoolKind do_d2b(MethodFrame*, double);

  // caststring: (Effect, Atom) -> (Effect, String)
  static String* do_caststring(MethodFrame*, Atom);

  // castns: (Effect, Atom) -> (Effect, Namespace)
  static Namespace* do_castns(MethodFrame*, Atom);

  // cknull: (Effect, Atom) -> (Effect, Atom~)
  static Atom do_cknull(MethodFrame*, Atom);

  // cknullobject: (Effect, ScriptObject) -> (Effect, ScriptObject~)
  static ScriptObject* do_cknullobject(MethodFrame*, ScriptObject*);

  // cktimeout: (Effect, Env) -> (Effect, Boolean)
  static BoolKind do_cktimeout(MethodFrame*, MethodEnv*);

  // abc_hasnext: (Effect, Atom, Int) -> (Effect, Int)
  static int32_t do_abc_hasnext(MethodFrame*, Atom, int32_t);

  // never: () -> Bot
  static void do_never(MethodFrame*);

  // call: (Effect, Atom, Atom, Atom) -> (Effect, Atom)
  static Atom do_call(MethodFrame*, Atom, int, Atom*);

  // construct: (Effect, Atom, Atom, Atom) -> (Effect, Atom~)
  static Atom do_construct(MethodFrame*, Atom, int, Atom*);

  // constructsuper: (Effect, Env, Atom~, Atom) -> (Effect, Bot)
  static void do_constructsuper(MethodFrame*, MethodEnv*, int, Atom*);

  // loadenv_namespace: (Ord, Namespace~) -> Env
  static MethodEnv* do_loadenv_namespace(MethodFrame*, int, Namespace*);

  // loadenv_boolean: (Ord, Boolean) -> Env
  static MethodEnv* do_loadenv_boolean(MethodFrame*, int, BoolKind);

  // loadenv_number: (Ord, Number~) -> Env
  static MethodEnv* do_loadenv_number(MethodFrame*, int, double);

  // loadenv_string: (Ord, String~) -> Env
  static MethodEnv* do_loadenv_string(MethodFrame*, int, String*);

  // loadenv_interface: (Method, ScriptObject~) -> Env
  static MethodEnv* do_loadenv_interface(MethodFrame*, MethodInfo*, ScriptObject*);

  // loadenv: (Ord, ScriptObject~) -> Env
  static MethodEnv* do_loadenv(MethodFrame*, int, ScriptObject*);

  // loadenv_atom: (Ord, Atom~) -> Env
  static MethodEnv* do_loadenv_atom(MethodFrame*, int, Atom);

  // loadinitenv: ScriptObject~ -> Env
  static MethodEnv* do_loadinitenv(MethodFrame*, ScriptObject*);

  // loadsuperinitenv: Env -> Env
  static MethodEnv* do_loadsuperinitenv(MethodFrame*, MethodEnv*);

  // loadenv_env: (Ord, Env) -> Env
  static MethodEnv* do_loadenv_env(MethodFrame*, int, MethodEnv*);

  // newobject: (Effect, Atom) -> (Effect, ScriptObject~)
  static ScriptObject* do_newobject(MethodFrame*, int, Atom*);

  // newarray: (Effect, Atom) -> (Effect, Array~)
  static ArrayObject* do_newarray(MethodFrame*, int, Atom*);

  // applytype: (Effect, Atom) -> (Effect, Atom)
  static Atom do_applytype(MethodFrame*, int, Atom*);

  // newinstance: Class~ -> ScriptObject~
  static ScriptObject* do_newinstance(MethodFrame*, ClassClosure*);

  // abc_convert_s: (Effect, Atom) -> (Effect, String~)
  static String* do_abc_convert_s(MethodFrame*, Atom);

  // abc_esc_xelem: (Effect, Atom) -> (Effect, String~)
  static String* do_abc_esc_xelem(MethodFrame*, Atom);

  // abc_esc_xattr: (Effect, Atom) -> (Effect, String~)
  static String* do_abc_esc_xattr(MethodFrame*, Atom);

  // abc_typeof: Atom -> String~
  static String* do_abc_typeof(MethodFrame*, Atom);

  // ckfilter: Atom~ -> Atom~
  static Atom do_ckfilter(MethodFrame*, Atom);

  // abc_add: (Effect, Atom, Atom) -> (Effect, Atom)
  static Atom do_abc_add(MethodFrame*, Atom, Atom);

  // addd: (Number, Number) -> Number
  static double do_addd(MethodFrame*, double, double);

  // concat_strings: (String, String) -> String~
  static String* do_concat_strings(MethodFrame*, String*, String*);

  // abc_nextname: (Effect, Atom, Int) -> (Effect, Atom)
  static Atom do_abc_nextname(MethodFrame*, Atom, int32_t);

  // abc_nextvalue: (Effect, Atom, Int) -> (Effect, Atom)
  static Atom do_abc_nextvalue(MethodFrame*, Atom, int32_t);

  // lessthan: (Atom, Atom) -> Boolean
  static BoolKind do_lessthan(MethodFrame*, Atom, Atom);

  // lessequals: (Atom, Atom) -> Boolean
  static BoolKind do_lessequals(MethodFrame*, Atom, Atom);

  // greaterthan: (Atom, Atom) -> Boolean
  static BoolKind do_greaterthan(MethodFrame*, Atom, Atom);

  // greaterequals: (Atom, Atom) -> Boolean
  static BoolKind do_greaterequals(MethodFrame*, Atom, Atom);

  // abc_instanceof: (Effect, Atom, Atom) -> (Effect, Boolean)
  static BoolKind do_abc_instanceof(MethodFrame*, Atom, Atom);

  // abc_istype: (Effect, Traits, Atom) -> (Effect, Boolean)
  static BoolKind do_abc_istype(MethodFrame*, Traits*, Atom);

  // abc_istypelate: (Effect, Atom, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_istypelate(MethodFrame*, Atom, Atom);

  // abc_astype: (Traits, Atom) -> Atom
  static Atom do_abc_astype(MethodFrame*, Traits*, Atom);

  // abc_astypelate: (Effect, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_astypelate(MethodFrame*, Atom, Atom);

  // abc_in: (Effect, Atom, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_in(MethodFrame*, Atom, Atom);

  // divd: (Number, Number) -> Number
  static double do_divd(MethodFrame*, double, double);

  // modulo: (Number, Number) -> Number
  static double do_modulo(MethodFrame*, double, double);

  // subd: (Number, Number) -> Number
  static double do_subd(MethodFrame*, double, double);

  // muld: (Number, Number) -> Number
  static double do_muld(MethodFrame*, double, double);

  // addi: (Int, Int) -> Int
  static int32_t do_addi(MethodFrame*, int32_t, int32_t);

  // subi: (Int, Int) -> Int
  static int32_t do_subi(MethodFrame*, int32_t, int32_t);

  // muli: (Int, Int) -> Int
  static int32_t do_muli(MethodFrame*, int32_t, int32_t);

  // ori: (Int, Int) -> Int
  static int32_t do_ori(MethodFrame*, int32_t, int32_t);

  // andi: (Int, Int) -> Int
  static int32_t do_andi(MethodFrame*, int32_t, int32_t);

  // xori: (Int, Int) -> Int
  static int32_t do_xori(MethodFrame*, int32_t, int32_t);

  // lshi: (Int, Int) -> Int
  static int32_t do_lshi(MethodFrame*, int32_t, int32_t);

  // rshi: (Int, Int) -> Int
  static int32_t do_rshi(MethodFrame*, int32_t, int32_t);

  // rshui: (Int, Int) -> Uint
  static uint32_t do_rshui(MethodFrame*, int32_t, int32_t);

  // noti: Int -> Int
  static int32_t do_noti(MethodFrame*, int32_t);

  // negi: Int -> Int
  static int32_t do_negi(MethodFrame*, int32_t);

  // negd: Number -> Number
  static double do_negd(MethodFrame*, double);

  // not: Boolean -> Boolean
  static BoolKind do_not(MethodFrame*, BoolKind);

  // newactivation: (Effect, Env) -> (Effect, ScriptObject~)
  static ScriptObject* do_newactivation(MethodFrame*, MethodEnv*);

  // abc_finddef: (Effect, Name, Env) -> (Effect, ScriptObject~)
  static ScriptObject* do_abc_finddef(MethodFrame*, const Multiname*, MethodEnv*);

  // abc_findpropstrict: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropstrict(MethodFrame*, const Multiname*, MethodEnv*, int, int, Atom*);

  // abc_findpropstrictx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropstrictx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // abc_findpropstrictns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropstrictns(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // abc_findpropstrictnsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropstrictnsx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // abc_findproperty: (Effect, Name, Env, Ord, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findproperty(MethodFrame*, const Multiname*, MethodEnv*, int, int, Atom*);

  // abc_findpropertyx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropertyx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // abc_findpropertyns: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropertyns(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // abc_findpropertynsx: (Effect, Name, Env, Ord, Atom, Atom~) -> (Effect, Atom~)
  static Atom do_abc_findpropertynsx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*);

  // newclass: (Effect, Traits~, Class, Atom~) -> (Effect, Class~)
  static ClassClosure* do_newclass(MethodFrame*, Traits*, ClassClosure*, int, Atom*);

  // newfunction: (Effect, Method, Atom~) -> (Effect, Function~)
  static ClassClosure* do_newfunction(MethodFrame*, MethodInfo*, int, Atom*);

  // abc_getsuper: (Effect, Name, Atom~) -> (Effect, Atom)
  static Atom do_abc_getsuper(MethodFrame*, const Multiname*, Atom);

  // abc_getsuperx: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getsuperx(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_getsuperns: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getsuperns(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_getsupernsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getsupernsx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_getdescendants: (Effect, Name, Atom~) -> (Effect, Atom)
  static Atom do_abc_getdescendants(MethodFrame*, const Multiname*, Atom);

  // abc_getdescendantsx: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getdescendantsx(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_getdescendantsns: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getdescendantsns(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_getdescendantsnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getdescendantsnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_callprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callprop(MethodFrame*, const Multiname*, int, Atom*);

  // abc_callpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callpropx(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callpropns(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callpropnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*);

  // abc_callproplex: (Effect, Name, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callproplex(MethodFrame*, const Multiname*, int, Atom*);

  // abc_callproplexx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callproplexx(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callproplexns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callproplexns(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callproplexnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callproplexnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*);

  // abc_constructprop: (Effect, Name, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_constructprop(MethodFrame*, const Multiname*, int, Atom*);

  // abc_constructpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_constructpropx(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_constructpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_constructpropns(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_constructpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_constructpropnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*);

  // abc_callsuper: (Effect, Name, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callsuper(MethodFrame*, const Multiname*, int, Atom*);

  // abc_callsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callsuperx(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callsuperns(MethodFrame*, const Multiname*, Atom, int, Atom*);

  // abc_callsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Atom)
  static Atom do_abc_callsupernsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*);

  // newcatch: (Effect, Traits~) -> (Effect, Atom~)
  static Atom do_newcatch(MethodFrame*, Traits*);

  // slottype: (ScriptObject~, Ord) -> Traits
  static Traits* do_slottype(MethodFrame*, ScriptObject*, int);

  // getouterscope: (Ord, Env) -> Atom~
  static Atom do_getouterscope(MethodFrame*, int, MethodEnv*);

  // deopt_finish: Effect -> Effect
  static void do_deopt_finish(MethodFrame*);

  // debugline: (Effect, Int) -> Effect
  static void do_debugline(MethodFrame*, int32_t);

  // debugfile: (Effect, String) -> Effect
  static void do_debugfile(MethodFrame*, String*);

  // string2atom: String -> Atom
  static Atom do_string2atom(MethodFrame*, String*);

  // double2atom: Number -> Atom~
  static Atom do_double2atom(MethodFrame*, double);

  // int2atom: Int -> Atom~
  static Atom do_int2atom(MethodFrame*, int32_t);

  // uint2atom: Uint -> Atom~
  static Atom do_uint2atom(MethodFrame*, uint32_t);

  // scriptobject2atom: ScriptObject -> Atom
  static Atom do_scriptobject2atom(MethodFrame*, ScriptObject*);

  // bool2atom: Boolean -> Atom~
  static Atom do_bool2atom(MethodFrame*, BoolKind);

  // ns2atom: Namespace -> Atom
  static Atom do_ns2atom(MethodFrame*, Namespace*);

  // atom2bool: Atom~ -> Boolean
  static BoolKind do_atom2bool(MethodFrame*, Atom);

  // atom2double: Atom -> Number
  static double do_atom2double(MethodFrame*, Atom);

  // atom2string: Atom -> String
  static String* do_atom2string(MethodFrame*, Atom);

  // atom2int: Atom -> Int
  static int32_t do_atom2int(MethodFrame*, Atom);

  // atom2uint: Atom -> Uint
  static uint32_t do_atom2uint(MethodFrame*, Atom);

  // atom2scriptobject: Atom -> ScriptObject
  static ScriptObject* do_atom2scriptobject(MethodFrame*, Atom);

  // atom2ns: Atom -> Namespace
  static Namespace* do_atom2ns(MethodFrame*, Atom);

  // i2d: Int -> Number
  static double do_i2d(MethodFrame*, int32_t);

  // u2d: Uint -> Number
  static double do_u2d(MethodFrame*, uint32_t);

  // d2i: Number -> Int
  static int32_t do_d2i(MethodFrame*, double);

  // d2u: Number -> Uint
  static uint32_t do_d2u(MethodFrame*, double);

  // toslot: (ScriptObject, Name) -> Ord
  static int do_toslot(MethodFrame*, ScriptObject*, const Multiname*);

  // toprimitive: (Effect, Atom) -> (Effect, Atom)
  static Atom do_toprimitive(MethodFrame*, Atom);

  // eqi: (Int, Int) -> Boolean
  static BoolKind do_eqi(MethodFrame*, int32_t, int32_t);

  // lti: (Int, Int) -> Boolean
  static BoolKind do_lti(MethodFrame*, int32_t, int32_t);

  // lei: (Int, Int) -> Boolean
  static BoolKind do_lei(MethodFrame*, int32_t, int32_t);

  // gti: (Int, Int) -> Boolean
  static BoolKind do_gti(MethodFrame*, int32_t, int32_t);

  // gei: (Int, Int) -> Boolean
  static BoolKind do_gei(MethodFrame*, int32_t, int32_t);

  // eqd: (Number, Number) -> Boolean
  static BoolKind do_eqd(MethodFrame*, double, double);

  // ltd: (Number, Number) -> Boolean
  static BoolKind do_ltd(MethodFrame*, double, double);

  // led: (Number, Number) -> Boolean
  static BoolKind do_led(MethodFrame*, double, double);

  // gtd: (Number, Number) -> Boolean
  static BoolKind do_gtd(MethodFrame*, double, double);

  // ged: (Number, Number) -> Boolean
  static BoolKind do_ged(MethodFrame*, double, double);

  // equi: (Uint, Uint) -> Boolean
  static BoolKind do_equi(MethodFrame*, uint32_t, uint32_t);

  // ltui: (Uint, Uint) -> Boolean
  static BoolKind do_ltui(MethodFrame*, uint32_t, uint32_t);

  // leui: (Uint, Uint) -> Boolean
  static BoolKind do_leui(MethodFrame*, uint32_t, uint32_t);

  // gtui: (Uint, Uint) -> Boolean
  static BoolKind do_gtui(MethodFrame*, uint32_t, uint32_t);

  // geui: (Uint, Uint) -> Boolean
  static BoolKind do_geui(MethodFrame*, uint32_t, uint32_t);

  // eqb: (Boolean, Boolean) -> Boolean
  static BoolKind do_eqb(MethodFrame*, BoolKind, BoolKind);

  // doubletoint32: Number -> Int
  static int32_t do_doubletoint32(MethodFrame*, double);

  // i2u: Int -> Uint
  static uint32_t do_i2u(MethodFrame*, int32_t);

  // u2i: Uint -> Int
  static int32_t do_u2i(MethodFrame*, uint32_t);

  // abc_dxnslate: (Effect, Atom) -> (Effect, Bot)
  static void do_abc_dxnslate(MethodFrame*, Atom);

  // abc_dxns: (Effect, String~) -> (Effect, Bot)
  static void do_abc_dxns(MethodFrame*, String*);

  // li8: (Effect, Int) -> (Effect, Int)
  static int32_t do_li8(MethodFrame*, int32_t);

  // li16: (Effect, Int) -> (Effect, Int)
  static int32_t do_li16(MethodFrame*, int32_t);

  // li32: (Effect, Int) -> (Effect, Int)
  static int32_t do_li32(MethodFrame*, int32_t);

  // lf32: (Effect, Int) -> (Effect, Number)
  static double do_lf32(MethodFrame*, int32_t);

  // lf64: (Effect, Int) -> (Effect, Number)
  static double do_lf64(MethodFrame*, int32_t);

  // si8: (Effect, Int, Int) -> (Effect, Bot)
  static void do_si8(MethodFrame*, int32_t, int32_t);

  // si16: (Effect, Int, Int) -> (Effect, Bot)
  static void do_si16(MethodFrame*, int32_t, int32_t);

  // si32: (Effect, Int, Int) -> (Effect, Bot)
  static void do_si32(MethodFrame*, int32_t, int32_t);

  // sf32: (Effect, Number, Int) -> (Effect, Bot)
  static void do_sf32(MethodFrame*, double, int32_t);

  // sf64: (Effect, Number, Int) -> (Effect, Bot)
  static void do_sf64(MethodFrame*, double, int32_t);

  // abc_equals: (Effect, Atom, Atom) -> (Effect, Boolean)
  static BoolKind do_abc_equals(MethodFrame*, Atom, Atom);

  // eqp: (ScriptObject, ScriptObject) -> Boolean
  static BoolKind do_eqp(MethodFrame*, ScriptObject*, ScriptObject*);

  // eqs: (String, String) -> Boolean
  static BoolKind do_eqs(MethodFrame*, String*, String*);

  // abc_strictequals: (Atom, Atom) -> Boolean
  static BoolKind do_abc_strictequals(MethodFrame*, Atom, Atom);

  // abc_setsuper: (Effect, Name, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setsuper(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_setsuperx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setsuperx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_setsuperns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setsuperns(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_setsupernsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setsupernsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom);

  // abc_deleteprop: (Effect, Name, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_deleteprop(MethodFrame*, const Multiname*, Atom);

  // abc_deletepropx: (Effect, Name, Atom, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_deletepropx(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_deletepropns: (Effect, Name, Atom, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_deletepropns(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_deletepropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Boolean)
  static BoolKind do_abc_deletepropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_getprop: (Effect, Name, Atom~) -> (Effect, Atom)
  static Atom do_abc_getprop(MethodFrame*, const Multiname*, Atom);

  // abc_getpropx: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getpropx(MethodFrame*, const Multiname*, Atom, Atom);

  // getpropertylate_u: (Effect, Uint, Atom~) -> (Effect, Atom)
  static Atom do_getpropertylate_u(MethodFrame*, uint32_t, Atom);

  // getpropertylate_i: (Effect, Int, Atom~) -> (Effect, Atom)
  static Atom do_getpropertylate_i(MethodFrame*, int32_t, Atom);

  // getpropertylate_d: (Effect, Number, Atom~) -> (Effect, Atom)
  static Atom do_getpropertylate_d(MethodFrame*, double, Atom);

  // array_get_u: (Effect, Uint, Array~) -> (Effect, Atom)
  static Atom do_array_get_u(MethodFrame*, uint32_t, ArrayObject*);

  // array_get_i: (Effect, Int, Array~) -> (Effect, Atom)
  static Atom do_array_get_i(MethodFrame*, int32_t, ArrayObject*);

  // array_get_d: (Effect, Number, Array~) -> (Effect, Atom)
  static Atom do_array_get_d(MethodFrame*, double, ArrayObject*);

  // vectorint_get_u: (Effect, Uint, VectorInt~) -> (Effect, Int)
  static int32_t do_vectorint_get_u(MethodFrame*, uint32_t, IntVectorObject*);

  // vectorint_get_i: (Effect, Int, VectorInt~) -> (Effect, Int)
  static int32_t do_vectorint_get_i(MethodFrame*, int32_t, IntVectorObject*);

  // vectorint_get_d: (Effect, Number, VectorInt~) -> (Effect, Int)
  static int32_t do_vectorint_get_d(MethodFrame*, double, IntVectorObject*);

  // vectoruint_get_u: (Effect, Uint, VectorUInt~) -> (Effect, Uint)
  static uint32_t do_vectoruint_get_u(MethodFrame*, uint32_t, UIntVectorObject*);

  // vectoruint_get_i: (Effect, Int, VectorUInt~) -> (Effect, Uint)
  static uint32_t do_vectoruint_get_i(MethodFrame*, int32_t, UIntVectorObject*);

  // vectoruint_get_d: (Effect, Number, VectorUInt~) -> (Effect, Uint)
  static uint32_t do_vectoruint_get_d(MethodFrame*, double, UIntVectorObject*);

  // vectordouble_get_u: (Effect, Uint, VectorDouble~) -> (Effect, Number)
  static double do_vectordouble_get_u(MethodFrame*, uint32_t, DoubleVectorObject*);

  // vectordouble_get_i: (Effect, Int, VectorDouble~) -> (Effect, Number)
  static double do_vectordouble_get_i(MethodFrame*, int32_t, DoubleVectorObject*);

  // vectordouble_get_d: (Effect, Number, VectorDouble~) -> (Effect, Number)
  static double do_vectordouble_get_d(MethodFrame*, double, DoubleVectorObject*);

  // abc_getpropns: (Effect, Name, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getpropns(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_getpropnsx: (Effect, Name, Atom, Atom, Atom~) -> (Effect, Atom)
  static Atom do_abc_getpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_setprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setprop(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_setpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setpropx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // setpropertylate_u: (Effect, Uint, Atom~, Atom) -> (Effect, Bot)
  static void do_setpropertylate_u(MethodFrame*, uint32_t, Atom, Atom);

  // setpropertylate_i: (Effect, Int, Atom~, Atom) -> (Effect, Bot)
  static void do_setpropertylate_i(MethodFrame*, int32_t, Atom, Atom);

  // setpropertylate_d: (Effect, Number, Atom~, Atom) -> (Effect, Bot)
  static void do_setpropertylate_d(MethodFrame*, double, Atom, Atom);

  // array_set_u: (Effect, Uint, Array~, Atom) -> (Effect, Bot)
  static void do_array_set_u(MethodFrame*, uint32_t, ArrayObject*, Atom);

  // array_set_i: (Effect, Int, Array~, Atom) -> (Effect, Bot)
  static void do_array_set_i(MethodFrame*, int32_t, ArrayObject*, Atom);

  // array_set_d: (Effect, Number, Array~, Atom) -> (Effect, Bot)
  static void do_array_set_d(MethodFrame*, double, ArrayObject*, Atom);

  // vectorint_set_u: (Effect, Uint, VectorInt~, Int) -> (Effect, Bot)
  static void do_vectorint_set_u(MethodFrame*, uint32_t, IntVectorObject*, int32_t);

  // vectorint_set_i: (Effect, Int, VectorInt~, Int) -> (Effect, Bot)
  static void do_vectorint_set_i(MethodFrame*, int32_t, IntVectorObject*, int32_t);

  // vectorint_set_d: (Effect, Number, VectorInt~, Int) -> (Effect, Bot)
  static void do_vectorint_set_d(MethodFrame*, double, IntVectorObject*, int32_t);

  // vectoruint_set_u: (Effect, Uint, VectorUInt~, Uint) -> (Effect, Bot)
  static void do_vectoruint_set_u(MethodFrame*, uint32_t, UIntVectorObject*, uint32_t);

  // vectoruint_set_i: (Effect, Int, VectorUInt~, Uint) -> (Effect, Bot)
  static void do_vectoruint_set_i(MethodFrame*, int32_t, UIntVectorObject*, uint32_t);

  // vectoruint_set_d: (Effect, Number, VectorUInt~, Uint) -> (Effect, Bot)
  static void do_vectoruint_set_d(MethodFrame*, double, UIntVectorObject*, uint32_t);

  // vectordouble_set_u: (Effect, Uint, VectorDouble~, Number) -> (Effect, Bot)
  static void do_vectordouble_set_u(MethodFrame*, uint32_t, DoubleVectorObject*, double);

  // vectordouble_set_i: (Effect, Int, VectorDouble~, Number) -> (Effect, Bot)
  static void do_vectordouble_set_i(MethodFrame*, int32_t, DoubleVectorObject*, double);

  // vectordouble_set_d: (Effect, Number, VectorDouble~, Number) -> (Effect, Bot)
  static void do_vectordouble_set_d(MethodFrame*, double, DoubleVectorObject*, double);

  // abc_setpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setpropns(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_setpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_setpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom);

  // abc_initprop: (Effect, Name, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_initprop(MethodFrame*, const Multiname*, Atom, Atom);

  // abc_initpropx: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_initpropx(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_initpropns: (Effect, Name, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_initpropns(MethodFrame*, const Multiname*, Atom, Atom, Atom);

  // abc_initpropnsx: (Effect, Name, Atom, Atom, Atom~, Atom) -> (Effect, Bot)
  static void do_abc_initpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom);

};

/* One-line implementations, for copy/paste convenience:
  void Stubs::do_throw(MethodFrame*, Atom) { assert(false && "throw not implemented"); }
  Atom Stubs::do_coerce(MethodFrame*, Traits*, Atom) { assert(false && "coerce not implemented"); return 0; }
  ScriptObject* Stubs::do_cast(MethodFrame*, Traits*, Atom) { assert(false && "cast not implemented"); return 0; }
  Atom Stubs::do_castobject(MethodFrame*, Atom) { assert(false && "castobject not implemented"); return 0; }
  double Stubs::do_tonumber(MethodFrame*, Atom) { assert(false && "tonumber not implemented"); return 0; }
  int32_t Stubs::do_toint(MethodFrame*, Atom) { assert(false && "toint not implemented"); return 0; }
  uint32_t Stubs::do_touint(MethodFrame*, Atom) { assert(false && "touint not implemented"); return 0; }
  BoolKind Stubs::do_toboolean(MethodFrame*, Atom) { assert(false && "toboolean not implemented"); return 0; }
  BoolKind Stubs::do_d2b(MethodFrame*, double) { assert(false && "d2b not implemented"); return 0; }
  String* Stubs::do_caststring(MethodFrame*, Atom) { assert(false && "caststring not implemented"); return 0; }
  Namespace* Stubs::do_castns(MethodFrame*, Atom) { assert(false && "castns not implemented"); return 0; }
  Atom Stubs::do_cknull(MethodFrame*, Atom) { assert(false && "cknull not implemented"); return 0; }
  ScriptObject* Stubs::do_cknullobject(MethodFrame*, ScriptObject*) { assert(false && "cknullobject not implemented"); return 0; }
  BoolKind Stubs::do_cktimeout(MethodFrame*, MethodEnv*) { assert(false && "cktimeout not implemented"); return 0; }
  int32_t Stubs::do_abc_hasnext(MethodFrame*, Atom, int32_t) { assert(false && "abc_hasnext not implemented"); return 0; }
  void Stubs::do_never(MethodFrame*) { assert(false && "never not implemented"); }
  Atom Stubs::do_call(MethodFrame*, Atom, int, Atom*) { assert(false && "call not implemented"); return 0; }
  Atom Stubs::do_construct(MethodFrame*, Atom, int, Atom*) { assert(false && "construct not implemented"); return 0; }
  void Stubs::do_constructsuper(MethodFrame*, MethodEnv*, int, Atom*) { assert(false && "constructsuper not implemented"); }
  MethodEnv* Stubs::do_loadenv_namespace(MethodFrame*, int, Namespace*) { assert(false && "loadenv_namespace not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_boolean(MethodFrame*, int, BoolKind) { assert(false && "loadenv_boolean not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_number(MethodFrame*, int, double) { assert(false && "loadenv_number not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_string(MethodFrame*, int, String*) { assert(false && "loadenv_string not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_interface(MethodFrame*, MethodInfo*, ScriptObject*) { assert(false && "loadenv_interface not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv(MethodFrame*, int, ScriptObject*) { assert(false && "loadenv not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_atom(MethodFrame*, int, Atom) { assert(false && "loadenv_atom not implemented"); return 0; }
  MethodEnv* Stubs::do_loadinitenv(MethodFrame*, ScriptObject*) { assert(false && "loadinitenv not implemented"); return 0; }
  MethodEnv* Stubs::do_loadsuperinitenv(MethodFrame*, MethodEnv*) { assert(false && "loadsuperinitenv not implemented"); return 0; }
  MethodEnv* Stubs::do_loadenv_env(MethodFrame*, int, MethodEnv*) { assert(false && "loadenv_env not implemented"); return 0; }
  ScriptObject* Stubs::do_newobject(MethodFrame*, int, Atom*) { assert(false && "newobject not implemented"); return 0; }
  ArrayObject* Stubs::do_newarray(MethodFrame*, int, Atom*) { assert(false && "newarray not implemented"); return 0; }
  Atom Stubs::do_applytype(MethodFrame*, int, Atom*) { assert(false && "applytype not implemented"); return 0; }
  ScriptObject* Stubs::do_newinstance(MethodFrame*, ClassClosure*) { assert(false && "newinstance not implemented"); return 0; }
  String* Stubs::do_abc_convert_s(MethodFrame*, Atom) { assert(false && "abc_convert_s not implemented"); return 0; }
  String* Stubs::do_abc_esc_xelem(MethodFrame*, Atom) { assert(false && "abc_esc_xelem not implemented"); return 0; }
  String* Stubs::do_abc_esc_xattr(MethodFrame*, Atom) { assert(false && "abc_esc_xattr not implemented"); return 0; }
  String* Stubs::do_abc_typeof(MethodFrame*, Atom) { assert(false && "abc_typeof not implemented"); return 0; }
  Atom Stubs::do_ckfilter(MethodFrame*, Atom) { assert(false && "ckfilter not implemented"); return 0; }
  Atom Stubs::do_abc_add(MethodFrame*, Atom, Atom) { assert(false && "abc_add not implemented"); return 0; }
  double Stubs::do_addd(MethodFrame*, double, double) { assert(false && "addd not implemented"); return 0; }
  String* Stubs::do_concat_strings(MethodFrame*, String*, String*) { assert(false && "concat_strings not implemented"); return 0; }
  Atom Stubs::do_abc_nextname(MethodFrame*, Atom, int32_t) { assert(false && "abc_nextname not implemented"); return 0; }
  Atom Stubs::do_abc_nextvalue(MethodFrame*, Atom, int32_t) { assert(false && "abc_nextvalue not implemented"); return 0; }
  BoolKind Stubs::do_lessthan(MethodFrame*, Atom, Atom) { assert(false && "lessthan not implemented"); return 0; }
  BoolKind Stubs::do_lessequals(MethodFrame*, Atom, Atom) { assert(false && "lessequals not implemented"); return 0; }
  BoolKind Stubs::do_greaterthan(MethodFrame*, Atom, Atom) { assert(false && "greaterthan not implemented"); return 0; }
  BoolKind Stubs::do_greaterequals(MethodFrame*, Atom, Atom) { assert(false && "greaterequals not implemented"); return 0; }
  BoolKind Stubs::do_abc_instanceof(MethodFrame*, Atom, Atom) { assert(false && "abc_instanceof not implemented"); return 0; }
  BoolKind Stubs::do_abc_istype(MethodFrame*, Traits*, Atom) { assert(false && "abc_istype not implemented"); return 0; }
  BoolKind Stubs::do_abc_istypelate(MethodFrame*, Atom, Atom) { assert(false && "abc_istypelate not implemented"); return 0; }
  Atom Stubs::do_abc_astype(MethodFrame*, Traits*, Atom) { assert(false && "abc_astype not implemented"); return 0; }
  Atom Stubs::do_abc_astypelate(MethodFrame*, Atom, Atom) { assert(false && "abc_astypelate not implemented"); return 0; }
  BoolKind Stubs::do_abc_in(MethodFrame*, Atom, Atom) { assert(false && "abc_in not implemented"); return 0; }
  double Stubs::do_divd(MethodFrame*, double, double) { assert(false && "divd not implemented"); return 0; }
  double Stubs::do_modulo(MethodFrame*, double, double) { assert(false && "modulo not implemented"); return 0; }
  double Stubs::do_subd(MethodFrame*, double, double) { assert(false && "subd not implemented"); return 0; }
  double Stubs::do_muld(MethodFrame*, double, double) { assert(false && "muld not implemented"); return 0; }
  int32_t Stubs::do_addi(MethodFrame*, int32_t, int32_t) { assert(false && "addi not implemented"); return 0; }
  int32_t Stubs::do_subi(MethodFrame*, int32_t, int32_t) { assert(false && "subi not implemented"); return 0; }
  int32_t Stubs::do_muli(MethodFrame*, int32_t, int32_t) { assert(false && "muli not implemented"); return 0; }
  int32_t Stubs::do_ori(MethodFrame*, int32_t, int32_t) { assert(false && "ori not implemented"); return 0; }
  int32_t Stubs::do_andi(MethodFrame*, int32_t, int32_t) { assert(false && "andi not implemented"); return 0; }
  int32_t Stubs::do_xori(MethodFrame*, int32_t, int32_t) { assert(false && "xori not implemented"); return 0; }
  int32_t Stubs::do_lshi(MethodFrame*, int32_t, int32_t) { assert(false && "lshi not implemented"); return 0; }
  int32_t Stubs::do_rshi(MethodFrame*, int32_t, int32_t) { assert(false && "rshi not implemented"); return 0; }
  uint32_t Stubs::do_rshui(MethodFrame*, int32_t, int32_t) { assert(false && "rshui not implemented"); return 0; }
  int32_t Stubs::do_noti(MethodFrame*, int32_t) { assert(false && "noti not implemented"); return 0; }
  int32_t Stubs::do_negi(MethodFrame*, int32_t) { assert(false && "negi not implemented"); return 0; }
  double Stubs::do_negd(MethodFrame*, double) { assert(false && "negd not implemented"); return 0; }
  BoolKind Stubs::do_not(MethodFrame*, BoolKind) { assert(false && "not not implemented"); return 0; }
  ScriptObject* Stubs::do_newactivation(MethodFrame*, MethodEnv*) { assert(false && "newactivation not implemented"); return 0; }
  ScriptObject* Stubs::do_abc_finddef(MethodFrame*, const Multiname*, MethodEnv*) { assert(false && "abc_finddef not implemented"); return 0; }
  Atom Stubs::do_abc_findpropstrict(MethodFrame*, const Multiname*, MethodEnv*, int, int, Atom*) { assert(false && "abc_findpropstrict not implemented"); return 0; }
  Atom Stubs::do_abc_findpropstrictx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropstrictx not implemented"); return 0; }
  Atom Stubs::do_abc_findpropstrictns(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropstrictns not implemented"); return 0; }
  Atom Stubs::do_abc_findpropstrictnsx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropstrictnsx not implemented"); return 0; }
  Atom Stubs::do_abc_findproperty(MethodFrame*, const Multiname*, MethodEnv*, int, int, Atom*) { assert(false && "abc_findproperty not implemented"); return 0; }
  Atom Stubs::do_abc_findpropertyx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropertyx not implemented"); return 0; }
  Atom Stubs::do_abc_findpropertyns(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropertyns not implemented"); return 0; }
  Atom Stubs::do_abc_findpropertynsx(MethodFrame*, const Multiname*, MethodEnv*, int, Atom, int, Atom*) { assert(false && "abc_findpropertynsx not implemented"); return 0; }
  ClassClosure* Stubs::do_newclass(MethodFrame*, Traits*, ClassClosure*, int, Atom*) { assert(false && "newclass not implemented"); return 0; }
  ClassClosure* Stubs::do_newfunction(MethodFrame*, MethodInfo*, int, Atom*) { assert(false && "newfunction not implemented"); return 0; }
  Atom Stubs::do_abc_getsuper(MethodFrame*, const Multiname*, Atom) { assert(false && "abc_getsuper not implemented"); return 0; }
  Atom Stubs::do_abc_getsuperx(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getsuperx not implemented"); return 0; }
  Atom Stubs::do_abc_getsuperns(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getsuperns not implemented"); return 0; }
  Atom Stubs::do_abc_getsupernsx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_getsupernsx not implemented"); return 0; }
  Atom Stubs::do_abc_getdescendants(MethodFrame*, const Multiname*, Atom) { assert(false && "abc_getdescendants not implemented"); return 0; }
  Atom Stubs::do_abc_getdescendantsx(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getdescendantsx not implemented"); return 0; }
  Atom Stubs::do_abc_getdescendantsns(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getdescendantsns not implemented"); return 0; }
  Atom Stubs::do_abc_getdescendantsnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_getdescendantsnsx not implemented"); return 0; }
  Atom Stubs::do_abc_callprop(MethodFrame*, const Multiname*, int, Atom*) { assert(false && "abc_callprop not implemented"); return 0; }
  Atom Stubs::do_abc_callpropx(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callpropx not implemented"); return 0; }
  Atom Stubs::do_abc_callpropns(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callpropns not implemented"); return 0; }
  Atom Stubs::do_abc_callpropnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*) { assert(false && "abc_callpropnsx not implemented"); return 0; }
  Atom Stubs::do_abc_callproplex(MethodFrame*, const Multiname*, int, Atom*) { assert(false && "abc_callproplex not implemented"); return 0; }
  Atom Stubs::do_abc_callproplexx(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callproplexx not implemented"); return 0; }
  Atom Stubs::do_abc_callproplexns(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callproplexns not implemented"); return 0; }
  Atom Stubs::do_abc_callproplexnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*) { assert(false && "abc_callproplexnsx not implemented"); return 0; }
  Atom Stubs::do_abc_constructprop(MethodFrame*, const Multiname*, int, Atom*) { assert(false && "abc_constructprop not implemented"); return 0; }
  Atom Stubs::do_abc_constructpropx(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_constructpropx not implemented"); return 0; }
  Atom Stubs::do_abc_constructpropns(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_constructpropns not implemented"); return 0; }
  Atom Stubs::do_abc_constructpropnsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*) { assert(false && "abc_constructpropnsx not implemented"); return 0; }
  Atom Stubs::do_abc_callsuper(MethodFrame*, const Multiname*, int, Atom*) { assert(false && "abc_callsuper not implemented"); return 0; }
  Atom Stubs::do_abc_callsuperx(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callsuperx not implemented"); return 0; }
  Atom Stubs::do_abc_callsuperns(MethodFrame*, const Multiname*, Atom, int, Atom*) { assert(false && "abc_callsuperns not implemented"); return 0; }
  Atom Stubs::do_abc_callsupernsx(MethodFrame*, const Multiname*, Atom, Atom, int, Atom*) { assert(false && "abc_callsupernsx not implemented"); return 0; }
  Atom Stubs::do_newcatch(MethodFrame*, Traits*) { assert(false && "newcatch not implemented"); return 0; }
  Traits* Stubs::do_slottype(MethodFrame*, ScriptObject*, int) { assert(false && "slottype not implemented"); return 0; }
  Atom Stubs::do_getouterscope(MethodFrame*, int, MethodEnv*) { assert(false && "getouterscope not implemented"); return 0; }
  void Stubs::do_deopt_finish(MethodFrame*) { assert(false && "deopt_finish not implemented"); }
  void Stubs::do_debugline(MethodFrame*, int32_t) { assert(false && "debugline not implemented"); }
  void Stubs::do_debugfile(MethodFrame*, String*) { assert(false && "debugfile not implemented"); }
  Atom Stubs::do_string2atom(MethodFrame*, String*) { assert(false && "string2atom not implemented"); return 0; }
  Atom Stubs::do_double2atom(MethodFrame*, double) { assert(false && "double2atom not implemented"); return 0; }
  Atom Stubs::do_int2atom(MethodFrame*, int32_t) { assert(false && "int2atom not implemented"); return 0; }
  Atom Stubs::do_uint2atom(MethodFrame*, uint32_t) { assert(false && "uint2atom not implemented"); return 0; }
  Atom Stubs::do_scriptobject2atom(MethodFrame*, ScriptObject*) { assert(false && "scriptobject2atom not implemented"); return 0; }
  Atom Stubs::do_bool2atom(MethodFrame*, BoolKind) { assert(false && "bool2atom not implemented"); return 0; }
  Atom Stubs::do_ns2atom(MethodFrame*, Namespace*) { assert(false && "ns2atom not implemented"); return 0; }
  BoolKind Stubs::do_atom2bool(MethodFrame*, Atom) { assert(false && "atom2bool not implemented"); return 0; }
  double Stubs::do_atom2double(MethodFrame*, Atom) { assert(false && "atom2double not implemented"); return 0; }
  String* Stubs::do_atom2string(MethodFrame*, Atom) { assert(false && "atom2string not implemented"); return 0; }
  int32_t Stubs::do_atom2int(MethodFrame*, Atom) { assert(false && "atom2int not implemented"); return 0; }
  uint32_t Stubs::do_atom2uint(MethodFrame*, Atom) { assert(false && "atom2uint not implemented"); return 0; }
  ScriptObject* Stubs::do_atom2scriptobject(MethodFrame*, Atom) { assert(false && "atom2scriptobject not implemented"); return 0; }
  Namespace* Stubs::do_atom2ns(MethodFrame*, Atom) { assert(false && "atom2ns not implemented"); return 0; }
  double Stubs::do_i2d(MethodFrame*, int32_t) { assert(false && "i2d not implemented"); return 0; }
  double Stubs::do_u2d(MethodFrame*, uint32_t) { assert(false && "u2d not implemented"); return 0; }
  int32_t Stubs::do_d2i(MethodFrame*, double) { assert(false && "d2i not implemented"); return 0; }
  uint32_t Stubs::do_d2u(MethodFrame*, double) { assert(false && "d2u not implemented"); return 0; }
  int Stubs::do_toslot(MethodFrame*, ScriptObject*, const Multiname*) { assert(false && "toslot not implemented"); return 0; }
  Atom Stubs::do_toprimitive(MethodFrame*, Atom) { assert(false && "toprimitive not implemented"); return 0; }
  BoolKind Stubs::do_eqi(MethodFrame*, int32_t, int32_t) { assert(false && "eqi not implemented"); return 0; }
  BoolKind Stubs::do_lti(MethodFrame*, int32_t, int32_t) { assert(false && "lti not implemented"); return 0; }
  BoolKind Stubs::do_lei(MethodFrame*, int32_t, int32_t) { assert(false && "lei not implemented"); return 0; }
  BoolKind Stubs::do_gti(MethodFrame*, int32_t, int32_t) { assert(false && "gti not implemented"); return 0; }
  BoolKind Stubs::do_gei(MethodFrame*, int32_t, int32_t) { assert(false && "gei not implemented"); return 0; }
  BoolKind Stubs::do_eqd(MethodFrame*, double, double) { assert(false && "eqd not implemented"); return 0; }
  BoolKind Stubs::do_ltd(MethodFrame*, double, double) { assert(false && "ltd not implemented"); return 0; }
  BoolKind Stubs::do_led(MethodFrame*, double, double) { assert(false && "led not implemented"); return 0; }
  BoolKind Stubs::do_gtd(MethodFrame*, double, double) { assert(false && "gtd not implemented"); return 0; }
  BoolKind Stubs::do_ged(MethodFrame*, double, double) { assert(false && "ged not implemented"); return 0; }
  BoolKind Stubs::do_equi(MethodFrame*, uint32_t, uint32_t) { assert(false && "equi not implemented"); return 0; }
  BoolKind Stubs::do_ltui(MethodFrame*, uint32_t, uint32_t) { assert(false && "ltui not implemented"); return 0; }
  BoolKind Stubs::do_leui(MethodFrame*, uint32_t, uint32_t) { assert(false && "leui not implemented"); return 0; }
  BoolKind Stubs::do_gtui(MethodFrame*, uint32_t, uint32_t) { assert(false && "gtui not implemented"); return 0; }
  BoolKind Stubs::do_geui(MethodFrame*, uint32_t, uint32_t) { assert(false && "geui not implemented"); return 0; }
  BoolKind Stubs::do_eqb(MethodFrame*, BoolKind, BoolKind) { assert(false && "eqb not implemented"); return 0; }
  int32_t Stubs::do_doubletoint32(MethodFrame*, double) { assert(false && "doubletoint32 not implemented"); return 0; }
  uint32_t Stubs::do_i2u(MethodFrame*, int32_t) { assert(false && "i2u not implemented"); return 0; }
  int32_t Stubs::do_u2i(MethodFrame*, uint32_t) { assert(false && "u2i not implemented"); return 0; }
  void Stubs::do_abc_dxnslate(MethodFrame*, Atom) { assert(false && "abc_dxnslate not implemented"); }
  void Stubs::do_abc_dxns(MethodFrame*, String*) { assert(false && "abc_dxns not implemented"); }
  int32_t Stubs::do_li8(MethodFrame*, int32_t) { assert(false && "li8 not implemented"); return 0; }
  int32_t Stubs::do_li16(MethodFrame*, int32_t) { assert(false && "li16 not implemented"); return 0; }
  int32_t Stubs::do_li32(MethodFrame*, int32_t) { assert(false && "li32 not implemented"); return 0; }
  double Stubs::do_lf32(MethodFrame*, int32_t) { assert(false && "lf32 not implemented"); return 0; }
  double Stubs::do_lf64(MethodFrame*, int32_t) { assert(false && "lf64 not implemented"); return 0; }
  void Stubs::do_si8(MethodFrame*, int32_t, int32_t) { assert(false && "si8 not implemented"); }
  void Stubs::do_si16(MethodFrame*, int32_t, int32_t) { assert(false && "si16 not implemented"); }
  void Stubs::do_si32(MethodFrame*, int32_t, int32_t) { assert(false && "si32 not implemented"); }
  void Stubs::do_sf32(MethodFrame*, double, int32_t) { assert(false && "sf32 not implemented"); }
  void Stubs::do_sf64(MethodFrame*, double, int32_t) { assert(false && "sf64 not implemented"); }
  BoolKind Stubs::do_abc_equals(MethodFrame*, Atom, Atom) { assert(false && "abc_equals not implemented"); return 0; }
  BoolKind Stubs::do_eqp(MethodFrame*, ScriptObject*, ScriptObject*) { assert(false && "eqp not implemented"); return 0; }
  BoolKind Stubs::do_eqs(MethodFrame*, String*, String*) { assert(false && "eqs not implemented"); return 0; }
  BoolKind Stubs::do_abc_strictequals(MethodFrame*, Atom, Atom) { assert(false && "abc_strictequals not implemented"); return 0; }
  void Stubs::do_abc_setsuper(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_setsuper not implemented"); }
  void Stubs::do_abc_setsuperx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_setsuperx not implemented"); }
  void Stubs::do_abc_setsuperns(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_setsuperns not implemented"); }
  void Stubs::do_abc_setsupernsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom) { assert(false && "abc_setsupernsx not implemented"); }
  BoolKind Stubs::do_abc_deleteprop(MethodFrame*, const Multiname*, Atom) { assert(false && "abc_deleteprop not implemented"); return 0; }
  BoolKind Stubs::do_abc_deletepropx(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_deletepropx not implemented"); return 0; }
  BoolKind Stubs::do_abc_deletepropns(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_deletepropns not implemented"); return 0; }
  BoolKind Stubs::do_abc_deletepropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_deletepropnsx not implemented"); return 0; }
  Atom Stubs::do_abc_getprop(MethodFrame*, const Multiname*, Atom) { assert(false && "abc_getprop not implemented"); return 0; }
  Atom Stubs::do_abc_getpropx(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getpropx not implemented"); return 0; }
  Atom Stubs::do_getpropertylate_u(MethodFrame*, uint32_t, Atom) { assert(false && "getpropertylate_u not implemented"); return 0; }
  Atom Stubs::do_getpropertylate_i(MethodFrame*, int32_t, Atom) { assert(false && "getpropertylate_i not implemented"); return 0; }
  Atom Stubs::do_getpropertylate_d(MethodFrame*, double, Atom) { assert(false && "getpropertylate_d not implemented"); return 0; }
  Atom Stubs::do_array_get_u(MethodFrame*, uint32_t, ArrayObject*) { assert(false && "array_get_u not implemented"); return 0; }
  Atom Stubs::do_array_get_i(MethodFrame*, int32_t, ArrayObject*) { assert(false && "array_get_i not implemented"); return 0; }
  Atom Stubs::do_array_get_d(MethodFrame*, double, ArrayObject*) { assert(false && "array_get_d not implemented"); return 0; }
  int32_t Stubs::do_vectorint_get_u(MethodFrame*, uint32_t, IntVectorObject*) { assert(false && "vectorint_get_u not implemented"); return 0; }
  int32_t Stubs::do_vectorint_get_i(MethodFrame*, int32_t, IntVectorObject*) { assert(false && "vectorint_get_i not implemented"); return 0; }
  int32_t Stubs::do_vectorint_get_d(MethodFrame*, double, IntVectorObject*) { assert(false && "vectorint_get_d not implemented"); return 0; }
  uint32_t Stubs::do_vectoruint_get_u(MethodFrame*, uint32_t, UIntVectorObject*) { assert(false && "vectoruint_get_u not implemented"); return 0; }
  uint32_t Stubs::do_vectoruint_get_i(MethodFrame*, int32_t, UIntVectorObject*) { assert(false && "vectoruint_get_i not implemented"); return 0; }
  uint32_t Stubs::do_vectoruint_get_d(MethodFrame*, double, UIntVectorObject*) { assert(false && "vectoruint_get_d not implemented"); return 0; }
  double Stubs::do_vectordouble_get_u(MethodFrame*, uint32_t, DoubleVectorObject*) { assert(false && "vectordouble_get_u not implemented"); return 0; }
  double Stubs::do_vectordouble_get_i(MethodFrame*, int32_t, DoubleVectorObject*) { assert(false && "vectordouble_get_i not implemented"); return 0; }
  double Stubs::do_vectordouble_get_d(MethodFrame*, double, DoubleVectorObject*) { assert(false && "vectordouble_get_d not implemented"); return 0; }
  Atom Stubs::do_abc_getpropns(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_getpropns not implemented"); return 0; }
  Atom Stubs::do_abc_getpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_getpropnsx not implemented"); return 0; }
  void Stubs::do_abc_setprop(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_setprop not implemented"); }
  void Stubs::do_abc_setpropx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_setpropx not implemented"); }
  void Stubs::do_setpropertylate_u(MethodFrame*, uint32_t, Atom, Atom) { assert(false && "setpropertylate_u not implemented"); }
  void Stubs::do_setpropertylate_i(MethodFrame*, int32_t, Atom, Atom) { assert(false && "setpropertylate_i not implemented"); }
  void Stubs::do_setpropertylate_d(MethodFrame*, double, Atom, Atom) { assert(false && "setpropertylate_d not implemented"); }
  void Stubs::do_array_set_u(MethodFrame*, uint32_t, ArrayObject*, Atom) { assert(false && "array_set_u not implemented"); }
  void Stubs::do_array_set_i(MethodFrame*, int32_t, ArrayObject*, Atom) { assert(false && "array_set_i not implemented"); }
  void Stubs::do_array_set_d(MethodFrame*, double, ArrayObject*, Atom) { assert(false && "array_set_d not implemented"); }
  void Stubs::do_vectorint_set_u(MethodFrame*, uint32_t, IntVectorObject*, int32_t) { assert(false && "vectorint_set_u not implemented"); }
  void Stubs::do_vectorint_set_i(MethodFrame*, int32_t, IntVectorObject*, int32_t) { assert(false && "vectorint_set_i not implemented"); }
  void Stubs::do_vectorint_set_d(MethodFrame*, double, IntVectorObject*, int32_t) { assert(false && "vectorint_set_d not implemented"); }
  void Stubs::do_vectoruint_set_u(MethodFrame*, uint32_t, UIntVectorObject*, uint32_t) { assert(false && "vectoruint_set_u not implemented"); }
  void Stubs::do_vectoruint_set_i(MethodFrame*, int32_t, UIntVectorObject*, uint32_t) { assert(false && "vectoruint_set_i not implemented"); }
  void Stubs::do_vectoruint_set_d(MethodFrame*, double, UIntVectorObject*, uint32_t) { assert(false && "vectoruint_set_d not implemented"); }
  void Stubs::do_vectordouble_set_u(MethodFrame*, uint32_t, DoubleVectorObject*, double) { assert(false && "vectordouble_set_u not implemented"); }
  void Stubs::do_vectordouble_set_i(MethodFrame*, int32_t, DoubleVectorObject*, double) { assert(false && "vectordouble_set_i not implemented"); }
  void Stubs::do_vectordouble_set_d(MethodFrame*, double, DoubleVectorObject*, double) { assert(false && "vectordouble_set_d not implemented"); }
  void Stubs::do_abc_setpropns(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_setpropns not implemented"); }
  void Stubs::do_abc_setpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom) { assert(false && "abc_setpropnsx not implemented"); }
  void Stubs::do_abc_initprop(MethodFrame*, const Multiname*, Atom, Atom) { assert(false && "abc_initprop not implemented"); }
  void Stubs::do_abc_initpropx(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_initpropx not implemented"); }
  void Stubs::do_abc_initpropns(MethodFrame*, const Multiname*, Atom, Atom, Atom) { assert(false && "abc_initpropns not implemented"); }
  void Stubs::do_abc_initpropnsx(MethodFrame*, const Multiname*, Atom, Atom, Atom, Atom) { assert(false && "abc_initpropnsx not implemented"); }
*/
}
