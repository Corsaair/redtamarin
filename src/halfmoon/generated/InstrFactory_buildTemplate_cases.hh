///
/// generated by templates.py -- do not edit
///

  case HR_abc_increment: {
/***
abc_increment: (effect0:Effect, x:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (data1:Number) = addd(data0, 1)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_increment, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    BinaryExpr* addd1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_addd, data0, tb.doubleConst(1)));
    Def* data1 = addd1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_decrement: {
/***
abc_decrement: (effect0:Effect, x:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (data1:Number) = subd(data0, 1)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_decrement, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    BinaryExpr* subd1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_subd, data0, tb.doubleConst(1)));
    Def* data1 = subd1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_increment_i: {
/***
abc_increment_i: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = addi(data0, 1)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_increment_i, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    BinaryExpr* addi1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_addi, data0, tb.intConst(1)));
    Def* data1 = addi1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_decrement_i: {
/***
abc_decrement_i: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = subi(data0, 1)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_decrement_i, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    BinaryExpr* subi1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_subi, data0, tb.intConst(1)));
    Def* data1 = subi1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_not: {
/***
abc_not: (effect0:Effect, x:Atom) -> (Effect, Boolean)
  (data0:Boolean) = toboolean(x)
  (data1:Boolean) = not(data0)
  () = return(effect0, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_not, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryExpr* toboolean0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_toboolean, x));
    Def* data0 = toboolean0->value_out(); (void)data0;

    UnaryExpr* not1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_not, data0));
    Def* data1 = not1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect0, data1));

    break;
  }

  case HR_abc_negate: {
/***
abc_negate: (effect0:Effect, x:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (data1:Number) = negd(data0)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_negate, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryExpr* negd1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_negd, data0));
    Def* data1 = negd1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_bitnot: {
/***
abc_bitnot: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = noti(data0)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_bitnot, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryExpr* noti1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_noti, data0));
    Def* data1 = noti1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_negate_i: {
/***
abc_negate_i: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = negi(data0)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_negate_i, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryExpr* negi1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_negi, data0));
    Def* data1 = negi1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_sxi1: {
/***
abc_sxi1: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = lshi(data0, 31)
  (data2:Int) = rshi(data1, 31)
  () = return(effect1, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_sxi1, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    BinaryExpr* lshi1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lshi, data0, tb.intConst(31)));
    Def* data1 = lshi1->value_out(); (void)data1;

    BinaryExpr* rshi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_rshi, data1, tb.intConst(31)));
    Def* data2 = rshi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect1, data2));

    break;
  }

  case HR_abc_sxi8: {
/***
abc_sxi8: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = lshi(data0, 24)
  (data2:Int) = rshi(data1, 24)
  () = return(effect1, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_sxi8, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    BinaryExpr* lshi1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lshi, data0, tb.intConst(24)));
    Def* data1 = lshi1->value_out(); (void)data1;

    BinaryExpr* rshi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_rshi, data1, tb.intConst(24)));
    Def* data2 = rshi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect1, data2));

    break;
  }

  case HR_abc_sxi16: {
/***
abc_sxi16: (effect0:Effect, x:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (data1:Int) = lshi(data0, 16)
  (data2:Int) = rshi(data1, 16)
  () = return(effect1, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_sxi16, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    BinaryExpr* lshi1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lshi, data0, tb.intConst(16)));
    Def* data1 = lshi1->value_out(); (void)data1;

    BinaryExpr* rshi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_rshi, data1, tb.intConst(16)));
    Def* data2 = rshi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect1, data2));

    break;
  }

  case HR_abc_checkfilter: {
/***
abc_checkfilter: (effect0:Effect, x:Atom) -> (Effect, Atom~)
  (effect1:Effect, data0:Atom~) = cknull(effect0, x)
  (data1:Atom~) = ckfilter(data0)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_checkfilter, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;

    UnaryStmt* cknull0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_cknull, effect0, x));
    Def* effect1 = cknull0->effect_out(); (void)effect1;
    Def* data0 = cknull0->value_out(); (void)data0;

    UnaryExpr* ckfilter1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_ckfilter, data0));
    Def* data1 = ckfilter1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_abc_li8: {
/***
abc_li8: (effect0:Effect, addr:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, addr)
  (effect2:Effect, data1:Int) = li8(effect1, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_li8, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* addr = tb.paramRef(1); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, addr));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* li81 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_li8, effect1, data0));
    Def* effect2 = li81->effect_out(); (void)effect2;
    Def* data1 = li81->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_li16: {
/***
abc_li16: (effect0:Effect, addr:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, addr)
  (effect2:Effect, data1:Int) = li16(effect1, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_li16, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* addr = tb.paramRef(1); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, addr));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* li161 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_li16, effect1, data0));
    Def* effect2 = li161->effect_out(); (void)effect2;
    Def* data1 = li161->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_li32: {
/***
abc_li32: (effect0:Effect, addr:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, addr)
  (effect2:Effect, data1:Int) = li32(effect1, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_li32, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* addr = tb.paramRef(1); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, addr));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* li321 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_li32, effect1, data0));
    Def* effect2 = li321->effect_out(); (void)effect2;
    Def* data1 = li321->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_lf32: {
/***
abc_lf32: (effect0:Effect, addr:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Int) = toint(effect0, addr)
  (effect2:Effect, data1:Number) = lf32(effect1, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_lf32, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* addr = tb.paramRef(1); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, addr));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* lf321 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_lf32, effect1, data0));
    Def* effect2 = lf321->effect_out(); (void)effect2;
    Def* data1 = lf321->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_lf64: {
/***
abc_lf64: (effect0:Effect, addr:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Int) = toint(effect0, addr)
  (effect2:Effect, data1:Number) = lf64(effect1, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_lf64, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* addr = tb.paramRef(1); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, addr));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* lf641 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_lf64, effect1, data0));
    Def* effect2 = lf641->effect_out(); (void)effect2;
    Def* data1 = lf641->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_si8: {
/***
abc_si8: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, addr)
  (effect3:Effect, data2:Bot) = si8(effect2, data0, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_si8, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* addr = tb.paramRef(2); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, addr));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryStmt* si82 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_si8, effect2, data0, data1));
    Def* effect3 = si82->effect_out(); (void)effect3;
    Def* data2 = si82->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_abc_si16: {
/***
abc_si16: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, addr)
  (effect3:Effect, data2:Bot) = si16(effect2, data0, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_si16, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* addr = tb.paramRef(2); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, addr));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryStmt* si162 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_si16, effect2, data0, data1));
    Def* effect3 = si162->effect_out(); (void)effect3;
    Def* data2 = si162->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_abc_si32: {
/***
abc_si32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, addr)
  (effect3:Effect, data2:Bot) = si32(effect2, data0, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_si32, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* addr = tb.paramRef(2); (void)addr;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, addr));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryStmt* si322 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_si32, effect2, data0, data1));
    Def* effect3 = si322->effect_out(); (void)effect3;
    Def* data2 = si322->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_abc_sf32: {
/***
abc_sf32: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, addr)
  (effect3:Effect, data2:Bot) = sf32(effect2, data0, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_sf32, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* addr = tb.paramRef(2); (void)addr;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, addr));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryStmt* sf322 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_sf32, effect2, data0, data1));
    Def* effect3 = sf322->effect_out(); (void)effect3;
    Def* data2 = sf322->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_abc_sf64: {
/***
abc_sf64: (effect0:Effect, x:Atom, addr:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, addr)
  (effect3:Effect, data2:Bot) = sf64(effect2, data0, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_sf64, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* addr = tb.paramRef(2); (void)addr;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, addr));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryStmt* sf642 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_sf64, effect2, data0, data1));
    Def* effect3 = sf642->effect_out(); (void)effect3;
    Def* data2 = sf642->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_abc_subtract: {
/***
abc_subtract: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Number) = tonumber(effect1, y)
  (data2:Number) = subd(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_subtract, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* tonumber1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect1, y));
    Def* effect2 = tonumber1->effect_out(); (void)effect2;
    Def* data1 = tonumber1->value_out(); (void)data1;

    BinaryExpr* subd2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_subd, data0, data1));
    Def* data2 = subd2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_multiply: {
/***
abc_multiply: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Number) = tonumber(effect1, y)
  (data2:Number) = muld(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_multiply, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* tonumber1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect1, y));
    Def* effect2 = tonumber1->effect_out(); (void)effect2;
    Def* data1 = tonumber1->value_out(); (void)data1;

    BinaryExpr* muld2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_muld, data0, data1));
    Def* data2 = muld2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_modulo: {
/***
abc_modulo: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Number) = tonumber(effect1, y)
  (data2:Number) = modulo(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_modulo, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* tonumber1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect1, y));
    Def* effect2 = tonumber1->effect_out(); (void)effect2;
    Def* data1 = tonumber1->value_out(); (void)data1;

    BinaryExpr* modulo2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_modulo, data0, data1));
    Def* data2 = modulo2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_divide: {
/***
abc_divide: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Number) = tonumber(effect1, y)
  (data2:Number) = divd(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_divide, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* tonumber1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect1, y));
    Def* effect2 = tonumber1->effect_out(); (void)effect2;
    Def* data1 = tonumber1->value_out(); (void)data1;

    BinaryExpr* divd2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_divd, data0, data1));
    Def* data2 = divd2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_add_i: {
/***
abc_add_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = addi(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_add_i, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* addi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_addi, data0, data1));
    Def* data2 = addi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_subtract_i: {
/***
abc_subtract_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = subi(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_subtract_i, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* subi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_subi, data0, data1));
    Def* data2 = subi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_multiply_i: {
/***
abc_multiply_i: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = muli(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_multiply_i, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* muli2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_muli, data0, data1));
    Def* data2 = muli2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_bitor: {
/***
abc_bitor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = ori(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_bitor, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* ori2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_ori, data0, data1));
    Def* data2 = ori2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_bitand: {
/***
abc_bitand: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = andi(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_bitand, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* andi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_andi, data0, data1));
    Def* data2 = andi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_bitxor: {
/***
abc_bitxor: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = xori(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_bitxor, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* xori2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_xori, data0, data1));
    Def* data2 = xori2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_lshift: {
/***
abc_lshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = lshi(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_lshift, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* lshi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lshi, data0, data1));
    Def* data2 = lshi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_rshift: {
/***
abc_rshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Int) = rshi(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_rshift, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* rshi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_rshi, data0, data1));
    Def* data2 = rshi2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_urshift: {
/***
abc_urshift: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Uint)
  (effect1:Effect, data0:Int) = toint(effect0, x)
  (effect2:Effect, data1:Int) = toint(effect1, y)
  (data2:Uint) = rshui(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_urshift, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, x));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    UnaryStmt* toint1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect1, y));
    Def* effect2 = toint1->effect_out(); (void)effect2;
    Def* data1 = toint1->value_out(); (void)data1;

    BinaryExpr* rshui2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_rshui, data0, data1));
    Def* data2 = rshui2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_add_ui: {
/***
add_ui: (effect0:Effect, x:Uint, y:Int) -> (Effect, Number)
  (data0:Number) = u2d(x)
  (data1:Number) = i2d(y)
  (data2:Number) = addd(data0, data1)
  () = return(effect0, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.uint_type, lattice_.int_type };
    tb.start(HR_add_ui, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryExpr* u2d0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_u2d, x));
    Def* data0 = u2d0->value_out(); (void)data0;

    UnaryExpr* i2d1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_i2d, y));
    Def* data1 = i2d1->value_out(); (void)data1;

    BinaryExpr* addd2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_addd, data0, data1));
    Def* data2 = addd2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect0, data2));

    break;
  }

  case HR_add_nn: {
/***
add_nn: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, x)
  (effect2:Effect, data1:Number) = tonumber(effect1, y)
  (data2:Number) = addd(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_add_nn, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, x));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    UnaryStmt* tonumber1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect1, y));
    Def* effect2 = tonumber1->effect_out(); (void)effect2;
    Def* data1 = tonumber1->value_out(); (void)data1;

    BinaryExpr* addd2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_addd, data0, data1));
    Def* data2 = addd2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_add_ss: {
/***
add_ss: (effect0:Effect, x:Atom, y:Atom) -> (Effect, String~)
  (effect1:Effect, data0:String) = caststring(effect0, x)
  (effect2:Effect, data1:String) = caststring(effect1, y)
  (data2:String~) = concat_strings(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_add_ss, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* caststring0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_caststring, effect0, x));
    Def* effect1 = caststring0->effect_out(); (void)effect1;
    Def* data0 = caststring0->value_out(); (void)data0;

    UnaryStmt* caststring1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_caststring, effect1, y));
    Def* effect2 = caststring1->effect_out(); (void)effect2;
    Def* data1 = caststring1->value_out(); (void)data1;

    BinaryExpr* concat_strings2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_concat_strings, data0, data1));
    Def* data2 = concat_strings2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_lessthan: {
/***
abc_lessthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean)
  (effect1:Effect, data0:Atom) = toprimitive(effect0, x)
  (effect2:Effect, data1:Atom) = toprimitive(effect1, y)
  (data2:Boolean) = lessthan(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_lessthan, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toprimitive0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect0, x));
    Def* effect1 = toprimitive0->effect_out(); (void)effect1;
    Def* data0 = toprimitive0->value_out(); (void)data0;

    UnaryStmt* toprimitive1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect1, y));
    Def* effect2 = toprimitive1->effect_out(); (void)effect2;
    Def* data1 = toprimitive1->value_out(); (void)data1;

    BinaryExpr* lessthan2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lessthan, data0, data1));
    Def* data2 = lessthan2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_greaterequals: {
/***
abc_greaterequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean)
  (effect1:Effect, data0:Atom) = toprimitive(effect0, x)
  (effect2:Effect, data1:Atom) = toprimitive(effect1, y)
  (data2:Boolean) = greaterequals(data0, data1)
  () = return(effect2, data2)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_greaterequals, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toprimitive0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect0, x));
    Def* effect1 = toprimitive0->effect_out(); (void)effect1;
    Def* data0 = toprimitive0->value_out(); (void)data0;

    UnaryStmt* toprimitive1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect1, y));
    Def* effect2 = toprimitive1->effect_out(); (void)effect2;
    Def* data1 = toprimitive1->value_out(); (void)data1;

    BinaryExpr* greaterequals2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_greaterequals, data0, data1));
    Def* data2 = greaterequals2->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect2, data2));

    break;
  }

  case HR_abc_greaterthan: {
/***
abc_greaterthan: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean)
  (effect1:Effect, py:Atom) = toprimitive(effect0, y)
  (effect2:Effect, px:Atom) = toprimitive(effect1, x)
  (data0:Boolean) = greaterthan(px, py)
  () = return(effect2, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_greaterthan, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toprimitive0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect0, y));
    Def* effect1 = toprimitive0->effect_out(); (void)effect1;
    Def* py = toprimitive0->value_out(); (void)py;

    UnaryStmt* toprimitive1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect1, x));
    Def* effect2 = toprimitive1->effect_out(); (void)effect2;
    Def* px = toprimitive1->value_out(); (void)px;

    BinaryExpr* greaterthan2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_greaterthan, px, py));
    Def* data0 = greaterthan2->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect2, data0));

    break;
  }

  case HR_abc_lessequals: {
/***
abc_lessequals: (effect0:Effect, x:Atom, y:Atom) -> (Effect, Boolean)
  (effect1:Effect, py:Atom) = toprimitive(effect0, y)
  (effect2:Effect, px:Atom) = toprimitive(effect1, x)
  (data0:Boolean) = lessequals(px, py)
  () = return(effect2, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.atom_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_lessequals, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryStmt* toprimitive0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect0, y));
    Def* effect1 = toprimitive0->effect_out(); (void)effect1;
    Def* py = toprimitive0->value_out(); (void)py;

    UnaryStmt* toprimitive1 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toprimitive, effect1, x));
    Def* effect2 = toprimitive1->effect_out(); (void)effect2;
    Def* px = toprimitive1->value_out(); (void)px;

    BinaryExpr* lessequals2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_lessequals, px, py));
    Def* data0 = lessequals2->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect2, data0));

    break;
  }

  case HR_abc_equals_ii: {
/***
abc_equals_ii: (effect0:Effect, x:Int, y:Int) -> (Effect, Boolean)
  (data0:Boolean) = eqi(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.int_type, lattice_.int_type };
    tb.start(HR_abc_equals_ii, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* eqi0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_eqi, x, y));
    Def* data0 = eqi0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_equals_uu: {
/***
abc_equals_uu: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Boolean)
  (data0:Boolean) = equi(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.uint_type, lattice_.uint_type };
    tb.start(HR_abc_equals_uu, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* equi0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_equi, x, y));
    Def* data0 = equi0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_equals_bb: {
/***
abc_equals_bb: (effect0:Effect, x:Boolean, y:Boolean) -> (Effect, Boolean)
  (data0:Boolean) = eqb(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.boolean_type, lattice_.boolean_type };
    tb.start(HR_abc_equals_bb, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* eqb0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_eqb, x, y));
    Def* data0 = eqb0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_equals_nn: {
/***
abc_equals_nn: (effect0:Effect, x:Number, y:Number) -> (Effect, Boolean)
  (data0:Boolean) = eqd(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.double_type, lattice_.double_type };
    tb.start(HR_abc_equals_nn, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* eqd0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_eqd, x, y));
    Def* data0 = eqd0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_equals_pp: {
/***
abc_equals_pp: (effect0:Effect, x:ScriptObject, y:ScriptObject) -> (Effect, Boolean)
  (data0:Boolean) = eqp(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.scriptobject_type[kTypeNullable], lattice_.scriptobject_type[kTypeNullable] };
    tb.start(HR_abc_equals_pp, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* eqp0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_eqp, x, y));
    Def* data0 = eqp0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_equals_ss: {
/***
abc_equals_ss: (effect0:Effect, x:String, y:String) -> (Effect, Boolean)
  (data0:Boolean) = eqs(x, y)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.string_type[kTypeNullable], lattice_.string_type[kTypeNullable] };
    tb.start(HR_abc_equals_ss, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    BinaryExpr* eqs0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_eqs, x, y));
    Def* data0 = eqs0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_abc_getslot: {
/***
abc_getslot: (effect0:Effect, slot:Ord, object:ScriptObject) -> (Effect, TopData)
  (effect1:Effect, data0:ScriptObject~) = cknullobject(effect0, object)
  (effect2:Effect, data1:TopData) = getslot(effect1, slot, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNullable] };
    tb.start(HR_abc_getslot, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* slot = tb.paramRef(1); (void)slot;
    Def* object = tb.paramRef(2); (void)object;

    UnaryStmt* cknullobject0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_cknullobject, effect0, object));
    Def* effect1 = cknullobject0->effect_out(); (void)effect1;
    Def* data0 = cknullobject0->value_out(); (void)data0;

    CallStmt2* getslot1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_getslot, effect1, slot, data0));
    Def* effect2 = getslot1->effect_out(); (void)effect2;
    Def* data1 = getslot1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_getprop_slot: {
/***
abc_getprop_slot: (effect0:Effect, name:Name, any:ScriptObject) -> (Effect, TopData)
  (data0:Ord) = toslot(any, name)
  (effect1:Effect, data1:TopData) = abc_getslot(effect0, data0, any)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, NAME, lattice_.scriptobject_type[kTypeNullable] };
    tb.start(HR_abc_getprop_slot, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* any = tb.paramRef(2); (void)any;

    BinaryExpr* toslot0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_toslot, any, name));
    Def* data0 = toslot0->value_out(); (void)data0;

    CallStmt2* abc_getslot1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_abc_getslot, effect0, data0, any));
    Def* effect1 = abc_getslot1->effect_out(); (void)effect1;
    Def* data1 = abc_getslot1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_getpropx_u: {
/***
getpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = getpropertylate_u(effect0, index, object)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.atom_type[kTypeNotNull] };
    tb.start(HR_getpropx_u, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;

    BinaryStmt* getpropertylate_u0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_getpropertylate_u, effect0, index, object));
    Def* effect1 = getpropertylate_u0->effect_out(); (void)effect1;
    Def* data0 = getpropertylate_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_i: {
/***
getpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = getpropertylate_i(effect0, index, object)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.atom_type[kTypeNotNull] };
    tb.start(HR_getpropx_i, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;

    BinaryStmt* getpropertylate_i0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_getpropertylate_i, effect0, index, object));
    Def* effect1 = getpropertylate_i0->effect_out(); (void)effect1;
    Def* data0 = getpropertylate_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_d: {
/***
getpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = getpropertylate_d(effect0, index, object)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.atom_type[kTypeNotNull] };
    tb.start(HR_getpropx_d, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;

    BinaryStmt* getpropertylate_d0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_getpropertylate_d, effect0, index, object));
    Def* effect1 = getpropertylate_d0->effect_out(); (void)effect1;
    Def* data0 = getpropertylate_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_au: {
/***
getpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = array_get_u(effect0, index, array)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.array_type[kTypeNotNull] };
    tb.start(HR_getpropx_au, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;

    BinaryStmt* array_get_u0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_array_get_u, effect0, index, array));
    Def* effect1 = array_get_u0->effect_out(); (void)effect1;
    Def* data0 = array_get_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_ai: {
/***
getpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = array_get_i(effect0, index, array)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.array_type[kTypeNotNull] };
    tb.start(HR_getpropx_ai, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;

    BinaryStmt* array_get_i0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_array_get_i, effect0, index, array));
    Def* effect1 = array_get_i0->effect_out(); (void)effect1;
    Def* data0 = array_get_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_ad: {
/***
getpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~) -> (Effect, Atom)
  (effect1:Effect, data0:Atom) = array_get_d(effect0, index, array)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.array_type[kTypeNotNull] };
    tb.start(HR_getpropx_ad, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;

    BinaryStmt* array_get_d0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_array_get_d, effect0, index, array));
    Def* effect1 = array_get_d0->effect_out(); (void)effect1;
    Def* data0 = array_get_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_viu: {
/***
getpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~) -> (Effect, Int)
  (effect1:Effect, data0:Int) = vectorint_get_u(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull] };
    tb.start(HR_getpropx_viu, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectorint_get_u0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectorint_get_u, effect0, index, vector));
    Def* effect1 = vectorint_get_u0->effect_out(); (void)effect1;
    Def* data0 = vectorint_get_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vii: {
/***
getpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~) -> (Effect, Int)
  (effect1:Effect, data0:Int) = vectorint_get_i(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull] };
    tb.start(HR_getpropx_vii, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectorint_get_i0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectorint_get_i, effect0, index, vector));
    Def* effect1 = vectorint_get_i0->effect_out(); (void)effect1;
    Def* data0 = vectorint_get_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vid: {
/***
getpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~) -> (Effect, Int)
  (effect1:Effect, data0:Int) = vectorint_get_d(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull] };
    tb.start(HR_getpropx_vid, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectorint_get_d0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectorint_get_d, effect0, index, vector));
    Def* effect1 = vectorint_get_d0->effect_out(); (void)effect1;
    Def* data0 = vectorint_get_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vuu: {
/***
getpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~) -> (Effect, Uint)
  (effect1:Effect, data0:Uint) = vectoruint_get_u(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull] };
    tb.start(HR_getpropx_vuu, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectoruint_get_u0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectoruint_get_u, effect0, index, vector));
    Def* effect1 = vectoruint_get_u0->effect_out(); (void)effect1;
    Def* data0 = vectoruint_get_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vui: {
/***
getpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~) -> (Effect, Uint)
  (effect1:Effect, data0:Uint) = vectoruint_get_i(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull] };
    tb.start(HR_getpropx_vui, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectoruint_get_i0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectoruint_get_i, effect0, index, vector));
    Def* effect1 = vectoruint_get_i0->effect_out(); (void)effect1;
    Def* data0 = vectoruint_get_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vud: {
/***
getpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~) -> (Effect, Uint)
  (effect1:Effect, data0:Uint) = vectoruint_get_d(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull] };
    tb.start(HR_getpropx_vud, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectoruint_get_d0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectoruint_get_d, effect0, index, vector));
    Def* effect1 = vectoruint_get_d0->effect_out(); (void)effect1;
    Def* data0 = vectoruint_get_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vdu: {
/***
getpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~) -> (Effect, Number)
  (effect1:Effect, data0:Number) = vectordouble_get_u(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull] };
    tb.start(HR_getpropx_vdu, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectordouble_get_u0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectordouble_get_u, effect0, index, vector));
    Def* effect1 = vectordouble_get_u0->effect_out(); (void)effect1;
    Def* data0 = vectordouble_get_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vdi: {
/***
getpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~) -> (Effect, Number)
  (effect1:Effect, data0:Number) = vectordouble_get_i(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull] };
    tb.start(HR_getpropx_vdi, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectordouble_get_i0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectordouble_get_i, effect0, index, vector));
    Def* effect1 = vectordouble_get_i0->effect_out(); (void)effect1;
    Def* data0 = vectordouble_get_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_getpropx_vdd: {
/***
getpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~) -> (Effect, Number)
  (effect1:Effect, data0:Number) = vectordouble_get_d(effect0, index, vector)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull] };
    tb.start(HR_getpropx_vdd, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;

    BinaryStmt* vectordouble_get_d0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_vectordouble_get_d, effect0, index, vector));
    Def* effect1 = vectordouble_get_d0->effect_out(); (void)effect1;
    Def* data0 = vectordouble_get_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_abc_setprop_slot: {
/***
abc_setprop_slot: (effect0:Effect, name:Name, object:ScriptObject, val:Atom) -> (Effect, Bot)
  (data0:Ord) = toslot(object, name)
  (effect1:Effect, data1:Bot) = abc_setslot(effect0, data0, object, val)
  () = return(effect1, data1)
***/

    const Type* in_types[] = { EFFECT, NAME, lattice_.scriptobject_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_setprop_slot, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* object = tb.paramRef(2); (void)object;
    Def* val = tb.paramRef(3); (void)val;

    BinaryExpr* toslot0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_toslot, object, name));
    Def* data0 = toslot0->value_out(); (void)data0;

    CallStmt2* abc_setslot1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_abc_setslot, effect0, data0, object, val));
    Def* effect1 = abc_setslot1->effect_out(); (void)effect1;
    Def* data1 = abc_setslot1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect1, data1));

    break;
  }

  case HR_setpropx_u: {
/***
setpropx_u: (effect0:Effect, name:Top, index:Uint, object:Atom~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = setpropertylate_u(effect0, index, object, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_u, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* setpropertylate_u0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_setpropertylate_u, effect0, index, object, val));
    Def* effect1 = setpropertylate_u0->effect_out(); (void)effect1;
    Def* data0 = setpropertylate_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_i: {
/***
setpropx_i: (effect0:Effect, name:Top, index:Int, object:Atom~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = setpropertylate_i(effect0, index, object, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_i, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* setpropertylate_i0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_setpropertylate_i, effect0, index, object, val));
    Def* effect1 = setpropertylate_i0->effect_out(); (void)effect1;
    Def* data0 = setpropertylate_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_d: {
/***
setpropx_d: (effect0:Effect, name:Top, index:Number, object:Atom~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = setpropertylate_d(effect0, index, object, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.atom_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_d, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* object = tb.paramRef(3); (void)object;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* setpropertylate_d0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_setpropertylate_d, effect0, index, object, val));
    Def* effect1 = setpropertylate_d0->effect_out(); (void)effect1;
    Def* data0 = setpropertylate_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_au: {
/***
setpropx_au: (effect0:Effect, name:Top, index:Uint, array:Array~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = array_set_u(effect0, index, array, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_au, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* array_set_u0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_array_set_u, effect0, index, array, val));
    Def* effect1 = array_set_u0->effect_out(); (void)effect1;
    Def* data0 = array_set_u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_ai: {
/***
setpropx_ai: (effect0:Effect, name:Top, index:Int, array:Array~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = array_set_i(effect0, index, array, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_ai, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* array_set_i0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_array_set_i, effect0, index, array, val));
    Def* effect1 = array_set_i0->effect_out(); (void)effect1;
    Def* data0 = array_set_i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_ad: {
/***
setpropx_ad: (effect0:Effect, name:Top, index:Number, array:Array~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Bot) = array_set_d(effect0, index, array, val)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.array_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_ad, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* array = tb.paramRef(3); (void)array;
    Def* val = tb.paramRef(4); (void)val;

    CallStmt2* array_set_d0 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_array_set_d, effect0, index, array, val));
    Def* effect1 = array_set_d0->effect_out(); (void)effect1;
    Def* data0 = array_set_d0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_setpropx_viu: {
/***
setpropx_viu: (effect0:Effect, name:Top, index:Uint, vector:VectorInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, val)
  (effect2:Effect, data1:Bot) = vectorint_set_u(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_viu, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, val));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    CallStmt2* vectorint_set_u1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectorint_set_u, effect1, index, vector, data0));
    Def* effect2 = vectorint_set_u1->effect_out(); (void)effect2;
    Def* data1 = vectorint_set_u1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vii: {
/***
setpropx_vii: (effect0:Effect, name:Top, index:Int, vector:VectorInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, val)
  (effect2:Effect, data1:Bot) = vectorint_set_i(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vii, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, val));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    CallStmt2* vectorint_set_i1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectorint_set_i, effect1, index, vector, data0));
    Def* effect2 = vectorint_set_i1->effect_out(); (void)effect2;
    Def* data1 = vectorint_set_i1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vid: {
/***
setpropx_vid: (effect0:Effect, name:Top, index:Number, vector:VectorInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Int) = toint(effect0, val)
  (effect2:Effect, data1:Bot) = vectorint_set_d(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectorint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vid, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, val));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    CallStmt2* vectorint_set_d1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectorint_set_d, effect1, index, vector, data0));
    Def* effect2 = vectorint_set_d1->effect_out(); (void)effect2;
    Def* data1 = vectorint_set_d1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vuu: {
/***
setpropx_vuu: (effect0:Effect, name:Top, index:Uint, vector:VectorUInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Uint) = touint(effect0, val)
  (effect2:Effect, data1:Bot) = vectoruint_set_u(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vuu, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* touint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_touint, effect0, val));
    Def* effect1 = touint0->effect_out(); (void)effect1;
    Def* data0 = touint0->value_out(); (void)data0;

    CallStmt2* vectoruint_set_u1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectoruint_set_u, effect1, index, vector, data0));
    Def* effect2 = vectoruint_set_u1->effect_out(); (void)effect2;
    Def* data1 = vectoruint_set_u1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vui: {
/***
setpropx_vui: (effect0:Effect, name:Top, index:Int, vector:VectorUInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Uint) = touint(effect0, val)
  (effect2:Effect, data1:Bot) = vectoruint_set_i(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vui, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* touint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_touint, effect0, val));
    Def* effect1 = touint0->effect_out(); (void)effect1;
    Def* data0 = touint0->value_out(); (void)data0;

    CallStmt2* vectoruint_set_i1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectoruint_set_i, effect1, index, vector, data0));
    Def* effect2 = vectoruint_set_i1->effect_out(); (void)effect2;
    Def* data1 = vectoruint_set_i1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vud: {
/***
setpropx_vud: (effect0:Effect, name:Top, index:Number, vector:VectorUInt~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Uint) = touint(effect0, val)
  (effect2:Effect, data1:Bot) = vectoruint_set_d(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectoruint_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vud, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* touint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_touint, effect0, val));
    Def* effect1 = touint0->effect_out(); (void)effect1;
    Def* data0 = touint0->value_out(); (void)data0;

    CallStmt2* vectoruint_set_d1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectoruint_set_d, effect1, index, vector, data0));
    Def* effect2 = vectoruint_set_d1->effect_out(); (void)effect2;
    Def* data1 = vectoruint_set_d1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vdu: {
/***
setpropx_vdu: (effect0:Effect, name:Top, index:Uint, vector:VectorDouble~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Number) = tonumber(effect0, val)
  (effect2:Effect, data1:Bot) = vectordouble_set_u(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.uint_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vdu, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, val));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    CallStmt2* vectordouble_set_u1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectordouble_set_u, effect1, index, vector, data0));
    Def* effect2 = vectordouble_set_u1->effect_out(); (void)effect2;
    Def* data1 = vectordouble_set_u1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vdi: {
/***
setpropx_vdi: (effect0:Effect, name:Top, index:Int, vector:VectorDouble~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Number) = tonumber(effect0, val)
  (effect2:Effect, data1:Bot) = vectordouble_set_i(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.int_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vdi, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, val));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    CallStmt2* vectordouble_set_i1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectordouble_set_i, effect1, index, vector, data0));
    Def* effect2 = vectordouble_set_i1->effect_out(); (void)effect2;
    Def* data1 = vectordouble_set_i1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_setpropx_vdd: {
/***
setpropx_vdd: (effect0:Effect, name:Top, index:Number, vector:VectorDouble~, val:Atom) -> (Effect, Bot)
  (effect1:Effect, data0:Number) = tonumber(effect0, val)
  (effect2:Effect, data1:Bot) = vectordouble_set_d(effect1, index, vector, data0)
  () = return(effect2, data1)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.double_type, lattice_.vectordouble_type[kTypeNotNull], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_setpropx_vdd, 5, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* index = tb.paramRef(2); (void)index;
    Def* vector = tb.paramRef(3); (void)vector;
    Def* val = tb.paramRef(4); (void)val;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, val));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    CallStmt2* vectordouble_set_d1 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_vectordouble_set_d, effect1, index, vector, data0));
    Def* effect2 = vectordouble_set_d1->effect_out(); (void)effect2;
    Def* data1 = vectordouble_set_d1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect2, data1));

    break;
  }

  case HR_abc_setslot: {
/***
abc_setslot: (effect0:Effect, slot:Ord, object:ScriptObject, val:Atom) -> (Effect, Bot)
  (effect1:Effect, ptr:ScriptObject~) = cknullobject(effect0, object)
  (data0:Traits) = slottype(ptr, slot)
  (effect2:Effect, data1:data0) = coerce(effect1, data0, val)
  (effect3:Effect, data2:Bot) = setslot(effect2, slot, ptr, data1)
  () = return(effect3, data2)
***/

    const Type* in_types[] = { EFFECT, ORDINAL, lattice_.scriptobject_type[kTypeNullable], lattice_.atom_type[kTypeNullable] };
    tb.start(HR_abc_setslot, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* slot = tb.paramRef(1); (void)slot;
    Def* object = tb.paramRef(2); (void)object;
    Def* val = tb.paramRef(3); (void)val;

    UnaryStmt* cknullobject0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_cknullobject, effect0, object));
    Def* effect1 = cknullobject0->effect_out(); (void)effect1;
    Def* ptr = cknullobject0->value_out(); (void)ptr;

    BinaryExpr* slottype1 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_slottype, ptr, slot));
    Def* data0 = slottype1->value_out(); (void)data0;

    BinaryStmt* coerce2 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_coerce, effect1, data0, val));
    Def* effect2 = coerce2->effect_out(); (void)effect2;
    Def* data1 = coerce2->value_out(); (void)data1;

    CallStmt2* setslot3 = (CallStmt2*)tb.addInstr(newCallStmt2(HR_setslot, effect2, slot, ptr, data1));
    Def* effect3 = setslot3->effect_out(); (void)effect3;
    Def* data2 = setslot3->value_out(); (void)data2;

    tb.addInstr(newStopInstr(HR_return, effect3, data2));

    break;
  }

  case HR_findprop2finddef: {
/***
findprop2finddef: (effect0:Effect, name:Env, env:Name, scopes:Top) -> (Effect, ScriptObject~)
  (effect1:Effect, data0:ScriptObject~) = abc_finddef(effect0, env, name)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, ENV, NAME, TOP };
    tb.start(HR_findprop2finddef, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* env = tb.paramRef(2); (void)env;
    Def* scopes = tb.paramRef(3); (void)scopes;

    BinaryStmt* abc_finddef0 = (BinaryStmt*)tb.addInstr(newBinaryStmt(HR_abc_finddef, effect0, env, name));
    Def* effect1 = abc_finddef0->effect_out(); (void)effect1;
    Def* data0 = abc_finddef0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_findprop2getouter: {
/***
findprop2getouter: (effect0:Effect, index:Ord, env:Env, scopes:Top) -> (Effect, Atom~)
  (data0:Atom~) = getouterscope(index, env)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, ORDINAL, ENV, TOP };
    tb.start(HR_findprop2getouter, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* index = tb.paramRef(1); (void)index;
    Def* env = tb.paramRef(2); (void)env;
    Def* scopes = tb.paramRef(3); (void)scopes;

    BinaryExpr* getouterscope0 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_getouterscope, index, env));
    Def* data0 = getouterscope0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_callprop_string: {
/***
callprop_string: (effect0:Effect, name:Top, stringclass:Top, value:Atom) -> (Effect, String~)
  (effect1:Effect, data0:String~) = abc_convert_s(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_callprop_string, 4, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* name = tb.paramRef(1); (void)name;
    Def* stringclass = tb.paramRef(2); (void)stringclass;
    Def* value = tb.paramRef(3); (void)value;

    UnaryStmt* abc_convert_s0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_abc_convert_s, effect0, value));
    Def* effect1 = abc_convert_s0->effect_out(); (void)effect1;
    Def* data0 = abc_convert_s0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_coerce_any: {
/***
coerce_any: (effect0:Effect, traits:Top, value:Top) -> (Effect, Top)
  () = return(effect0, value)
***/

    const Type* in_types[] = { EFFECT, TOP, TOP };
    tb.start(HR_coerce_any, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    tb.addInstr(newStopInstr(HR_return, effect0, value));

    break;
  }

  case HR_coerce_object: {
/***
coerce_object: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Atom)
  (data0:Atom) = castobject(value)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_object, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryExpr* castobject0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_castobject, value));
    Def* data0 = castobject0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_coerce_number: {
/***
coerce_number: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Number)
  (effect1:Effect, data0:Number) = tonumber(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_number, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryStmt* tonumber0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_tonumber, effect0, value));
    Def* effect1 = tonumber0->effect_out(); (void)effect1;
    Def* data0 = tonumber0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_coerce_int: {
/***
coerce_int: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Int)
  (effect1:Effect, data0:Int) = toint(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_int, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryStmt* toint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_toint, effect0, value));
    Def* effect1 = toint0->effect_out(); (void)effect1;
    Def* data0 = toint0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_coerce_uint: {
/***
coerce_uint: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Uint)
  (effect1:Effect, data0:Uint) = touint(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_uint, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryStmt* touint0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_touint, effect0, value));
    Def* effect1 = touint0->effect_out(); (void)effect1;
    Def* data0 = touint0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_coerce_boolean: {
/***
coerce_boolean: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Boolean)
  (data0:Boolean) = toboolean(value)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_boolean, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryExpr* toboolean0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_toboolean, value));
    Def* data0 = toboolean0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_coerce_string: {
/***
coerce_string: (effect0:Effect, traits:Top, value:Atom) -> (Effect, String)
  (effect1:Effect, data0:String) = caststring(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_string, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryStmt* caststring0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_caststring, effect0, value));
    Def* effect1 = caststring0->effect_out(); (void)effect1;
    Def* data0 = caststring0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_coerce_ns: {
/***
coerce_ns: (effect0:Effect, traits:Top, value:Atom) -> (Effect, Namespace)
  (effect1:Effect, data0:Namespace) = castns(effect0, value)
  () = return(effect1, data0)
***/

    const Type* in_types[] = { EFFECT, TOP, lattice_.atom_type[kTypeNullable] };
    tb.start(HR_coerce_ns, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* traits = tb.paramRef(1); (void)traits;
    Def* value = tb.paramRef(2); (void)value;

    UnaryStmt* castns0 = (UnaryStmt*)tb.addInstr(newUnaryStmt(HR_castns, effect0, value));
    Def* effect1 = castns0->effect_out(); (void)effect1;
    Def* data0 = castns0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect1, data0));

    break;
  }

  case HR_inttouint: {
/***
inttouint: (effect0:Effect, value:Int) -> (Effect, Uint)
  (data0:Uint) = i2u(value)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.int_type };
    tb.start(HR_inttouint, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* value = tb.paramRef(1); (void)value;

    UnaryExpr* i2u0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_i2u, value));
    Def* data0 = i2u0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_uinttoint: {
/***
uinttoint: (effect0:Effect, value:Uint) -> (Effect, Int)
  (data0:Int) = u2i(value)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.uint_type };
    tb.start(HR_uinttoint, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* value = tb.paramRef(1); (void)value;

    UnaryExpr* u2i0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_u2i, value));
    Def* data0 = u2i0->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_numbertoint: {
/***
numbertoint: (effect0:Effect, value:Number) -> (Effect, Int)
  (data0:Int) = doubletoint32(value)
  () = return(effect0, data0)
***/

    const Type* in_types[] = { EFFECT, lattice_.double_type };
    tb.start(HR_numbertoint, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* value = tb.paramRef(1); (void)value;

    UnaryExpr* doubletoint320 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_doubletoint32, value));
    Def* data0 = doubletoint320->value_out(); (void)data0;

    tb.addInstr(newStopInstr(HR_return, effect0, data0));

    break;
  }

  case HR_numbertouint: {
/***
numbertouint: (effect0:Effect, value:Number) -> (Effect, Uint)
  (data0:Int) = doubletoint32(value)
  (data1:Uint) = i2u(data0)
  () = return(effect0, data1)
***/

    const Type* in_types[] = { EFFECT, lattice_.double_type };
    tb.start(HR_numbertouint, 2, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* value = tb.paramRef(1); (void)value;

    UnaryExpr* doubletoint320 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_doubletoint32, value));
    Def* data0 = doubletoint320->value_out(); (void)data0;

    UnaryExpr* i2u1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_i2u, data0));
    Def* data1 = i2u1->value_out(); (void)data1;

    tb.addInstr(newStopInstr(HR_return, effect0, data1));

    break;
  }

  case HR_abc_modulo_and: {
/***
abc_modulo_and: (effect0:Effect, x:Uint, y:Uint) -> (Effect, Uint)
  (data0:Int) = u2i(x)
  (data1:Int) = u2i(y)
  (data2:Int) = subi(data1, 1)
  (data3:Int) = andi(data0, data2)
  (data4:Uint) = i2u(data3)
  () = return(effect0, data4)
***/

    const Type* in_types[] = { EFFECT, lattice_.uint_type, lattice_.uint_type };
    tb.start(HR_abc_modulo_and, 3, in_types);

    Def* effect0 = tb.paramRef(0); (void)effect0;
    Def* x = tb.paramRef(1); (void)x;
    Def* y = tb.paramRef(2); (void)y;

    UnaryExpr* u2i0 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_u2i, x));
    Def* data0 = u2i0->value_out(); (void)data0;

    UnaryExpr* u2i1 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_u2i, y));
    Def* data1 = u2i1->value_out(); (void)data1;

    BinaryExpr* subi2 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_subi, data1, tb.intConst(1)));
    Def* data2 = subi2->value_out(); (void)data2;

    BinaryExpr* andi3 = (BinaryExpr*)tb.addInstr(newBinaryExpr(HR_andi, data0, data2));
    Def* data3 = andi3->value_out(); (void)data3;

    UnaryExpr* i2u4 = (UnaryExpr*)tb.addInstr(newUnaryExpr(HR_i2u, data3));
    Def* data4 = i2u4->value_out(); (void)data4;

    tb.addInstr(newStopInstr(HR_return, effect0, data4));

    break;
  }

